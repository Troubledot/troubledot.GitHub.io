<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>你加我不等于我们</title>
      <link href="/2019/02/27/%E4%BD%A0%E5%8A%A0%E6%88%91%E4%B8%8D%E7%AD%89%E4%BA%8E%E6%88%91%E4%BB%AC/"/>
      <url>/2019/02/27/%E4%BD%A0%E5%8A%A0%E6%88%91%E4%B8%8D%E7%AD%89%E4%BA%8E%E6%88%91%E4%BB%AC/</url>
      <content type="html"><![CDATA[<p>前两天偶然在知乎上看到一个男生在吐苦水：他对女朋友特别好，每天拼了命的工作想买车买房为她提供更好的条件，但是最好她却跟另外一个男生好了，仅仅因为那个男生送了她一只卡西欧的手表，把手机壁纸换成了她的照片。</p><p>乍一看，确实令人不解，但是这时候有人问到：你买车买房真的是为了她吗？</p><p>我们仔细想想，其实车房是为了将来跟你结婚组建家庭的那个人，那个人可以是她也可以是别人。这么看来那块卡西欧手表倒是真正的属于她，这份爱廉价但却很真实。</p><p>好多人以为两个人在一起的关系就像这样简单：<br><img src="http://res.troubledot.cn/we-1.png" alt=""></p><p>你和我组成了我们，我为我们的努力也都是为了你。</p><p>实际上我感觉两个人在一起更像是这样</p><p><img src="http://res.troubledot.cn/we.png" alt=""></p><p>你我并非我们的子集。怎么理解呢，两个人在一起，即使他们已经结婚生子，但每个人依然会有一部分真正属于自己的东西和空间，就是图中的12区域，比如说女生的口红包包，男生的游戏机手办之类的。上面那位男生提到的车房应该是属于4区域，是那类两人共用但是偏向于自己的物品，而另一位男生的手表和壁纸都是在1区的，如此看来女生get不到他深沉的爱也就不难理解了。</p><p>刚好前段时间情人节，那天没有给自己女朋友或者妻子准备礼物的男生借口应该都差不多：工作忙，平时为了家都这么累了，没有精力准备以及不过这种西方节日。</p><p>内心戏也都差不多：难道就因为今天没有礼物就要否定我平时对你的好吗？</p><p>而女孩子面对这种情况大体就这几种情况：</p><p>知书达理内心善良女生面对这种情况只是嘴上抱怨几句，心里会有一点小失落：如果能像别人那样收到礼物该多好呀。</p><p>有点小矫情的女生：会跟你吵一架，闹闹脾气。</p><p>关注咪蒙的小仙女们：这样的男朋友不分还留着过年？</p><p>生活中大多数女生是前两种，其实我们只要花一点点功夫就能让她们开心好久，哪怕是你临时买的一支花，再或者楼下小超市买的一盒酸奶甚至是同事酒席上装口袋里的一把瓜子喜糖。</p><p>之前刷抖音的时候，看到一个小视频，一个农村阿姨正在地头劳作，收到了老公的一束花，但是这应该是她一生中第一次收到花，她先是一脸惊讶，紧接着眼泪唰一下就下来了，嘴上抱怨着：买这干啥，买这干啥。手上小心翼翼的把花拿过去了。我们知道这花有可能是为了拍视频准备的，但是这种感动是演不出来的。她是家里的女主人，所以她理解丈夫的压力，理解生活的艰辛，同时她又是妻子，她也渴望着丈夫的爱。</p><p>都说男生的快乐很简单，女生何尝不是呢。许多男人在抱怨妻子不理解的时候，可曾想过自己在为1区付出过多少，爱是需要表达出来的，而那个将与你相互扶持走过大半生的人值得你所有的爱。</p><p>换男生的角度来说，这个大冬天下楼给你买早点，碰到啥好吃的都为你留一口的男孩子其实也需要关怀和爱，他跟你其实没有多大区别，如果你们没有在一起，他可能就是你公司里面的小张小李，生病的时候同样需要人来照顾，月底交房租水电费的时候同样也会仔细多算几次，被领导批评的时候同样会难堪。。。在当前这个社会背景下，跟你年纪相仿的他要承载更多，你的一句关心，一个笑脸就能给他带来一个轻松的心情，何乐不为呢。</p><p>礼物只是一种经营关系的方式，其实不需要太过贵重，只要在12区域即可，男朋友生日你送他剃须刀肯定是要好过豆浆机的，哪怕你答应她天天6点起来给他打豆浆喝，这里的豆浆机就是5区的物品，女朋友过生日，你送她一支十块钱的玫瑰花都要强过一台2000块的全自动洗衣机（例子比较极端，当然不排除真有人这么干）。</p><p>跟一个完全陌生的人结合并共度人生的大部分时间，本就不是一件简单的事情。将这份感情经营好是要花费精力在上面的，千万不要妄想着靠那点可怜的荷尔蒙来为我们今后的几十年持续不断的提供多巴胺。</p><p>从现代人的出现到现在，有统计显示地球上生活过1170亿人，能在同一时空相遇又相爱需要多大的缘分啊，这份缘分难道不值得我们花精力去守护吗？</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>三十出头的你还想有个人依靠？</title>
      <link href="/2019/02/25/%E4%B8%89%E5%8D%81%E5%87%BA%E5%A4%B4%E7%9A%84%E4%BD%A0%E8%BF%98%E6%83%B3%E6%9C%89%E4%B8%AA%E4%BA%BA%E4%BE%9D%E9%9D%A0%EF%BC%9F/"/>
      <url>/2019/02/25/%E4%B8%89%E5%8D%81%E5%87%BA%E5%A4%B4%E7%9A%84%E4%BD%A0%E8%BF%98%E6%83%B3%E6%9C%89%E4%B8%AA%E4%BA%BA%E4%BE%9D%E9%9D%A0%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>90年生人，身份证上是89年。按照老家的说法满打满算三十了。在这个城市待了8年多了，生活毫无起色，前几天和她吵架了，常常在她面前说教控制情绪的我还是没能幸免，该说的不该说的都说了。</p><p>仔细想想自己做人做事好像都挺失败的，只不过一直不愿意承认罢了，其实身边最熟悉的人们也都在极力帮我隐瞒这个事实，也难为他们了。</p><p>一个人在外边晃了三天了，昨晚上十一点多在大街上不停地打开“美团”刷附近的酒店，路过汉庭进去问了下，一夜240，喝了一口水掩饰尴尬：“那算了，我再去找找”。甚至不敢多看一眼前台服务人员，像极了上学时候问到一条200多的裤子。</p><p>背个包在大街上继续游荡，仿佛一个孤魂野鬼，路过万达，对面是一家24小时营业的牛肉面馆，在隔壁KTV喝嗨了的人三五成群的来这里吃饭，有一对小情侣说说笑笑的闹着走进了旁边的小区，突然发现我也许从来就没有属于过这座城市。我曾经给她说过在这里只有我们俩相依为命，我一直以为这只是我安慰她的话，毕竟这可是我甘肃老家啊，现在发现这个城市于她于我并无两样。</p><p><strong>家不是地方也不是房子，我们在这个陌生的城市里真的只有彼此。</strong></p><p>她说她要跟她妈一起回家。妈是依靠，家是依靠。委屈的时候可以回家找妈，真好。。</p><p>我也想家了，有点想老赵了，想回家或者打个电话给他。随即马上打消了这个念头，只会让他徒增烦恼罢了，我并不算是个多争气的儿子。</p><p>早上在外面吃饭的时候，接到老赵的电话：“一切都好，不要再操心了，放心吧都好着呢。”匆匆挂了电话，差点没忍住哭出声来。</p><p>正好赶上旁边一所中学放学了，到处都是中学生，感觉自己真的有点格格不入，仔细看看就会发现他们脸上的笑真的好好看啊。</p><p>突然想到了自己初中的时候，想起了我的发小mtr，其实我真的很感激他，母亲病了以后父亲为生活疲于奔命，我哥也自顾不暇。从初中开始就是他一直在照顾我，去食堂他负责打饭付钱，我等着吃就好了，去网吧上网他负责开机子登记身份证，我开机玩就成，去酒吧喝酒他负责订包厢去跟各路朋友应酬交涉，我只负责玩我自己的，甚至我叫了我的朋友他也可以帮我暖场招呼好，跟同学打闹的时候我被踢了一脚，他误会了给我出头要跟人动手，他妈也对我特别好，做各种各样好吃的给我俩，来给他陪读的时候下午会把我的饭也做好，那会儿其实也会羡慕。说实话自我记事起好像就再没有过这样的经历。</p><p>前段时间他打电话跟我说怕我现在过的不好怪他当年带我瞎玩没好好学习，提到了他特别想在我结婚的时候能给我全程操办着，给我把面子涨足，虽然当时表现的很云淡风轻，说实话我被感动到了。</p><p>找他吗？他儿子一岁了，他有他的家长里短，生活过的没有那么顺心，这些琐事好像说不到他头上。</p><p>突然发现除了她我好像本来就没有一个能说说话的人，可笑的是我还曾说过她没有什么好闺蜜。</p><p>我并不是一个能独当一面的人，不是一个能给别人安全感的人，以前有朋友说过我自己都是一个需要照顾的人还怎么去照顾别人，事实证明也的确如此。其实我的性格有明显的缺陷：极度敏感，抱怨领导，抱怨同事，有时候负能量爆棚，不断的逃避现实，好多事情的处理显得极为幼稚，而最后只能默默的自吞苦果。好多时候我清楚我的内心其实并不豁达，我的性子也并非玩世不恭，只是不愿意面对这个让自己失望的自己而已。</p><p>白天时间过的好快啊，天又快黑了，冬天的这种时候还在大街上没能回家，这是最让我烦心的事情。</p><p>车水马龙，万家灯火，广场上的大叔大妈们按时跳起了广场舞，我突然感觉好讨厌这里，好讨厌这个城市。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>函数的扩展</title>
      <link href="/2019/01/16/%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/"/>
      <url>/2019/01/16/%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/</url>
      <content type="html"><![CDATA[<h3 id="1-函数参数的默认值"><a href="#1-函数参数的默认值" class="headerlink" title="1.函数参数的默认值"></a>1.函数参数的默认值</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>es6之前，函数的参数不能给默认值的，如果一定要给，只能用变通的方法；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function log(x,y)&#123;</span><br><span class="line">y = y||&apos;Word&apos;;</span><br><span class="line">console.log(x,y)</span><br><span class="line">&#125;</span><br><span class="line">log(&apos;Hello&apos;) // Hello World</span><br><span class="line">log(&apos;Hello&apos;, &apos;China&apos;) // Hello China</span><br><span class="line">log(&apos;Hello&apos;, &apos;&apos;) // Hello World</span><br></pre></td></tr></table></figure><p>这样的问题就在于如果y是一个boll值为false的值，那么他就会取到默认值。就像上面最后一行代码，我们预期输出的应该是‘Hello ’，但是因为我们给y赋的值对应的布尔值为false，所以他最后读了默认值World。这里我们就需要额外判断一次y是否被赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (typeof y === &apos;undefined&apos;) &#123;</span><br><span class="line">  y = &apos;World&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是现在es6解决了这个问题，我们可以在定义参数的时候直接为其赋一个默认值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function log(x, y = &apos;World&apos;) &#123;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(&apos;Hello&apos;) // Hello World</span><br><span class="line">log(&apos;Hello&apos;, &apos;China&apos;) // Hello China</span><br><span class="line">log(&apos;Hello&apos;, &apos;&apos;) // Hello</span><br></pre></td></tr></table></figure><p>这样的写法比较自然也符合我们正常的思维。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Point(x = 0, y = 0) &#123;</span><br><span class="line">  this.x = x;</span><br><span class="line">  this.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const p = new Point();</span><br><span class="line">p // &#123; x: 0, y: 0 &#125;</span><br></pre></td></tr></table></figure><p>除了简洁，ES6 的写法还有两个好处：首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。</p><p>参数变量是默认声明的，所以不能用let或const再次声明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function foo(x = 5) &#123;</span><br><span class="line">  let x = 1; // error</span><br><span class="line">  const x = 2; // error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，参数变量x是默认声明的，在函数体中，不能用let或const再次声明，否则会报错。</p><p>使用参数默认值时，函数不能有同名参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 不报错</span><br><span class="line">function foo(x, x, y) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">function foo(x, x, y = 1) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">// SyntaxError: Duplicate parameter name not allowed in this context</span><br></pre></td></tr></table></figure><p>另外，一个容易忽略的地方是，参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let x = 99;</span><br><span class="line">function foo(p = x + 1) &#123;</span><br><span class="line">  console.log(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() // 100</span><br><span class="line"></span><br><span class="line">x = 100;</span><br><span class="line">foo() // 101</span><br></pre></td></tr></table></figure><p>上面代码中，参数p的默认值是x + 1。这时，每次调用函数foo，都会重新计算x + 1，而不是默认p等于 100。</p><h4 id="与解构赋值默认值结合使用"><a href="#与解构赋值默认值结合使用" class="headerlink" title="与解构赋值默认值结合使用"></a>与解构赋值默认值结合使用</h4><p>参数默认值可以和解构赋值的默认值结合起来使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function foo(&#123;x, y = 5&#125;) &#123;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(&#123;&#125;) // undefined 5</span><br><span class="line">foo(&#123;x: 1&#125;) // 1 5</span><br><span class="line">foo(&#123;x: 1, y: 2&#125;) // 1 2</span><br><span class="line">foo() // TypeError: Cannot read property &apos;x&apos; of undefined</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>系统学习ES6（数值的扩展）</title>
      <link href="/2019/01/07/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0ES6%EF%BC%88%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95%EF%BC%89/"/>
      <url>/2019/01/07/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0ES6%EF%BC%88%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="1-二进制和八进制的表示方法"><a href="#1-二进制和八进制的表示方法" class="headerlink" title="1.二进制和八进制的表示方法"></a>1.二进制和八进制的表示方法</h3><p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0b111110111</span> === <span class="number">503</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0o767</span> === <span class="number">503</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>从es5开始，严格模式下八进制就不允许使用前缀0来表示，es6中进一步明确要用0o来表示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非严格模式</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">0o11</span> === <span class="number">011</span>);</span><br><span class="line">&#125;)() <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 严格模式</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">0o11</span> === <span class="number">011</span>);</span><br><span class="line">&#125;)() <span class="comment">// Uncaught SyntaxError: Octal literals are not allowed in strict mode.</span></span><br></pre></td></tr></table></figure><p>如果要将0b和0o表示的数转换成十进制要使用Number方法；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number(&apos;ob11&apos;)   3</span><br><span class="line">Number(&apos;0o10&apos;)   8</span><br></pre></td></tr></table></figure><h3 id="2-Number-isFinite-、Number-isNaN"><a href="#2-Number-isFinite-、Number-isNaN" class="headerlink" title="2.Number.isFinite()、Number.isNaN()"></a>2.Number.isFinite()、Number.isNaN()</h3><p>es6在number对象上提供了两个新方法，isFinite()和isNaN()；很明显是用来检测一个数值是否是finite和NaN的。</p><p>Number.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">15</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">0.8</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(-<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">'foo'</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">'15'</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">true</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>参数类型不是数值的时候，均返回false；</p><p>isNaN是用来检查一个数值是否是NaN</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">15</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">'15'</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">true</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">9</span>/<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">'true'</span> / <span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">'true'</span> / <span class="string">'true'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果参数类型不是NaN，一律返回false；</p><p>他们与全局方法isFinite和isNaN有的区别在于，传统方法先调用Number()方法将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isInfinite()对于非数值一律返回false，Number.isNaN只有对于NaN才返回true</p><h3 id="3-Number-parseInt-Number-parseFloat"><a href="#3-Number-parseInt-Number-parseFloat" class="headerlink" title="3.Number.parseInt(), Number.parseFloat()"></a>3.Number.parseInt(), Number.parseFloat()</h3><p>ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'12.34'</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'123.45#'</span>) <span class="comment">// 123.45</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="built_in">Number</span>.parseInt(<span class="string">'12.34'</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">Number</span>.parseFloat(<span class="string">'123.45#'</span>) <span class="comment">// 123.45</span></span><br></pre></td></tr></table></figure><h3 id="4-Number-isInteger"><a href="#4-Number-isInteger" class="headerlink" title="4.Number.isInteger()"></a>4.Number.isInteger()</h3><p>Number.isInteger()用来判断一个数值是否为整数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25.1</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>js内部，浮点数和整数采用的是同样的储存方法，所以25和25.0被视为同一个值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger() <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="string">'15'</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="literal">true</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>注意，由于 JavaScript 采用 IEEE 754 标准，数值存储为64位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）。如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，Number.isInteger可能会误判。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">3.0000000000000002</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，Number.isInteger的参数明明不是整数，但是会返回true。原因就是这个小数的精度达到了小数点后16个十进制位，转成二进制位超过了53个二进制位，导致最后的那个2被丢弃了。</p><p>类似的情况还有，如果一个数值的绝对值小于Number.MIN_VALUE（5E-324），即小于 JavaScript 能够分辨的最小值，会被自动转为 0。这时，Number.isInteger也会误判。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">5E-324</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">5E-325</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，5E-325由于值太小，会被自动转为0，因此返回true。</p><p>总之，如果对数据精度的要求较高，不建议使用Number.isInteger()判断一个数值是否为整数。</p><h3 id="5-Number-EPSILON"><a href="#5-Number-EPSILON" class="headerlink" title="5.Number.EPSILON"></a>5.Number.EPSILON</h3><p>ES6 在Number对象上面，新增一个极小的常量Number.EPSILON。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。</p><p>对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的1.00..001，小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Number.EPSILON === Math.pow(2, -52)</span><br><span class="line">// true</span><br><span class="line">Number.EPSILON</span><br><span class="line">// 2.220446049250313e-16</span><br><span class="line">Number.EPSILON.toFixed(20)</span><br><span class="line">// &quot;0.00000000000000022204&quot;</span><br></pre></td></tr></table></figure><p>Number.EPSILON实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。</p><p>引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0.1 + 0.2</span><br><span class="line">// 0.30000000000000004</span><br><span class="line"></span><br><span class="line">0.1 + 0.2 - 0.3</span><br><span class="line">// 5.551115123125783e-17</span><br><span class="line"></span><br><span class="line">5.551115123125783e-17.toFixed(20)</span><br><span class="line">// &apos;0.00000000000000005551&apos;</span><br></pre></td></tr></table></figure><p>上面代码解释了，为什么比较0.1 + 0.2与0.3得到的结果是false。</p><p>Number.EPSILON可以用来设置“能够接受的误差范围”。比如，误差范围设为 2 的-50 次方（即Number.EPSILON * Math.pow(2, 2)），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5.551115123125783e-17 &lt; Number.EPSILON * Math.pow(2, 2)</span><br><span class="line">// true</span><br></pre></td></tr></table></figure><p>因此，Number.EPSILON的实质是一个可以接受的最小误差范围。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withinErrorMargin</span> (<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.abs(left - right) &lt; <span class="built_in">Number</span>.EPSILON * <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span> <span class="comment">// false</span></span><br><span class="line">withinErrorMargin(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.1</span> + <span class="number">1.3</span> === <span class="number">2.4</span> <span class="comment">// false</span></span><br><span class="line">withinErrorMargin(<span class="number">1.1</span> + <span class="number">1.3</span>, <span class="number">2.4</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面的代码为浮点数运算，部署了一个误差检查函数。</p><h3 id="6-安全整数和-Number-isSafeInteger"><a href="#6-安全整数和-Number-isSafeInteger" class="headerlink" title="6.安全整数和 Number.isSafeInteger()"></a>6.安全整数和 Number.isSafeInteger()</h3><p>JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) <span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="number">9007199254740992</span>  <span class="comment">// 9007199254740992</span></span><br><span class="line"><span class="number">9007199254740993</span>  <span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，超出 2 的 53 次方之后，一个数就不精确了。</p><p>ES6 引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1</span><br><span class="line">// true</span><br><span class="line">Number.MAX_SAFE_INTEGER === 9007199254740991</span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">Number.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER</span><br><span class="line">// true</span><br><span class="line">Number.MIN_SAFE_INTEGER === -9007199254740991</span><br><span class="line">// true</span><br></pre></td></tr></table></figure><p>上面代码中，可以看到 JavaScript 能够精确表示的极限。</p><p>Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Number.isSafeInteger(&apos;a&apos;) // false</span><br><span class="line">Number.isSafeInteger(null) // false</span><br><span class="line">Number.isSafeInteger(NaN) // false</span><br><span class="line">Number.isSafeInteger(Infinity) // false</span><br><span class="line">Number.isSafeInteger(-Infinity) // false</span><br><span class="line"></span><br><span class="line">Number.isSafeInteger(3) // true</span><br><span class="line">Number.isSafeInteger(1.2) // false</span><br><span class="line">Number.isSafeInteger(9007199254740990) // true</span><br><span class="line">Number.isSafeInteger(9007199254740992) // false</span><br><span class="line"></span><br><span class="line">Number.isSafeInteger(Number.MIN_SAFE_INTEGER - 1) // false</span><br><span class="line">Number.isSafeInteger(Number.MIN_SAFE_INTEGER) // true</span><br><span class="line">Number.isSafeInteger(Number.MAX_SAFE_INTEGER) // true</span><br><span class="line">Number.isSafeInteger(Number.MAX_SAFE_INTEGER + 1) // false</span><br></pre></td></tr></table></figure><p>这个函数的实现很简单，就是跟安全整数的两个边界值比较一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Number.isSafeInteger = function (n) &#123;</span><br><span class="line">  return (typeof n === &apos;number&apos; &amp;&amp;</span><br><span class="line">    Math.round(n) === n &amp;&amp;</span><br><span class="line">    Number.MIN_SAFE_INTEGER &lt;= n &amp;&amp;</span><br><span class="line">    n &lt;= Number.MAX_SAFE_INTEGER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际使用这个函数时，需要注意。验证运算结果是否落在安全整数的范围内，不要只验证运算结果，而要同时验证参与运算的每个值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Number.isSafeInteger(9007199254740993)</span><br><span class="line">// false</span><br><span class="line">Number.isSafeInteger(990)</span><br><span class="line">// true</span><br><span class="line">Number.isSafeInteger(9007199254740993 - 990)</span><br><span class="line">// true</span><br><span class="line">9007199254740993 - 990</span><br><span class="line">// 返回结果 9007199254740002</span><br><span class="line">// 正确答案应该是 9007199254740003</span><br></pre></td></tr></table></figure><p>上面代码中，9007199254740993不是一个安全整数，但是Number.isSafeInteger会返回结果，显示计算结果是安全的。这是因为，这个数超出了精度范围，导致在计算机内部，以9007199254740992的形式储存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9007199254740993 === 9007199254740992</span><br><span class="line">// true</span><br></pre></td></tr></table></figure><p>所以，如果只验证运算结果是否为安全整数，很可能得到错误结果。下面的函数可以同时验证两个运算数和运算结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function trusty (left, right, result) &#123;</span><br><span class="line">  if (</span><br><span class="line">    Number.isSafeInteger(left) &amp;&amp;</span><br><span class="line">    Number.isSafeInteger(right) &amp;&amp;</span><br><span class="line">    Number.isSafeInteger(result)</span><br><span class="line">  ) &#123;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">  throw new RangeError(&apos;Operation cannot be trusted!&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trusty(9007199254740993, 990, 9007199254740993 - 990)</span><br><span class="line">// RangeError: Operation cannot be trusted!</span><br><span class="line"></span><br><span class="line">trusty(1, 2, 3)</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure><h3 id="7-Math-对象的扩展"><a href="#7-Math-对象的扩展" class="headerlink" title="7.Math 对象的扩展"></a>7.Math 对象的扩展</h3><p>ES6 在 Math 对象上新增了 17 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用。</p><h4 id="Math-trunc"><a href="#Math-trunc" class="headerlink" title="Math.trunc()"></a>Math.trunc()</h4><p>Math.trunc方法用于去除一个数的小数部分，返回整数部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.trunc(4.1) // 4</span><br><span class="line">Math.trunc(4.9) // 4</span><br><span class="line">Math.trunc(-4.1) // -4</span><br><span class="line">Math.trunc(-4.9) // -4</span><br><span class="line">Math.trunc(-0.1234) // -0</span><br></pre></td></tr></table></figure><p>对于非数值，Math.trunc内部使用Number方法将其先转为数值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Math.trunc(&apos;123.456&apos;) // 123</span><br><span class="line">Math.trunc(true) //1</span><br><span class="line">Math.trunc(false) // 0</span><br><span class="line">Math.trunc(null) // 0</span><br></pre></td></tr></table></figure><p>对于空值和无法截取整数的值，返回NaN</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Math.trunc(NaN);      // NaN</span><br><span class="line">Math.trunc(&apos;foo&apos;);    // NaN</span><br><span class="line">Math.trunc();         // NaN</span><br><span class="line">Math.trunc(undefined) // NaN</span><br></pre></td></tr></table></figure><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.trunc = Math.trunc || function(x) &#123;</span><br><span class="line">  return x &lt; 0 ? Math.ceil(x) : Math.floor(x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Math-sign"><a href="#Math-sign" class="headerlink" title="Math.sign()"></a>Math.sign()</h4><p>Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。</p><p>它会返回五种值。</p><ul><li>参数为正数，返回+1；</li><li>参数为负数，返回-1；</li><li>参数为 0，返回0；</li><li>参数为-0，返回-0;</li><li>其他值，返回NaN。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.sign(-5) // -1</span><br><span class="line">Math.sign(5) // +1</span><br><span class="line">Math.sign(0) // +0</span><br><span class="line">Math.sign(-0) // -0</span><br><span class="line">Math.sign(NaN) // NaN</span><br></pre></td></tr></table></figure><p>如果参数是非数值，会自动转为数值。对于那些无法转为数值的值，会返回NaN。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Math.sign(&apos;&apos;)  // 0</span><br><span class="line">Math.sign(true)  // +1</span><br><span class="line">Math.sign(false)  // 0</span><br><span class="line">Math.sign(null)  // 0</span><br><span class="line">Math.sign(&apos;9&apos;)  // +1</span><br><span class="line">Math.sign(&apos;foo&apos;)  // NaN</span><br><span class="line">Math.sign()  // NaN</span><br><span class="line">Math.sign(undefined)  // NaN</span><br></pre></td></tr></table></figure><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Math.sign = Math.sign || function(x) &#123;</span><br><span class="line">  x = +x; // convert to a number</span><br><span class="line">  if (x === 0 || isNaN(x)) &#123;</span><br><span class="line">    return x;</span><br><span class="line">  &#125;</span><br><span class="line">  return x &gt; 0 ? 1 : -1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Math-cbrt"><a href="#Math-cbrt" class="headerlink" title="Math.cbrt()"></a>Math.cbrt()</h4><p>Math.cbrt方法用于计算一个数的立方根。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Math.cbrt(-1) // -1</span><br><span class="line">Math.cbrt(0)  // 0</span><br><span class="line">Math.cbrt(1)  // 1</span><br><span class="line">Math.cbrt(2)  // 1.2599210498948734</span><br></pre></td></tr></table></figure><p>对于非数值，Math.cbrt方法内部也是先使用Number方法将其转为数值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.cbrt(&apos;8&apos;) // 2</span><br><span class="line">Math.cbrt(&apos;hello&apos;) // NaN</span><br></pre></td></tr></table></figure><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Math.cbrt = Math.cbrt || function(x) &#123;</span><br><span class="line">  var y = Math.pow(Math.abs(x), 1/3);</span><br><span class="line">  return x &lt; 0 ? -y : y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Math-clz32"><a href="#Math-clz32" class="headerlink" title="Math.clz32()"></a>Math.clz32()</h4><p>JavaScript 的整数使用 32 位二进制形式表示，Math.clz32方法返回一个数的 32 位无符号整数形式有多少个前导 0。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.clz32(0) // 32</span><br><span class="line">Math.clz32(1) // 31</span><br><span class="line">Math.clz32(1000) // 22</span><br><span class="line">Math.clz32(0b01000000000000000000000000000000) // 1</span><br><span class="line">Math.clz32(0b00100000000000000000000000000000) // 2</span><br></pre></td></tr></table></figure><p>上面代码中，0 的二进制形式全为 0，所以有 32 个前导 0；1 的二进制形式是0b1，只占 1 位，所以 32 位之中有 31 个前导 0；1000 的二进制形式是0b1111101000，一共有 10 位，所以 32 位之中有 22 个前导 0。</p><p>clz32这个函数名就来自”count leading zero bits in 32-bit binary representation of a number“（计算一个数的 32 位二进制形式的前导 0 的个数）的缩写。</p><p>左移运算符（&lt;&lt;）与Math.clz32方法直接相关。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.clz32(0) // 32</span><br><span class="line">Math.clz32(1) // 31</span><br><span class="line">Math.clz32(1 &lt;&lt; 1) // 30</span><br><span class="line">Math.clz32(1 &lt;&lt; 2) // 29</span><br><span class="line">Math.clz32(1 &lt;&lt; 29) // 2</span><br></pre></td></tr></table></figure><p>对于小数，Math.clz32方法只考虑整数部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.clz32(3.2) // 30</span><br><span class="line">Math.clz32(3.9) // 30</span><br></pre></td></tr></table></figure><p>对于空值或其他类型的值，Math.clz32方法会将它们先转为数值，然后再计算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Math.clz32() // 32</span><br><span class="line">Math.clz32(NaN) // 32</span><br><span class="line">Math.clz32(Infinity) // 32</span><br><span class="line">Math.clz32(null) // 32</span><br><span class="line">Math.clz32(&apos;foo&apos;) // 32</span><br><span class="line">Math.clz32([]) // 32</span><br><span class="line">Math.clz32(&#123;&#125;) // 32</span><br><span class="line">Math.clz32(true) // 31</span><br></pre></td></tr></table></figure><h4 id="Math-imul"><a href="#Math-imul" class="headerlink" title="Math.imul()"></a>Math.imul()</h4><p>Math.imul方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.imul(2, 4)   // 8</span><br><span class="line">Math.imul(-1, 8)  // -8</span><br><span class="line">Math.imul(-2, -2) // 4</span><br></pre></td></tr></table></figure><p>如果只考虑最后 32 位，大多数情况下，Math.imul(a, b)与a <em> b的结果是相同的，即该方法等同于(a </em> b)|0的效果（超过 32 位的部分溢出）。之所以需要部署这个方法，是因为 JavaScript 有精度限制，超过 2 的 53 次方的值无法精确表示。这就是说，对于那些很大的数的乘法，低位数值往往都是不精确的，Math.imul方法可以返回正确的低位数值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(0x7fffffff * 0x7fffffff)|0 // 0</span><br></pre></td></tr></table></figure><p>上面这个乘法算式，返回结果为 0。但是由于这两个二进制数的最低位都是 1，所以这个结果肯定是不正确的，因为根据二进制乘法，计算结果的二进制最低位应该也是 1。这个错误就是因为它们的乘积超过了 2 的 53 次方，JavaScript 无法保存额外的精度，就把低位的值都变成了 0。Math.imul方法可以返回正确的值 1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.imul(0x7fffffff, 0x7fffffff) // 1</span><br></pre></td></tr></table></figure><h4 id="Math-fround"><a href="#Math-fround" class="headerlink" title="Math.fround()"></a>Math.fround()</h4><p>Math.fround方法返回一个数的32位单精度浮点数形式。</p><p>对于32位单精度格式来说，数值精度是24个二进制位（1 位隐藏位与 23 位有效位），所以对于 -224 至 224 之间的整数（不含两个端点），返回结果与参数本身一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.fround(0)   // 0</span><br><span class="line">Math.fround(1)   // 1</span><br><span class="line">Math.fround(2 ** 24 - 1)   // 16777215</span><br></pre></td></tr></table></figure><p>如果参数的绝对值大于 224，返回的结果便开始丢失精度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.fround(2 ** 24)       // 16777216</span><br><span class="line">Math.fround(2 ** 24 + 1)   // 16777216</span><br></pre></td></tr></table></figure><p>Math.fround方法的主要作用，是将64位双精度浮点数转为32位单精度浮点数。如果小数的精度超过24个二进制位，返回值就会不同于原值，否则返回值不变（即与64位双精度值一致）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 未丢失有效精度</span><br><span class="line">Math.fround(1.125) // 1.125</span><br><span class="line">Math.fround(7.25)  // 7.25</span><br><span class="line"></span><br><span class="line">// 丢失精度</span><br><span class="line">Math.fround(0.3)   // 0.30000001192092896</span><br><span class="line">Math.fround(0.7)   // 0.699999988079071</span><br><span class="line">Math.fround(1.0000000123) // 1</span><br></pre></td></tr></table></figure><p>对于 NaN 和 Infinity，此方法返回原值。对于其它类型的非数值，Math.fround 方法会先将其转为数值，再返回单精度浮点数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Math.fround(NaN)      // NaN</span><br><span class="line">Math.fround(Infinity) // Infinity</span><br><span class="line"></span><br><span class="line">Math.fround(&apos;5&apos;)      // 5</span><br><span class="line">Math.fround(true)     // 1</span><br><span class="line">Math.fround(null)     // 0</span><br><span class="line">Math.fround([])       // 0</span><br><span class="line">Math.fround(&#123;&#125;)       // NaN</span><br></pre></td></tr></table></figure><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.fround = Math.fround || function (x) &#123;</span><br><span class="line">  return new Float32Array([x])[0];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Math-hypot"><a href="#Math-hypot" class="headerlink" title="Math.hypot()"></a>Math.hypot()</h4><p>Math.hypot方法返回所有参数的平方和的平方根。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Math.hypot(3, 4);        // 5</span><br><span class="line">Math.hypot(3, 4, 5);     // 7.0710678118654755</span><br><span class="line">Math.hypot();            // 0</span><br><span class="line">Math.hypot(NaN);         // NaN</span><br><span class="line">Math.hypot(3, 4, &apos;foo&apos;); // NaN</span><br><span class="line">Math.hypot(3, 4, &apos;5&apos;);   // 7.0710678118654755</span><br><span class="line">Math.hypot(-3);          // 3</span><br></pre></td></tr></table></figure><p>上面代码中，3 的平方加上 4 的平方，等于 5 的平方。</p><p>如果参数不是数值，Math.hypot方法会将其转为数值。只要有一个参数无法转为数值，就会返回 NaN。</p><h4 id="对数方法"><a href="#对数方法" class="headerlink" title="对数方法"></a>对数方法</h4><p>ES6 新增了 4 个对数相关方法。</p><h5 id="（1）-Math-expm1"><a href="#（1）-Math-expm1" class="headerlink" title="（1） Math.expm1()"></a>（1） Math.expm1()</h5><p>Math.expm1(x)返回 e^x - 1，即Math.exp(x) - 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.expm1(-1) // -0.6321205588285577</span><br><span class="line">Math.expm1(0)  // 0</span><br><span class="line">Math.expm1(1)  // 1.718281828459045</span><br></pre></td></tr></table></figure><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.expm1 = Math.expm1 || function(x) &#123;</span><br><span class="line">  return Math.exp(x) - 1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="（2）Math-log1p"><a href="#（2）Math-log1p" class="headerlink" title="（2）Math.log1p()"></a>（2）Math.log1p()</h5><p>Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Math.log1p(1)  // 0.6931471805599453</span><br><span class="line">Math.log1p(0)  // 0</span><br><span class="line">Math.log1p(-1) // -Infinity</span><br><span class="line">Math.log1p(-2) // NaN</span><br></pre></td></tr></table></figure><p>没有部署这个方法的环境可用如下代码模拟</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.log1p = Math.log1p || function(x) &#123;</span><br><span class="line">  return Math.log(1 + x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="（3）Math-log10"><a href="#（3）Math-log10" class="headerlink" title="（3）Math.log10()"></a>（3）Math.log10()</h5><p>Math.log10(x)返回以 10 为底的x的对数。如果x小于 0，则返回 NaN。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.log10(2)      // 0.3010299956639812</span><br><span class="line">Math.log10(1)      // 0</span><br><span class="line">Math.log10(0)      // -Infinity</span><br><span class="line">Math.log10(-2)     // NaN</span><br><span class="line">Math.log10(100000) // 5</span><br></pre></td></tr></table></figure><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.log10 = Math.log10 || function(x) &#123;</span><br><span class="line">  return Math.log(x) / Math.LN10;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="（4）Math-log2"><a href="#（4）Math-log2" class="headerlink" title="（4）Math.log2()"></a>（4）Math.log2()</h5><p>Math.log2(x)返回以 2 为底的x的对数。如果x小于 0，则返回 NaN。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Math.log2(3)       // 1.584962500721156</span><br><span class="line">Math.log2(2)       // 1</span><br><span class="line">Math.log2(1)       // 0</span><br><span class="line">Math.log2(0)       // -Infinity</span><br><span class="line">Math.log2(-2)      // NaN</span><br><span class="line">Math.log2(1024)    // 10</span><br><span class="line">Math.log2(1 &lt;&lt; 29) // 29</span><br></pre></td></tr></table></figure><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.log2 = Math.log2 || function(x) &#123;</span><br><span class="line">  return Math.log(x) / Math.LN2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="8-指数运算符"><a href="#8-指数运算符" class="headerlink" title="8.指数运算符"></a>8.指数运算符</h3><p>ES2016 新增了一个指数运算符（**）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 ** 2 // 4</span><br><span class="line">2 ** 3 // 8</span><br></pre></td></tr></table></figure><p><strong>这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 相当于 2 ** (3 ** 2)</span><br><span class="line">2 ** 3 ** 2</span><br><span class="line">// 512</span><br></pre></td></tr></table></figure><p>上面代码中，首先计算的是第二个指数运算符，而不是第一个。</p><p>指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let a = 1.5;</span><br><span class="line">a **= 2;</span><br><span class="line">// 等同于 a = a * a;</span><br><span class="line"></span><br><span class="line">let b = 4;</span><br><span class="line">b **= 3;</span><br><span class="line">// 等同于 b = b * b * b;</span><br></pre></td></tr></table></figure><blockquote><p>注意，V8 引擎的指数运算符与Math.pow的实现不相同，对于特别大的运算结果，两者会有细微的差异。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(99, 99)</span><br><span class="line">// 3.697296376497263e+197</span><br><span class="line"></span><br><span class="line">99 ** 99</span><br><span class="line">// 3.697296376497268e+197</span><br></pre></td></tr></table></figure><p>上面代码中，两个运算结果的最后一位有效数字是有差异的。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>系统学习ES6（变量的解构赋值）</title>
      <link href="/2018/12/12/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0ES6%EF%BC%88%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%EF%BC%89/"/>
      <url>/2018/12/12/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0ES6%EF%BC%88%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="1-数组的解构赋值"><a href="#1-数组的解构赋值" class="headerlink" title="1.数组的解构赋值"></a>1.数组的解构赋值</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><blockquote><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p></blockquote><p>以前的变量赋值都是直接指定值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>ES6里可以写成这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b] = [<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>表示我们可以从数组中提取对应值，按照对应的位置对变量赋值。</p><p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。</p><p>其实这种匹配模式比较好理解，我记得上学的时候有学过一个比较系数法，就是这个意思；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo,[[bar],baz]] = [<span class="number">1</span>,[[<span class="number">2</span>],<span class="number">3</span>]];</span><br><span class="line">foo <span class="comment">// 1;</span></span><br><span class="line">bar <span class="comment">// 2;</span></span><br><span class="line">baz <span class="comment">// 3;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [ , , third] = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>];</span><br><span class="line">third <span class="comment">// "baz"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">head <span class="comment">// 1</span></span><br><span class="line">tail <span class="comment">// [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">'a'</span>];</span><br><span class="line">x <span class="comment">// "a"</span></span><br><span class="line">y <span class="comment">// undefined</span></span><br><span class="line">z <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>如果解构不成功，变量的值就是undefined；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [b] = [];</span><br><span class="line"><span class="keyword">let</span> [a,b] = [];</span><br></pre></td></tr></table></figure><p>上面这两种情况下，b的值都是undefined；</p><p>还有一种情况是不完全解构，就是说等号左右两边不一定一一对应，这样也能解构成功；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x,y] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">x <span class="comment">//1</span></span><br><span class="line">y<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a,[b,c],d] = [<span class="number">1</span>,[<span class="number">2</span>],<span class="number">3</span>]</span><br><span class="line">a <span class="comment">//1</span></span><br><span class="line">b <span class="comment">//2</span></span><br><span class="line">c <span class="comment">//undefined</span></span><br><span class="line">d <span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>上面的情况都属于不完全解构，但是可以成功；</p><p>如果等号右边不是数组的话，会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = &#123;&#125;;</span><br></pre></td></tr></table></figure><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><blockquote><p>解构赋值允许指定默认值</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</span><br><span class="line">foo <span class="comment">//true</span></span><br><span class="line"><span class="keyword">let</span> [x,y = <span class="string">'b'</span>] = [<span class="string">'a'</span>]  <span class="comment">//x = 'a' y = 'b'</span></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>, <span class="literal">undefined</span>]; <span class="comment">// x='a', y='b'</span></span><br></pre></td></tr></table></figure><p><strong>注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。</strong></p><p>上呢判断y等于undefined，默认值生效，y = ‘b’；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>这里x = null，null不严格等于undefined，所以默认值没有生效，x = null；</p><p>如果默认值是一个表达式，那么这个表达式是惰性求值的，也就是说如果要用到的时候才会求值；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'aaa'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [x=f()] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>这里x不用执行f就能取到值，所以函数不会执行，上面的代码等价于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'aaa'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ([<span class="number">1</span>][<span class="number">0</span>] === <span class="literal">undefined</span>)&#123;</span><br><span class="line">f()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">x = [<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认值也可以引用解构赋值的其他变量，但是该变量必须被声明；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let [x = 1, y = x] = [];     // x=1; y=1</span><br><span class="line">let [x = 1, y = x] = [2];    // x=2; y=2</span><br><span class="line">let [x = 1, y = x] = [1, 2]; // x=1; y=2</span><br><span class="line">let [x = y, y = 1] = [];     // ReferenceError: y is not defined</span><br></pre></td></tr></table></figure><p>这里又复习了暂时性死区的概念。</p><h3 id="2-对象的解构赋值"><a href="#2-对象的解构赋值" class="headerlink" title="2.对象的解构赋值"></a>2.对象的解构赋值</h3><p>明白了匹配的话对象的解构赋值也就很好理解了；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;name,age&#125; = &#123;<span class="attr">name</span>:<span class="string">'troubledot'</span>,<span class="attr">age</span>:<span class="number">28</span>&#125;</span><br><span class="line">name <span class="comment">//'troubledot'</span></span><br><span class="line">age <span class="comment">// 28</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;age,name&#125; = &#123;<span class="attr">name</span>:<span class="string">'troubledot'</span>,<span class="attr">age</span>:<span class="number">28</span>&#125;</span><br><span class="line">name <span class="comment">//'troubledot'</span></span><br><span class="line">age <span class="comment">// 28</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;sex&#125; = &#123;<span class="attr">name</span>:<span class="string">'troubledot'</span>,<span class="attr">age</span>:<span class="number">28</span>&#125;;</span><br><span class="line">sex <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>不难发现，数组的解构赋值是用索引来匹配的，对象的解构赋值是用key来匹配的；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">name</span>:me&#125; = &#123;<span class="attr">name</span>:<span class="string">'troubledot'</span>&#125;</span><br><span class="line">me <span class="comment">// 'troubledot'</span></span><br></pre></td></tr></table></figure><p>在对象的解构赋值中，对象的属性是一个连通变量和值的桥梁。打个比方就是我的年龄是a，我的年龄是28，那么a = 28，而年龄就是连通a和28的桥梁，年龄是一种<strong>模式</strong>，真正被赋值的不是年龄，而是a；</p><p>嵌套结构的对象也可以解构；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    <span class="string">'Hello'</span>,</span><br><span class="line">    &#123; <span class="attr">y</span>: <span class="string">'World'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x <span class="comment">// "Hello"</span></span><br><span class="line">y <span class="comment">// "World"</span></span><br></pre></td></tr></table></figure><p>这里的p对应的是我的比方里面的年龄，被赋值的不是它而是x和y；</p><p>如果需要对p赋值，应该这样写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    &apos;Hello&apos;,</span><br><span class="line">    &#123; y: &apos;World&apos; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line">let &#123;p&#125; = obj;</span><br><span class="line"></span><br><span class="line">p //[&apos;Hello&apos;,&#123; y: &apos;World&apos; &#125;]</span><br></pre></td></tr></table></figure><p>这里只对p进行了解构，如果我们还是需要x和y的话，需要对x和y再进行解构；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    &apos;Hello&apos;,</span><br><span class="line">    &#123; y: &apos;World&apos; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line">let &#123;p,p:[x,&#123;y&#125;]&#125; = obj;</span><br><span class="line"></span><br><span class="line">p //[&apos;Hello&apos;,&#123; y: &apos;World&apos; &#125;]</span><br><span class="line">x // &quot;Hello&quot;</span><br><span class="line">y // &quot;World&quot;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> node = &#123;</span><br><span class="line">  loc: &#123;</span><br><span class="line">    start: &#123;</span><br><span class="line">      line: <span class="number">1</span>,</span><br><span class="line">      column: <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; loc, <span class="attr">loc</span>: &#123; start &#125;, <span class="attr">loc</span>: &#123; <span class="attr">start</span>: &#123; line &#125;&#125; &#125; = node;</span><br><span class="line">line <span class="comment">// 1</span></span><br><span class="line">loc  <span class="comment">// Object &#123;start: Object&#125;</span></span><br><span class="line">start <span class="comment">// Object &#123;line: 1, column: 5&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码分别对loc，start和line进行了解构；</p><p>看一个对象嵌套赋值的例子；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line">(&#123;<span class="attr">name</span>:obj.name,<span class="attr">age</span>:arr[<span class="number">0</span>]&#125; = &#123;<span class="attr">name</span>:<span class="string">'troubledot'</span>,<span class="attr">age</span>:<span class="number">28</span>&#125;)</span><br><span class="line"><span class="comment">//obj = &#123;name:'troubledot'&#125;</span></span><br><span class="line"><span class="comment">//arr = [28]</span></span><br></pre></td></tr></table></figure><p>对象的解构也可以指定默认值；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;&#125;;</span><br><span class="line">x <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;x, y = <span class="number">5</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;&#125;;</span><br><span class="line">y <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">5</span>&#125;;</span><br><span class="line">y <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">message</span>: msg = <span class="string">'Something went wrong'</span> &#125; = &#123;&#125;;</span><br><span class="line">msg <span class="comment">// "Something went wrong"</span></span><br></pre></td></tr></table></figure><p>同样当对象的属性值严格等于undefined的时候，默认值生效；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line">x <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">null</span>&#125;;</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>null不严格等于undefined，所以x不等于其默认值。</p><p>解构失败，变量的值等于undefined，如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a&#125; = &#123;<span class="attr">b</span>:<span class="number">3</span>&#125;</span><br><span class="line">a <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//报错</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">name</span>:&#123;firstname&#125;&#125; = &#123;<span class="attr">age</span>:<span class="number">28</span>&#125;</span><br></pre></td></tr></table></figure><p>这个报错，我们倒着看的时候会比较好理解；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let me = &#123;age:28&#125;;</span><br><span class="line">me.name = undefined;</span><br><span class="line">me.name.firstname //报错</span><br></pre></td></tr></table></figure><p>由于JavaScript 引擎会把大括号包裹的部分视为一个代码块处理，所以我们在对已经声明的对象进行解构的时候需要特别注意，下面这段代码会因为把{a}当作代码块处理而发生语法错误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line">&#123;a&#125; = &#123;<span class="attr">a</span>:<span class="number">20</span>&#125;</span><br><span class="line"><span class="comment">// SyntaxError: syntax error</span></span><br></pre></td></tr></table></figure><p>解决这个问题我们只需要不在行首出现括号就好</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line">(&#123;a&#125; = &#123;<span class="attr">a</span>:<span class="number">20</span>&#125;)</span><br><span class="line"><span class="comment">// SyntaxError: syntax error</span></span><br></pre></td></tr></table></figure><p>解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&#123;&#125; = [<span class="literal">true</span>, <span class="literal">false</span>]);</span><br><span class="line">(&#123;&#125; = <span class="string">'abc'</span>);</span><br><span class="line">(&#123;&#125; = []);</span><br></pre></td></tr></table></figure><p>上面的表达式虽然毫无意义，但是语法是合法的，可以执行。</p><p>对象的解构赋值可以很方便地将现有对象的方法，赋值到某个变量。</p><p>我们可以这么理解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">我：&#123;</span><br><span class="line">姓名：张三，</span><br><span class="line">年龄：28，</span><br><span class="line">性别：男，</span><br><span class="line">宠物：&#123;</span><br><span class="line">狗：&#123;</span><br><span class="line">名字：’土豆‘，</span><br><span class="line">品种：’金毛‘</span><br><span class="line">&#125;</span><br><span class="line">&#125;，</span><br><span class="line">技能：写js</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 现在有一个王六</span><br><span class="line"> &#123;年龄，性别，技能&#125;  = 我</span><br><span class="line">//我们就知道王六也是个28岁的男性，也会写js 。这里相当于我们解构了年龄性别和技能</span><br><span class="line"></span><br><span class="line">&#123;宠物&#125;  = 我</span><br><span class="line"></span><br><span class="line">// 这样的话我们只解构了宠物这个属性，我们也知道王六有只宠物狗。品种和名字我们都不知道。</span><br><span class="line">&#123;</span><br><span class="line">宠物：&#123;</span><br><span class="line">狗：&#123;</span><br><span class="line">名字：’毛毛‘，</span><br><span class="line">品种：’泰迪‘</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; = 我；</span><br><span class="line">//这样的话我们就知道了王六的狗子是一只叫毛毛的泰迪。</span><br></pre></td></tr></table></figure><p>这是自创的中文编程。 </p><p>明白了上面的道理我们就好理解下面的代码了；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; log, sin, cos &#125; = <span class="built_in">Math</span>;</span><br></pre></td></tr></table></figure><p>这里我们给log，sin，cos赋值，分别等于Math.log，Math.sin，Math.cos，这样在使用的时候会比较方便；</p><p>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="number">0</span> : first, [arr.length - <span class="number">1</span>] : last&#125; = arr;</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">last <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h3 id="3-字符串的解构赋值"><a href="#3-字符串的解构赋值" class="headerlink" title="3.字符串的解构赋值"></a>3.字符串的解构赋值</h3><p>我们可以把字符串当作数组来处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">'hello'</span>;</span><br><span class="line">a <span class="comment">// "h"</span></span><br><span class="line">b <span class="comment">// "e"</span></span><br><span class="line">c <span class="comment">// "l"</span></span><br><span class="line">d <span class="comment">// "l"</span></span><br><span class="line">e <span class="comment">// "o"</span></span><br></pre></td></tr></table></figure><p>所以类似数组的对象都有个length属性，我么也可以对其进行解构赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">'hello'</span>;</span><br><span class="line">len<span class="comment">//5</span></span><br></pre></td></tr></table></figure><h3 id="4-数组和布尔值的解构赋值"><a href="#4-数组和布尔值的解构赋值" class="headerlink" title="4.数组和布尔值的解构赋值"></a>4.数组和布尔值的解构赋值</h3><p>解构赋值的时候如果等号右边是布尔值和数值，会先转化为对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line">s === <span class="built_in">Boolean</span>.prototype.toString <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面的这两个例子，toString是一个模式，对s解构赋值的时候我们，需要找123和true的toString属性，他们本身没有toString属性，但是他们的原型有，所以s能取到值；如果改成这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">otherfn</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line">s <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">otherfn</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line">s <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>这里的s就是undefined了，因为123和true都没有ohterfn属性，他们的原型也没有。这样的话下面这个例子就很好理解了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: x &#125; = <span class="literal">undefined</span>; <span class="comment">// TypeError</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: y &#125; = <span class="literal">null</span>; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p>null和undefined不能转换成对象，所以会报错。</p><h3 id="5-函数参数的解构赋值"><a href="#5-函数参数的解构赋值" class="headerlink" title="5.函数参数的解构赋值"></a>5.函数参数的解构赋值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>add的参数是一个数组，但是在执行的时候解构成了变量x和y；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);</span><br><span class="line">// [ 3, 7 ]</span><br></pre></td></tr></table></figure><p>函数参数的解构也可以使用默认值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, 0]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [0, 0]</span></span><br><span class="line">move(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure><p>上面函数的参数是一个对象，函数执行的时候对参数进行解构，如果解构失败就取默认值。</p><p>注意，下面的写法会得到不一样的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, undefined]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [undefined, undefined]</span></span><br><span class="line">move(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure><p>这里的默认值是参数对象的默认值，不是x和y的默认值。</p><p>move({x: 3}) 的时候其实相当于move({x: 3,y:undefined});</p><p>同理 move({}); // [undefined, undefined]也就很好理解了。</p><p>move()的时候，相当于参数等于undefined，此时取其默认值。 move(); // [0, 0]</p><blockquote><p>undefined会触发函数参数的默认值</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">x = <span class="string">'yes'</span></span>) =&gt;</span> x);</span><br><span class="line"><span class="comment">// [ 1, 'yes', 3 ]</span></span><br></pre></td></tr></table></figure><h3 id="6-圆括号问题"><a href="#6-圆括号问题" class="headerlink" title="6.圆括号问题"></a>6.圆括号问题</h3><p>解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。</p><p>由此带来的问题是，如果模式中出现圆括号怎么处理。ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。</p><p>但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。</p><p>-</p><h4 id="不能使用圆括号的情况"><a href="#不能使用圆括号的情况" class="headerlink" title="不能使用圆括号的情况"></a>不能使用圆括号的情况</h4><p>以下三种情况解构赋值不得使用圆括号</p><h5 id="1-变量声明语句"><a href="#1-变量声明语句" class="headerlink" title="1. 变量声明语句"></a>1. 变量声明语句</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line"><span class="keyword">let</span> [(a)] = [<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">x</span>: (c)&#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> (&#123;<span class="attr">x</span>: c&#125;) = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;(x: c)&#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;(x): c&#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">o</span>: (&#123; <span class="attr">p</span>: p &#125;) &#125; = &#123; <span class="attr">o</span>: &#123; <span class="attr">p</span>: <span class="number">2</span> &#125; &#125;;</span><br></pre></td></tr></table></figure><p>变量声明语句，模式不能使用小括号；</p><h5 id="2-函数参数"><a href="#2-函数参数" class="headerlink" title="2.函数参数"></a>2.函数参数</h5><p>函数参数其实也属于变量声明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[(z</span>)]) </span>&#123; <span class="keyword">return</span> z; &#125;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[z,(x</span>)]) </span>&#123; <span class="keyword">return</span> x; &#125;</span><br></pre></td></tr></table></figure><h5 id="3-赋值语句的模式"><a href="#3-赋值语句的模式" class="headerlink" title="3.赋值语句的模式"></a>3.赋值语句的模式</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line">(&#123; <span class="attr">p</span>: a &#125;) = &#123; <span class="attr">p</span>: <span class="number">42</span> &#125;;</span><br><span class="line">([a]) = [<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line">[(&#123; <span class="attr">p</span>: a &#125;), &#123; <span class="attr">x</span>: c &#125;] = [&#123;&#125;, &#123;&#125;];</span><br></pre></td></tr></table></figure><p>不管是整个模式放在小括号中，还是将部分模式放在小括号中都会报错</p><h4 id="可以使用圆括号的情况"><a href="#可以使用圆括号的情况" class="headerlink" title="可以使用圆括号的情况"></a>可以使用圆括号的情况</h4><p>通过上面我们基本已经清楚可以使用圆括号的情况：</p><blockquote><p>赋值语句的非模式部分可以使用圆括号</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[(b)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br><span class="line">(&#123; <span class="attr">p</span>: (d) &#125; = &#123;&#125;); <span class="comment">// 正确</span></span><br><span class="line">[(<span class="built_in">parseInt</span>.prop)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>这三句都可以执行，我们来看下，第一行模式是数组的第一个元素跟b没关系，所以可以用圆括号，第二行模式是p，所以d用圆括号没有问题，第三行跟第一行是一样的。</p><h3 id="7-用途"><a href="#7-用途" class="headerlink" title="7.用途"></a>7.用途</h3><h4 id="1-交换变量的值"><a href="#1-交换变量的值" class="headerlink" title="(1) 交换变量的值"></a>(1) 交换变量的值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure><p>如果没有解构赋值，我们要交换变量的值需要一个中间量，但是现在可以直接解构赋值。</p><h4 id="（2）从函数返回多个值"><a href="#（2）从函数返回多个值" class="headerlink" title="（2）从函数返回多个值"></a>（2）从函数返回多个值</h4><p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure><h4 id="（3）函数参数的定义"><a href="#（3）函数参数的定义" class="headerlink" title="（3）函数参数的定义"></a>（3）函数参数的定义</h4><p>解构赋值可以方便的将一组参数与变量名对应起来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</span><br><span class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</span><br><span class="line">f(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><h4 id="4）提取-JSON-数据"><a href="#4）提取-JSON-数据" class="headerlink" title="(4）提取 JSON 数据"></a>(4）提取 JSON 数据</h4><p>前后端分离的项目中，我们经常需要提取json数据的值，使用解构赋值会变得特别方便</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">  id: <span class="number">42</span>,</span><br><span class="line">  status: <span class="string">"OK"</span>,</span><br><span class="line">  data: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(id, status, number);</span><br><span class="line"><span class="comment">// 42, "OK", [867, 5309]</span></span><br></pre></td></tr></table></figure><h4 id="（5）函数参数的默认值"><a href="#（5）函数参数的默认值" class="headerlink" title="（5）函数参数的默认值"></a>（5）函数参数的默认值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  async = true,</span></span></span><br><span class="line"><span class="function"><span class="params">  beforeSend = function (</span>) </span>&#123;&#125;,</span><br><span class="line">  cache = <span class="literal">true</span>,</span><br><span class="line">  complete = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  crossDomain = <span class="literal">false</span>,</span><br><span class="line">  global = <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// ... more config</span></span><br><span class="line">&#125; = &#123;&#125;) &#123;</span><br><span class="line">  <span class="comment">// ... do stuff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || ‘default foo’;这样的语句。</p><h4 id="（6）遍历-Map-结构"><a href="#（6）遍历-Map-结构" class="headerlink" title="（6）遍历 Map 结构"></a>（6）遍历 Map 结构</h4><p>任何部署了 Iterator 接口的对象，都可以用for…of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'first'</span>,<span class="string">'hello'</span>);</span><br><span class="line">map.set(<span class="string">'second'</span>,<span class="string">'world'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key,value] <span class="keyword">of</span> map)&#123;</span><br><span class="line">key +<span class="string">'is'</span>+ value</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br></pre></td></tr></table></figure><p>也可以只取键和值；<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'first'</span>,<span class="string">'hello'</span>);</span><br><span class="line">map.set(<span class="string">'second'</span>,<span class="string">'world'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [,value] <span class="keyword">of</span> map)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="（7）输入模块的指定方法。"><a href="#（7）输入模块的指定方法。" class="headerlink" title="（7）输入模块的指定方法。"></a>（7）输入模块的指定方法。</h4><p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</p><p>某些按需引用的方法也是这个原理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">"source-map"</span>);</span><br><span class="line"><span class="keyword">import</span> &#123; Button, Table &#125; <span class="keyword">from</span> <span class="string">'iview'</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>你不是一个合格的父亲</title>
      <link href="/2018/12/06/%E4%BD%A0%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%90%88%E6%A0%BC%E7%9A%84%E7%88%B6%E4%BA%B2/"/>
      <url>/2018/12/06/%E4%BD%A0%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%90%88%E6%A0%BC%E7%9A%84%E7%88%B6%E4%BA%B2/</url>
      <content type="html"><![CDATA[<p>老赵属蛇，65了，生活过的并不幸福，甚至有点凄苦。</p><p>15年前母亲走后，家里就剩下我们父子二人了，彼时我还小，没有别人看上去那么懂事，并没有感觉到当时的生活有多苦，现在回想起来，生活最苦也不过如此吧。</p><p>记得印度佛教有苦行僧的说法，而纵观我父亲这一生，真可谓是尝尽人间疾苦。童年赶上自然灾害，命硬没饿死，上学？对不起没有这个预算，有一大家子人等着吃饭呢，18岁成年之后就担负起了养活十几口子的重任，到了结婚的年纪了，妻子勤劳善良，且不说洗衣做饭是一把好手，哪怕去工地干活也不比大小伙子差多少，小儿子出生以后，日子虽然苦，但是凭借两个人的努力，生活已经有了起色，自己修了房子，老大也快上大学了，用家里的28自行车驮回来了村里的第一台大彩电，后面甚至还有了一点存款，谁能想到，好景不长，随着妻子一病好几年，那点积蓄在医院里简直杯水车薪，但是即使是负债累累也要给发妻治病，家徒四壁也不能让儿子们辍学，没钱了就去借，只要有一口气早晚会翻身，然而生活跟电影不一样的地方就在于，现实并不是很喜欢那种坚持就是胜利的戏码。母亲病了好几年，我的父亲忍受着各种各样的冷眼，经济和心理的双重压力让他没有功夫去伤春悲秋，后来，他自己的母亲走了，第二年他父亲也走了，然后是自己的妻子，现在想想，母亲的故去对他来说又何尝不是一种解脱呢。</p><p>现在想到这些，我感觉父亲没疯没颓废已经胜过好多人了。</p><p>我经常在想，人的意志、信念到底是什么样子的存在。看看我父亲，他为人父的责任感和对自己亡妻的承诺是他如此负重前行的源动力。 毫不夸张，母亲走后他就再没有为自己活过一天了，好多写宠物的文章里面提到，我们的生活里有各种消遣娱乐，但是宠物的生活里面只有主人。每次读到这种论调，我第一个想到的就是我的老父亲，现在我们兄弟俩就是他的全部，我们俩都遗传到了母亲的病，他是亲眼看着母亲没了的，虽然我们现在不会有大问题，但是我知道他在想什么，特别担心我们的身体状况，那是一种恨不能用自己来替代的关心。</p><p>他自己的身体本来就不好，年纪大了免疫力又弱，特别容易感冒，又有高血压，但是他从来不把这些当回事，最常说的一句话就是我你不用操心。可我怎么可能不操心呢。</p><p>说实话这种关怀有时候真的让人心疼，我多希望他能像有些老人一样有点私心，为自己好好活一下。</p><p>有好多同事聊起来说自己的母亲沉迷广场舞很闹心，自己的父亲沉迷门球啥的都不做饭。我其实真的特别羡慕。他喜欢打打牌，输赢不到20块钱的那种，记忆里母亲还健康的时候，因为这个他没少被数落，农闲的时候一玩就是一通宵，赢了厚厚一沓钱，当然都是1毛的纸币，母亲在骂，他在乐。。现在想想这就是我父母的爱情吧。</p><p>现在没人管束了，打牌的乐趣好像也没有以前那么多了，不过这也是他仅有的一点自己的兴趣爱好，但是现在这个爱好给他带来的快乐好像在慢慢减退，我很担心，等他再老一点，如果生活中真的再没有什么乐趣的时候，一个人待在那么大的院子里，真的每一分钟都是煎熬。</p><p>我经常在想，以后我会成为一个怎样的父亲，首先我自己是一个独立的个体，其次才扮演父亲，丈夫，子女等等角色。而我的父亲，在我的记忆里，他的生活就是为了别人，自己的父母，自己的妻子，自己的儿子们。。更可怕的是他已经完全适应了这个节奏，将我们养大成人，为我们的琐事操心已经变成了吃饭睡觉般稀松平常，出了一辈子苦力，现在生活已经不需要他在拼搏了，他感受到的不是轻松，反倒是更大的负罪感，他一直因为不能给我和我哥好的生活而愧疚，一直为不能给我准备好婚房而愧疚，一直为不能给我的生活给予帮助而愧疚，可是他不知道曾经那么艰难的日子我们都没有辍学，我们没有比别人吃的差，穿的差。这一切都是他的功劳，这个恩情我们兄弟俩注定无以为报了。我想过好多的办法为了让他过得轻松一点，想给他样条狗，没事带着溜达溜达，也算有个念想，他说：我连自己都照顾不好你还想让我再养个狗。好吧，想让他发展个啥兴趣爱好，但他感觉是不务正业，气得我呀，都这把年纪了就不能享受下退休生活吗？我曾经苦口婆心的跟他说过，他过得轻松了我们在外面也会轻松，我们不求他能挣多少钱，只求他能开开心心、健健康康的，道理都能懂，但是劳碌一生的他也确实做不到如此心宽体胖。</p><p>我常常在想，他的确不能算得上一个合格的父亲，你心疼子女满怀愧疚的无私奉献，但是这一切都是基于你的身体和心理的压力的，长此以往，我们互相愧疚，我们感觉自己不孝不能让你省心，你感觉对不起我们没给我们好的物质条件，有时候我都在想，如果我不会想这么多，心安理得的接受你的好，不再把你的这份愧疚当回事，或许也能找到一种平衡，但是如果真的这样做了，那你对我们穷尽一生的付出和教育岂不是像一个笑话。</p><p>当然，农村的大环境对人的影响也很大，在我们老家，为人父母一生的目标基本就是养大子女帮子女准备好物质条件结婚生子，然后带孙子，等哪天身体扛不住了，这一生也便到尽头了，没有退休也没有养老，人人都是如此。大家都在犯错的时候，对的那个人就会显得特别突兀，自然也会受到排挤。一直想把父亲接出来，体验下没有闲言碎语的环境，尝试一下更加轻松的活法。如果顺利的话，或许我们今年可以一起在外面过年。</p><p>事实上，你来心安理得的接受我们的好，心安理得的享受轻松的老年生活才更符合逻辑，毕竟你要知道你是老子啊。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>系统学习ES6（let和const命令）</title>
      <link href="/2018/12/03/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0ES6%E4%B8%80/"/>
      <url>/2018/12/03/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0ES6%E4%B8%80/</url>
      <content type="html"><![CDATA[<h3 id="1、let命令"><a href="#1、let命令" class="headerlink" title="1、let命令"></a>1、let命令</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">a  <span class="comment">// 1</span></span><br><span class="line">b  <span class="comment">// ReferenceError: a is not defined.</span></span><br></pre></td></tr></table></figure><p>以上分别用var和let声明了变量a和b，输出b的时候会报错，因为let声明的变量只有在let所在的代码块内有效。</p><p>for循环其实就比较适合用let。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">i <span class="comment">// ReferenceError: i is not defined.</span></span><br></pre></td></tr></table></figure><p>这里就比较符合我们的预期：i应该只有在for循环内部起作用；<br>如果换成var,输出i的时候就是10；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">i <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>这里的i是var声明的，在全局范围内有效，所以会输出最后一轮的i；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">a[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">2</span>]()   <span class="comment">//10</span></span><br></pre></td></tr></table></figure><p>这段代码里面a是一个数组，这个数组是由10个funcion组成的，像这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a <span class="comment">// [console.log(i),console.log(i),console.log(i),console.log(i),console.log(i),console.log(i),console.log(i),console.log(i),console.log(i),console.log(i)]</span></span><br></pre></td></tr></table></figure><p>我们会发现这里的i好像跟前面那个例子里面的i是一样的，其实函数里面console的这个i一直是一个东西，就是那个在全局声明的i，所以会输出最后一轮的i；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">a[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">2</span>]()   <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>如果换成let就会变成2了，怎么理解呢，let声明的变量只在当前这一轮循环中有用，也就是说，每次进入循环都会声明一次i，而不是像var那样直接取全局的变量。这样解释的话会有个疑问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？</p><blockquote><p>这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。</p></blockquote><p>另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">'abc'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br></pre></td></tr></table></figure><p>这段代码，第一次循环完成的时候，i被赋值为字符串’abc’，’abc’小于3为false，不满足循环条件，循环应该就结束了。但是事实上依然进了循环。这就很好的印证了上面的结论：</p><blockquote><p>函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。</p></blockquote><h4 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h4><p>所谓的变量提升，就是说对于一个变量，如果在声明之前使用它的话，会有个默认值undefined；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span> ;</span><br></pre></td></tr></table></figure><p>这样容易有一些不确定因素在里面，比如看到一个undefined，它有可能是变量提升的，还有可能它是被我们赋值的undefined；<br>而使用let的时候呢</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// Uncaught ReferenceError: a is not defined</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>显然这样更加符合逻辑，这个报错的意义也更加明确。<br>所以我感觉let不存在变量提升倒是比较规范的地方，规则越严谨，不确定因素越少。</p><h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><p>只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。</p><p>ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p><blockquote><p>总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p></blockquote><p>明白了这个道理，下面这段代码也就很好理解了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// TDZ开始</span></span><br><span class="line">  tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> tmp; <span class="comment">// TDZ结束</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">  tmp = <span class="number">123</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tmp在声明前都是其死区，所以一直报错；</p><p>这里我们需要注意一下typeof命令。如果没有用到let的话，typeof随便用；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> undeclared_variable <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure><p>这里的 undeclared_variable 没有被声明过，我们也可以用tpyeof，返回undefined；</p><p>但是如果用到let呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> a <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">'troubledot'</span></span><br></pre></td></tr></table></figure><p>现在我们知道<strong>暂时性死区</strong>这个概念了就很好理解了，typeof位于a的暂时性死区内，所以报错也就自然而然了。</p><blockquote><p>在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。</p></blockquote><p>还有一些比较隐蔽的死区不太容易发现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x = y, y = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>执行函数bar的时候，给x赋值y，但是y并没有声明，也就是说我们在y的暂时性死区使用了它，所以会报错。说白了咱们认死理就好</p><blockquote><p>先声明，再使用</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x = <span class="number">2</span>, y = x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">bar(); <span class="comment">// [2,2]</span></span><br></pre></td></tr></table></figure><p>使用x之前已经声明过x了，所以不会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">var</span> x = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> x = x;</span><br><span class="line"><span class="comment">// ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure><p>上面这种情况也比较有意思，其实我们要理解这个只需要明白变量的声明是 ‘let x = x’这句执行完以后才完成的。也就是说，在执行这一句的过程中遇到了x这样一个变量，此时因为赋值语句还没有执行完，所以这里也算是x的暂时性死区，当然就会报错了。</p><h4 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h4><blockquote><p>let不允许在相同作用域内，重复声明同一个变量。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们注意到，只要用到了let就不能有重复声明，不管重复的变量是不是用let声明的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arg; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能在函数内部重复声明参数，但是下面这种不会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> arg; <span class="comment">// 不报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回忆一下最开始的时候说的，let只在let命令所在的代码块内有效。</p><h3 id="2、块级作用域"><a href="#2、块级作用域" class="headerlink" title="2、块级作用域"></a>2、块级作用域</h3><p>通过对let的了解，看得出来let位JavaScript新增了块级作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(n); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子能够很好的帮我吗理解块级作用域，let声明的变量，只在自己的作用域内有效，代码块外层不会收到内层的影响。<br>ES6 允许块级作用域的任意嵌套。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;&#123;<span class="keyword">let</span> insane = <span class="string">'Hello World'</span>&#125;&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure><p>上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  &#123;<span class="keyword">let</span> insane = <span class="string">'Hello World'</span>&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(insane); <span class="comment">// 报错</span></span><br><span class="line">&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure><p>外层读取不到内存定义的变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  <span class="keyword">let</span> insane = <span class="string">'Hello World'</span>;</span><br><span class="line">  &#123;<span class="keyword">let</span> insane = <span class="string">'Hello World'</span>&#125;</span><br><span class="line">&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure><p>内层作用域可以定义外层作用域内的同名变量。</p><p>我们知道，立即执行函数就是为了隔离作用域，避免变量污染，所以块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IIFE 写法</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 块级作用域写法</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h4><p>函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题。</p><p>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种情况，根据es5的规定，都是非法的。<br>但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。</p><p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 重复声明一次函数f</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>上面代码在 ES5 中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p><p>ES6 就完全不一样了，理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响。但是，如果你真的在 ES6 浏览器中运行一下上面的代码，是会报错的，这是为什么呢？</p><p>原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。</p><ul><li>允许在块级作用域内声明函数。</li><li>函数声明类似于var，即会提升到全局作用域或函数作用域的头部。</li><li>同时，函数声明还会提升到所在的块级作用域的头部。</li></ul><p>注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。</p><p>根据这三条规则，在浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器的 ES6 环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 重复声明一次函数f</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure><p>上面的代码在符合 ES6 的浏览器中，都会报错，因为实际运行的是下面的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 浏览器的 ES6 环境</span><br><span class="line">function f() &#123; console.log(&apos;I am outside!&apos;); &#125;</span><br><span class="line">(function () &#123;</span><br><span class="line">  var f = undefined;</span><br><span class="line">  if (false) &#123;</span><br><span class="line">    function f() &#123; console.log(&apos;I am inside!&apos;); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line">// Uncaught TypeError: f is not a function</span><br></pre></td></tr></table></figure><p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明语句</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">'secret'</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">'secret'</span>;</span><br><span class="line">  <span class="keyword">let</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，还有一个需要注意的地方。ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="3-const命令"><a href="#3-const命令" class="headerlink" title="3.const命令"></a>3.const命令</h3><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><p>const声明一个只读的常量。一旦声明，常量的值就不能改变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.1415</span>;</span><br><span class="line">PI <span class="comment">// 3.1415</span></span><br><span class="line"></span><br><span class="line">PI = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure><p>改变const声明的PI的值就会报错。</p><p>const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo;</span><br><span class="line"><span class="comment">// SyntaxError: Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure><p>只声明不赋值就会报错。<br>其他的地方，const和let一样，不能重复声明，存在暂时性死区，只能在声明以后再使用。</p><h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 foo 添加一个属性，可以成功</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br><span class="line">foo.prop <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 foo 指向另一个对象，就会报错</span></span><br><span class="line">foo = &#123;&#125;; <span class="comment">// TypeError: "foo" is read-only</span></span><br></pre></td></tr></table></figure><p>这里的foo是一个对象，它存储的其实是一个地址，这个地址指向一个对象。对象本身可以改变的，所以我们给他添加一个属性的时候没有报错，但是如果改变了指向的话，就会报错了。</p><p>对象是这样，数组也是。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [];</span><br><span class="line">a.push(<span class="string">'Hello'</span>); <span class="comment">// 可执行</span></span><br><span class="line">a.length = <span class="number">0</span>;    <span class="comment">// 可执行</span></span><br><span class="line">a = [<span class="string">'Dave'</span>];    <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>当然，有时候或许我们还真的需要这种功能，就是真正的让对象都不能变化，我们可以使用Object.freeze方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规模式时，下面一行不起作用；</span></span><br><span class="line"><span class="comment">// 严格模式时，该行会报错</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>这里的foo指向一个冻结的对象Object，所以添加新属性不起作用，严格模式时还会报错。</p><p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> constantize = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach( <span class="function">(<span class="params">key, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span> ) &#123;</span><br><span class="line">      constantize( obj[key] );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="ES6声明变量的6种方法"><a href="#ES6声明变量的6种方法" class="headerlink" title="ES6声明变量的6种方法"></a>ES6声明变量的6种方法</h4><p>ES5声明变量只有var和function两种命令；ES6中除了这两种，还有四种：我们前面提到的let、const，还有import和class命令；</p><h3 id="4-顶层对象的属性"><a href="#4-顶层对象的属性" class="headerlink" title="4.顶层对象的属性"></a>4.顶层对象的属性</h3><p>顶层对象，在浏览器环境指的是window对象，在node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.a = <span class="number">1</span>;</span><br><span class="line">a. <span class="comment">// 1</span></span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>也就是所有我们定义的全局变量，都可以看作是顶层对象的属性；也就是说上面的顶层对象的属性赋值和全局变量的赋值其实是同一件事情。</p><p>顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</p><p>ES6 为了改变这一点：</p><ul><li>一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；</li><li>另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果在 Node 的 REPL 环境，可以写成 global.a</span></span><br><span class="line"><span class="comment">// 或者采用通用方法，写成 this.a</span></span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">window</span>.b <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>这里var声明的全局变量a就是顶层对象的属性，而用let声明的b则不是。</p><h3 id="5-global对象"><a href="#5-global对象" class="headerlink" title="5.global对象"></a>5.global对象</h3><p>ES5 的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。</p><ul><li>浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。</li><li>浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。</li><li>Node 里面，顶层对象是global，但其他环境都不支持。</li></ul><p>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。</p><ul><li>全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块。</li><li>函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。</li><li>不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么eval、new Function这些方法都可能无法使用。</li></ul><p>也就是说，我们的js代码有可能因为换了执行环境就出错了<br>综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">(<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span></span><br><span class="line">   ? <span class="built_in">window</span></span><br><span class="line">   : (<span class="keyword">typeof</span> process === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">      <span class="keyword">typeof</span> <span class="built_in">require</span> === <span class="string">'function'</span> &amp;&amp;</span><br><span class="line">      <span class="keyword">typeof</span> global === <span class="string">'object'</span>)</span><br><span class="line">     ? global</span><br><span class="line">     : <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">var</span> getGlobal = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> self; &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> <span class="built_in">window</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> global !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> global; &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'unable to locate global object'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有点猥琐。。</p><p>现在有一个提案，在语言标准的层面，引入global作为顶层对象。也就是说，在所有环境下，global都是存在的，都可以从它拿到顶层对象。</p><p>垫片库system.global模拟了这个提案，可以在所有环境拿到global。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS 的写法</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'system.global/shim'</span>)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 模块的写法</span></span><br><span class="line"><span class="keyword">import</span> shim <span class="keyword">from</span> <span class="string">'system.global/shim'</span>; shim();</span><br></pre></td></tr></table></figure><p>上面代码可以保证各种环境里面，global对象都是存在的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS 的写法</span></span><br><span class="line"><span class="keyword">var</span> global = <span class="built_in">require</span>(<span class="string">'system.global'</span>)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 模块的写法</span></span><br><span class="line"><span class="keyword">import</span> getGlobal <span class="keyword">from</span> <span class="string">'system.global'</span>;</span><br><span class="line"><span class="keyword">const</span> global = getGlobal();</span><br></pre></td></tr></table></figure><p>上面代码将顶层对象放入变量global。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>ztree的自定义编辑</title>
      <link href="/2018/08/29/ztree%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%96%E8%BE%91/"/>
      <url>/2018/08/29/ztree%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%96%E8%BE%91/</url>
      <content type="html"><![CDATA[<p>组织架构树是项目中特别常见的一类组件，我一般都用<a href="http://www.ztree.me/" target="_blank" rel="noopener">ztree</a>，前两天又用到这个，不过需求跟平时有点区别，我感觉也算比较常见，就把他稍微整理一下。</p><p>需求大致是这样：一个普通的树结构，点击编辑。<br><img src="http://res.troubledot.cn/edit.png" alt=""></p><p>会弹出来操作按钮，而且并不是所有用户都有增删改的权限，对该节点不具备的权限会置灰，如下图所示。</p><p><img src="http://res.troubledot.cn/WX20180830-122042@2x.png" alt=""></p><p>我们知道ztree是带编辑功能的，但是长这样子</p><p><img src="http://res.troubledot.cn/ztree.png" alt=""></p><p>而且ztree的官方demo的编辑按钮是在鼠标hover到节点以后才弹出来的，显然跟我们的需求不符合。我看了下代码，发现删除和编辑用的是这两个API</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">editName(node)    <span class="comment">//参数为要操作的节点</span></span><br><span class="line">removeNode (node, callbackFlag) <span class="comment">//参数为要操作的节点</span></span><br></pre></td></tr></table></figure><p>鼠标的hover其实不是伪类:hover,而是调用了 addHoverDom 和 removeHoverDom这两个API，目的是拿到要操作的节点。再看我们的需求，发现我们需要所有的节点（ztree对象的getNodes()方法可以拿到所有节点），因为我们需要让每个节点的操作按钮都显示出来。<br>基本思路：遍历所有节点，然后操作该节点对应的dom，拼接操作按钮图标（这里需要判断是否有权限，根据权限拼接不同的图标），再给按钮绑定事件，调用对应操作的API；</p><p> 代码如下，因为还有地方要调用，所以我将其封装成了方法</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">addnewBtn</span>(<span class="params">nodeList</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newCount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> zTree = $.fn.zTree.getZTreeObj(<span class="string">"tree"</span>);</span><br><span class="line">    nodeList.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">element, index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> sObj = $(<span class="string">"#"</span> + element.tId + <span class="string">"_span"</span>);</span><br><span class="line">        <span class="keyword">if</span> (zTree.setting.edit.enable) &#123;     <span class="comment">//判断当前是否可以编辑</span></span><br><span class="line">            <span class="keyword">var</span> addable = (element.addable == <span class="literal">undefined</span>) || (element.addable == <span class="literal">true</span>) ? <span class="string">"addable"</span> : <span class="string">""</span>; <span class="comment">//新增权限 权限增加了一个able的标记，根据class取不同图片，下面绑定事件也是绑在该class上 下同</span></span><br><span class="line">            <span class="keyword">var</span> editable = (element.editable == <span class="literal">undefined</span>) || (element.editable == <span class="literal">true</span>) ? <span class="string">"editable"</span> : <span class="string">""</span>;   <span class="comment">//编辑权限</span></span><br><span class="line">            <span class="keyword">var</span> removeable = (element.removeable == <span class="literal">undefined</span>) || (element.removeable == <span class="literal">true</span>) ? <span class="string">"removeable"</span> : <span class="string">""</span>;  <span class="comment">//删除权限</span></span><br><span class="line">            <span class="keyword">if</span> (element.editNameFlag || $(<span class="string">"#addBtn_"</span> + element.tId).length &gt; <span class="number">0</span> || $(<span class="string">"#remove_"</span> + element.tId).length &gt; <span class="number">0</span> || $(<span class="string">"#edit_"</span> + element.tId).length &gt; <span class="number">0</span>) <span class="keyword">return</span>;  <span class="comment">//有按钮就不再加了</span></span><br><span class="line">            <span class="keyword">var</span> addStr = <span class="string">"&lt;span class='button add "</span> + addable + <span class="string">"' id='addBtn_"</span> + element.tId +</span><br><span class="line">                <span class="string">"' title='add node' onfocus='this.blur();'&gt;&lt;/span&gt;"</span>; <span class="comment">//添加按钮</span></span><br><span class="line">            <span class="keyword">var</span> editStr = <span class="string">"&lt;span class='button edit "</span> + editable + <span class="string">"' id='edit_"</span> + element.tId +<span class="string">"' title='rename' onfocus='this.blur();'&gt;&lt;/span&gt;"</span>; <span class="comment">//编辑按钮</span></span><br><span class="line">            <span class="keyword">var</span> delStr = <span class="string">"&lt;span class='button remove "</span> + removeable + <span class="string">"' id='remove_"</span> + element.tId + <span class="string">"' title='remove' onfocus='this.blur();'&gt;&lt;/span&gt;"</span>; <span class="comment">//删除按钮</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">allstr</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> allstr;</span><br><span class="line">                <span class="keyword">if</span> (element.isParent) &#123;</span><br><span class="line">                    allstr = addStr + editStr + delStr;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    allstr = editStr + delStr;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> allstr;</span><br><span class="line">            &#125;   <span class="comment">// 子节点不需要新增按钮</span></span><br><span class="line">            sObj.after(allstr()); <span class="comment">//拼接html</span></span><br><span class="line">            <span class="keyword">if</span> ((element.addable == <span class="literal">undefined</span>) || (element.addable == <span class="literal">true</span>)) &#123;</span><br><span class="line">                <span class="keyword">var</span> btn = $(<span class="string">"#addBtn_"</span> + element.tId);  <span class="comment">//取到有权限的添加按钮</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (btn) btn.bind(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  <span class="comment">//给添加按钮绑定事件</span></span><br><span class="line">                <span class="keyword">var</span> newnode = zTree.addNodes(element, &#123; <span class="attr">id</span>: (<span class="number">100</span> + newCount), <span class="attr">pId</span>: element.id, <span class="attr">name</span>: <span class="string">"new node"</span> + (newCount++), <span class="attr">isParent</span>: <span class="literal">true</span> &#125;, <span class="literal">true</span>); <span class="comment">//新增文件夹（默认新增的是文件 需求有点怪😂）</span></span><br><span class="line">                <span class="keyword">var</span> tId = newnode[<span class="number">0</span>].tId; <span class="comment">//添加的节点  获取这个是因为添加的是文件夹 所以他还能继续添加</span></span><br><span class="line">                <span class="keyword">var</span> nStr = <span class="string">"&lt;span class='button add addable' id='addBtn_"</span> + tId + <span class="string">"' title='add node' onfocus='this.blur();'&gt;&lt;/span&gt;&lt;span class='button edit editable' id='edit_"</span> + tId + <span class="string">"' title='rename' onfocus='this.blur();'&gt;&lt;/span&gt;&lt;span class='button remove removeable' id='remove_"</span> + tId + <span class="string">"' title='remove' onfocus='this.blur();'&gt;&lt;/span&gt;"</span>; </span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> nobj = $(<span class="string">"#"</span> + tId + <span class="string">"_span"</span>).after(nStr); <span class="comment">//给添加的节点后面加操作按钮</span></span><br><span class="line">                <span class="keyword">var</span> nbtn = $(<span class="string">"#addBtn_"</span> + tId);</span><br><span class="line">                nbtn.bind(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  <span class="comment">//给添加的节点上的添加按钮绑定事件</span></span><br><span class="line">                    <span class="comment">/* Act on the event */</span></span><br><span class="line">                    zTree.addNodes(newnode[<span class="number">0</span>], &#123; <span class="attr">id</span>: (<span class="number">1000</span> + newCount), <span class="attr">pId</span>: newnode[<span class="number">0</span>].id, <span class="attr">name</span>: <span class="string">"new node"</span> + (newCount++), <span class="attr">isParent</span>: <span class="literal">true</span> &#125;, <span class="literal">true</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们发现增和删、改是有区别的。 其实比较好理解，删和改我们只需要知道操作的对象就可以了，但是添加的时候我们还需要知道添加的内容。  </p><p>这里需要注意一下，咱们添加的这几个操作按钮只对展开的节点有用，也就是说当我们点击编辑以后，展开那些一开始没有展开的节点，发现他们的子节点是没有操作按钮的，显然这是不符合我们需求的。最简单的办法，用节点展开的回调函数onExpand，展开节点的时候给他所有的子节点添加按钮，这也是我封装addnewBtn的主要原因</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">zTreeOnExpand</span>(<span class="params">event, treeId, treeNode</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> treeObj = $.fn.zTree.getZTreeObj(<span class="string">"tree"</span>);</span><br><span class="line">    <span class="keyword">var</span> nodes = treeObj.getNodesByFilter(filter,<span class="literal">false</span>,treeNode); <span class="comment">// 查找子节点集合</span></span><br><span class="line">    addnewBtn(nodes);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面就剩下编辑和删除了，我们前面只是拼了个按钮上去，并没有做功能，代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> operateNode;  <span class="comment">//定义一个变量存当前操作的节点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">zTreeOnClick</span>(<span class="params">event, treeId, treeNode</span>) </span>&#123;</span><br><span class="line">    operateNode = treeNode;  <span class="comment">//获取当前操作的节点存入 operateNode</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$(<span class="built_in">document</span>).on(<span class="string">'click'</span>, <span class="string">'.button.edit.editable'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;  <span class="comment">//事件绑定到editable 上是为了区分权限 下同</span></span><br><span class="line">    <span class="keyword">var</span> treeObj = $.fn.zTree.getZTreeObj(<span class="string">"tree"</span>);</span><br><span class="line">    treeObj.editName(operateNode);    <span class="comment">// 编辑节点</span></span><br><span class="line">&#125;);</span><br><span class="line">   </span><br><span class="line">$(<span class="built_in">document</span>).on(<span class="string">'click'</span>, <span class="string">'.button.remove.removeable'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> treeObj = $.fn.zTree.getZTreeObj(<span class="string">"tree"</span>);</span><br><span class="line">    treeObj.removeNode(operateNode);   <span class="comment">// 删除节点</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里只是部分代码，<a href="https://github.com/Troubledot/Common-components" target="_blank" rel="noopener">完整的代码在这里</a>，自己整理的很简单的东西，如果运气好能帮到别人，那就太棒了。</p>]]></content>
      
      <categories>
          
          <category> 组件整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ztree </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>编译原理学习笔记--引论</title>
      <link href="/2018/08/06/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%BC%95%E8%AE%BA/"/>
      <url>/2018/08/06/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%BC%95%E8%AE%BA/</url>
      <content type="html"><![CDATA[<blockquote><p>想花点时间系统学习下计算机基础，我会把编译原理里面的习题和自己的一些笔记在这整理一下。</p></blockquote><h3 id="引论"><a href="#引论" class="headerlink" title="引论"></a>引论</h3><h4 id="1-1-语言处理器"><a href="#1-1-语言处理器" class="headerlink" title="1.1 语言处理器"></a>1.1 语言处理器</h4><p>编译器：一个编译器就是一个程序，它可以阅读以某一种语言（源语言）编写的程序，并把该程序翻译成为一个等价的、用另一种语言（目标语言）编写的程序。<strong>编译器的重要任务之一是报告它在翻译过程中发现的源程序中的错误</strong>。</p><p>如果目标程序是一个可执行的机器语言程序，那么他就可以被用户调用，处理输入并产生输出。</p><p>解释器：解释器是另一种常见的语言处理器。<strong>它并不通过翻译的方式生成目标程序</strong>。从用户的角度看，解释器直接利用用户提供的输入执行源程序中指定的操作。</p><p>在把用户输入映射成输出的过程中，由一个编译器产生的机器语言目标程序通常比一个解释器快很多。然而解释器的错误诊断效果通常比编译器更好，因为它逐个语句的执行源程序。</p><h5 id="习题1-1-1：编译器和解释器之间的区别是什么？"><a href="#习题1-1-1：编译器和解释器之间的区别是什么？" class="headerlink" title="习题1.1.1：编译器和解释器之间的区别是什么？"></a>习题1.1.1：编译器和解释器之间的区别是什么？</h5><p>编译器就是一个程序，它可以阅读以某一种语言（源语言）编写的程序，并把该程序翻译成一个等价的、用另一种语言（目标语言）编写的程序，而解释器不是通过翻译的方式生成目标程序的，用户的角度来看解释器是直接利用用户提供的输入执行源程序中指定的操作的。</p><h5 id="习题1-1-2：编译器相对于解释器的优点是什么？解释器相对于编译器的优点是什么？"><a href="#习题1-1-2：编译器相对于解释器的优点是什么？解释器相对于编译器的优点是什么？" class="headerlink" title="习题1.1.2：编译器相对于解释器的优点是什么？解释器相对于编译器的优点是什么？"></a>习题1.1.2：编译器相对于解释器的优点是什么？解释器相对于编译器的优点是什么？</h5><p>在把用户输入映射成输出的过程中，由编译器产生的机器语言目标程序比解释器快很多，但是解释器的错误诊断效果比编译器更好，因为它逐个语句的执行源程序。</p><h5 id="习题1-1-3：在一个语言处理系统中，编译器产生汇编语言而不是机器语言的好处是什么？"><a href="#习题1-1-3：在一个语言处理系统中，编译器产生汇编语言而不是机器语言的好处是什么？" class="headerlink" title="习题1.1.3：在一个语言处理系统中，编译器产生汇编语言而不是机器语言的好处是什么？"></a>习题1.1.3：在一个语言处理系统中，编译器产生汇编语言而不是机器语言的好处是什么？</h5><p>因为汇编语言比较容易输出和调试。</p><h5 id="习题1-1-4-把一种高级语言翻译成另一种高级语言的编译器称为源到源（source-to-sourc）的翻译器，编译器使用c语言作为目标语言有什么好处？"><a href="#习题1-1-4-把一种高级语言翻译成另一种高级语言的编译器称为源到源（source-to-sourc）的翻译器，编译器使用c语言作为目标语言有什么好处？" class="headerlink" title="习题1.1.4:把一种高级语言翻译成另一种高级语言的编译器称为源到源（source-to-sourc）的翻译器，编译器使用c语言作为目标语言有什么好处？"></a>习题1.1.4:把一种高级语言翻译成另一种高级语言的编译器称为源到源（source-to-sourc）的翻译器，编译器使用c语言作为目标语言有什么好处？</h5><p>就好比为什么编译器要产生汇编语言而是不是机器语言一样，C语言更简单更常用更加容易理解，同样方便调试和输出。</p><h5 id="习题1-1-5-描述一下汇编器所要完成的任务。"><a href="#习题1-1-5-描述一下汇编器所要完成的任务。" class="headerlink" title="习题1.1.5 描述一下汇编器所要完成的任务。"></a>习题1.1.5 描述一下汇编器所要完成的任务。</h5><p>汇编器就类似于编译器，只是它的源语言不是高级语言而是汇编语言。同样，它需要一个预处理器进行预处理，如聚合文件，展开宏等。写成的机器语言也要类似与连接器和加载器的程序，完成类似的工作。</p><h5 id="习题1-6-1-对照下面的c代码，指出赋给w，x，y，和z的值。"><a href="#习题1-6-1-对照下面的c代码，指出赋给w，x，y，和z的值。" class="headerlink" title="习题1.6.1 对照下面的c代码，指出赋给w，x，y，和z的值。"></a>习题1.6.1 对照下面的c代码，指出赋给w，x，y，和z的值。</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> w, x, y, z;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">4</span> ; <span class="keyword">int</span> j = <span class="number">5</span>;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">7</span>;</span><br><span class="line">i = <span class="number">6</span>;</span><br><span class="line">w = i + j;</span><br><span class="line">&#125;</span><br><span class="line">x = i + j;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">8</span>;</span><br><span class="line">y = i + j;</span><br><span class="line">&#125;</span><br><span class="line">z = i + j;</span><br></pre></td></tr></table></figure><p>w = 13; x = 11; y = 13; z = 11;</p><h5 id="习题1-6-2"><a href="#习题1-6-2" class="headerlink" title="习题1.6.2"></a>习题1.6.2</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> w, x, y, z;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span> ; <span class="keyword">int</span> j = <span class="number">4</span>;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">w = i + j;</span><br><span class="line">&#125;</span><br><span class="line">x = i + j;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">6</span>;</span><br><span class="line">i = <span class="number">7</span>;</span><br><span class="line">y = i + j;</span><br><span class="line">&#125;</span><br><span class="line">z = i + j;</span><br></pre></td></tr></table></figure><p>w = 9; x = 7; y = 13; z = 11;</p><h5 id="习题1-6-2-如下块结构代码，假设使用常见的声明的静态作用域规则，请指出其中12个声明中的每一个的作用域"><a href="#习题1-6-2-如下块结构代码，假设使用常见的声明的静态作用域规则，请指出其中12个声明中的每一个的作用域" class="headerlink" title="习题1.6.2 如下块结构代码，假设使用常见的声明的静态作用域规则，请指出其中12个声明中的每一个的作用域"></a>习题1.6.2 如下块结构代码，假设使用常见的声明的静态作用域规则，请指出其中12个声明中的每一个的作用域</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="keyword">int</span> w, x, y, z;    <span class="comment">/* 块B1 */</span></span><br><span class="line">&#123; <span class="keyword">int</span> x, z; <span class="comment">/* 块B2 */</span></span><br><span class="line">&#123;<span class="keyword">int</span> w, x;   <span class="comment">/* 块B3 */</span>  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> w, x;        <span class="comment">/* 块B4 */</span></span><br><span class="line">&#123;<span class="keyword">int</span> y, z;   <span class="comment">/* 块B5 */</span>  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自上至下依次</p><p>w: B1 B2<br>x: B1<br>y: B1 B2 B3 B4<br>z: B1 B4</p><p>x: B2<br>z: B2 B3</p><p>w:B3<br>x:B3</p><p>w:B4 B5<br>x:B4 B5</p><p>y:B5<br>z:B5</p><blockquote><p>还有点疑问不太确定自己的理解对不对。</p></blockquote><h5 id="习题1-6-3-下面C代码的打印结果是什么"><a href="#习题1-6-3-下面C代码的打印结果是什么" class="headerlink" title="习题1.6.3 下面C代码的打印结果是什么"></a>习题1.6.3 下面C代码的打印结果是什么</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> a(x+1)</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,x)&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">c</span><span class="params">()</span></span>&#123;<span class="keyword">int</span> x = <span class="number">1</span>;<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;b();c()&#125;</span><br></pre></td></tr></table></figure><p>2</p><p>2</p><p>感觉还是考察作用域</p><h3 id="第一章总结"><a href="#第一章总结" class="headerlink" title="第一章总结"></a>第一章总结</h3><ul><li><strong>语言处理器：</strong>一个集成的软件开发环境，其中包括很多种类的语言处理器，比如编译器、解释器、汇编器、连接器、加载器、调试器以及程序概要提取工具。</li><li><strong>编译器的步骤：</strong>一个编译器的运作需要一系列的步骤，每个步骤把源程序从一个中间表示转换成另一个中间表示。</li><li><strong>机器语言和汇编语言：</strong>机器语言是第一代程序设计语言，然后是汇编语言。使用这些语言进行编程时既费时又容易出错。</li><li><strong>编译器设计中的建模：</strong>编译器设计是理论对实践有很大影响的领域之一。已知在编译器设计中有用的模型包括自动机、文法、正则表达式、树型结构和很多其他理论概念。</li><li><strong>代码优化：</strong>虽然代码不能达到真正最优化，但提高代码效率的科学既复杂又非常重要。它是编译技术研究的一个重要部分。</li><li><strong>高级语言：</strong>随着时间的流逝，程序设计语言担负了越来越多原先由程序员负责的任务，比如内存管理、类型一致性检查和代码并发执行。</li><li><strong>编译器和计算机体系结构：</strong>编译器技术影响了计算机的体系结构，同时也受到体系结构发展的影响。体系结构中的很多现代创新都依赖于编译器能够从源程序中抽取出有效利用硬件能力的机会。</li><li><strong>软件生产率和软件安全性：</strong>使得编译器能够优化代码的技术同样能够用于多种不同的程序分析任务。这些任务既包括探测常见的程序错误，也包括发现程序可能会受到已被黑客们发现的多种入侵方式之一的伤害。</li><li><strong>作用域规则：</strong>一个x的声明的作用域是一段上下文，在此上下文中对x的使用指向这个声明。如果仅仅通过阅读某个语言的程序就能确定它的作用域，那么这个语言就使用了静态作用域，或者说词法作用域。否则这个语言就使用了动态作用域。</li><li><strong>环境：</strong>名字和内存位置关联，然后再和值相关联。这个情况可以使用环境和状态来描述。其中环境把名字映射成为存储位置，而状态则把位置映射到它的值；</li><li><strong>快结构：</strong>允许语句块相互嵌套的语言称为快结构语言。假设一个块中有一个x的声明D，而嵌套于这个块中的块B中有一个对名字x的使用。如果在这两个块之间没有其他声明了x的块，那么这个x的使用位于D的作用域内；</li><li><strong>参数传递：</strong>参数可以通过值或引用的方式从调用过程传递给被调用过程。当通过值传递的方式传递大型对象时，实际被传递的值是指向这些对象本身的引用。这样就变成了一个高效的引用调用；</li><li><strong>别名：</strong>当参数被以引用的方式（高效地）传递时，两个形式参数会指向同一个对象。这会造成一个变量的修改改变了另一个变量的值。</li></ul>]]></content>
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
            <tag> 习题 </tag>
            
            <tag> 龙书 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>生命面前，众生并不平等</title>
      <link href="/2018/07/08/%E7%94%9F%E5%91%BD%E5%AF%B9%E4%BC%97%E7%94%9F%E5%B9%B6%E4%B8%8D%E5%B9%B3%E7%AD%89/"/>
      <url>/2018/07/08/%E7%94%9F%E5%91%BD%E5%AF%B9%E4%BC%97%E7%94%9F%E5%B9%B6%E4%B8%8D%E5%B9%B3%E7%AD%89/</url>
      <content type="html"><![CDATA[<p>机缘巧合去看了《我不是药神》，我第一次看完一个电影想了那么多，当然这也跟我看过的电影少有一些关系。但是不管怎么说这真的是一部非常棒的国产电影，引人深思。</p><p>程勇是一个普通人，就像我们身边的张叔李大伯一样，他没啥大本事脾气还臭，租了一个破店面卖保健品，他卖的药就跟邻居大爷说的一样：没逑用。自然也就没啥生意了。离婚以后老婆要带着儿子去移民，上面还有个有心脑血管疾病的老爹需要照顾，人生很失败，他自己也很颓废，就像大多数普通人一样过的小心翼翼，每周带儿子去澡堂子搓个澡，完事吃个大排档，儿子想要双球鞋，很拮据但是也还能拿得出来，生活如果按照当下的轨迹往前走的话，日子过的窝囊但是还能活。所以当吕受益第一次找到他的时候，他像大多数穷人一样，穷但是有底线，犯法的事情不会干。但是老父亲进医院了，病很重，不过能治，要八万。这里我感觉特别强烈，因为我们家曾经有过一模一样的经历，我想当时的老赵应该就像此时的程勇一样无助，不同的是老赵没有遇到吕受益，没有这条违法但是能马上来钱的路子。其实程勇也是一个受害者，他迈出这一步也恰恰是因为他父亲天价的手术费。他开始走私仿制药，500进的药卖3000一瓶，他赚了6倍病人还对他感恩戴德，因为他给这些白血病人省了十倍的药费。老父亲的手术做了，吃饭的时候都嫌喂的慢了，被房东上了锁的店门也重新开了，去夜店甚至都能拿钱砸老板了—有钱是真特么好。</p><hr><p>吕受益，黄毛，思慧和老神父跟着他有药吃，有钱赚，未来充满了希望，吕受益邀请程勇去他家的时候说现在好了，有药了也有钱了，儿子结婚早的话没准他还能当爷爷呢。随着张长林的一次卖假药活动，平静的日子被打破了。程勇不是圣人，就像黄毛说的，他做这些就是为了钱，他现在有钱了就不想继续干违法的事情了，怕坐牢——他把代理权以200多万的价格卖给了张长林。散伙的时候，他说了一句：我他妈又不是白血病人 。也是啊，这世上，除了自己和至亲至爱，别人的死活与我何干，谁都没有义务帮别人。这一段特别催泪：黄毛无畏，无牵无挂，他是最决绝的，满手鲜血冲进大雨里。老牧师，年事以高，再加上职业的原因，其实也早已看穿了生死。思慧：思慧不是病人，她女儿是，加上她算是有一份可以来钱的工作。所以这些人离开的没有一点拖泥带水。唯一不同的是吕受益，他真的以为大家喝多了吗？他只是不愿意相信刚看到的希望就这样破灭了而已，他是了解程勇的，他知道他能干得出来这种事情，同时他也是最想活下去的人，自己高大帅气，老婆美丽贤惠，儿子健康可爱，他不想做英雄，他没有资本也没有勇气像其他人那样潇洒从容，生死面前，一切的大义、勇气都显得那么奢侈。直到程勇冲他喊了那声滚。他内心的绝望和无助也应该是几个人里面最强烈的，他想活着，哪怕以那种最卑微的形式。我记得吕受益说过：他看到自己的儿子就不想死了，但是最后，看了一眼老婆孩子他自杀了。他只不过是无数绝症病人中的一个而已，生命的凋零就像落叶一般稀松平常，世界并不会因为谁的死就发生改变，吕受益走了但是其他的病人还需要继续想办法让自己活下去。 这里我感觉程勇其实有一点被道德绑架的感觉，他只是个普通人，没有义务帮任何人，更何况他已经帮过好多人了。但是这就是人和机器的区别，人有感情，只有计算机才会只讲道理。 我不杀伯仁，伯仁因我而死。 就这样程勇又开始卖药了。 好多人说他在赎罪，其实他何罪之有呢？我感觉他更多的是在弥补自己内心的愧疚，他把吕受益的死怪自己头上了，他不想再发生同样的事情，所以500进的药他卖500，到后面供应紧张，2000进的药也卖500，此时的他没了当年的嚣张跋扈，多了一些沉稳内敛。而且他不再像之前那样怕坐牢了，人们老在说成熟男人的人格魅力，这一点在此刻的程勇身上很能体现。</p><hr><p>好景不长，既然是违法的事情那么肯定会有人来追究，医药代表不断施压，警方的侦破力度也不断加大，黄毛帮程勇顶罪被车撞死了，他听了勇哥的话剃了头买了回家的火车票，他才二十岁啊，他想活着犯了什么罪，真的是灵魂的拷问。如果没有跟着勇哥卖药就没有警察抓他，但是如果没有程勇，他可能跟吕受益一样活不到出车祸的时候。剧情就是这么矛盾，而且矛盾也是整部剧的精髓。一开始的时候，程勇知道这事违法，很强烈的拒绝了吕受益的，因为老父亲的病，他很矛盾但还是选择了去卖印度药；吕受益带程勇去他们家的时候指着儿子跟程勇说过，我看到他就不想死了，最后呢，看了一眼自己的儿子选择了自杀；黄毛一开始是看不起程勇的，但是他为了自己的义气，为了帮到自己的朋友们选择了跟他干；思慧知道程勇的小心思，但是为了帮助更多的病友，更重要的是为了自己的女儿，她选择了妥协，而当程勇从她家里离开的时候，她的笑是发自内心的；病人求警察别再查案，放过假药贩子；警察开慢警车，让罪犯得到应有的尊重；真正的药神是诺华，但是却因为药价昂贵被推上了风口浪尖。。。</p><hr><p>药企的根本是一个企业，企业需要盈利才能长久发展。悬壶济世不求回报那是观世音菩萨，医生是上帝赐予我们最美好的职业，无论如何我们还是应该感谢那些医药工作者们的付出，白血病是本来是绝症，但是因为诺华的格列宁，绝症变成了一个慢性病，电影里的老太太哭诉道：我吃了两年的正版要，房子吃没了家人吃垮了。。咱们换个角度，如果没有诺华，别说你有一套房子，就算你有北京城的十套别墅又能怎样？其实是诺华给了那些有能力的人拿钱买命的资格，程勇做的事让这个有能力的标准降低了一大档。努力赚钱，不仅会让生活有所改观，开好车，住大房子，更重要的是能为自己守护更多东西，程勇为他父亲的手术费犯愁的时候，吕受益老婆因为感谢程勇喝那一大杯白酒的时候，思慧为了女儿在夜店跳钢管舞的时候，黄毛为了朋友去帮那个自己压根看不上的程勇的时候，老太太哭诉自己吃药吃垮了家人，吃掉了房子的时候。。。我一直在想，如果这种事情遇到我身上我该怎么办，我能怎么办？ 寿命的长短我们无法左右，但是生活的质量是可以追求的，如果可以，我想给身边的人足够好的生活，因为在生命面前，其实并不是我们想象的那样众生平等。</p>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 药神 </tag>
            
            <tag> 生命 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>为什么 ++[[]][+[]]+[+[]] = 10？</title>
      <link href="/2018/07/06/%E4%B8%BA%E4%BB%80%E4%B9%88%20++%5B%5B%5D%5D%5B+%5B%5D%5D+%5B+%5B%5D%5D%20=%2010%EF%BC%9F/"/>
      <url>/2018/07/06/%E4%B8%BA%E4%BB%80%E4%B9%88%20++%5B%5B%5D%5D%5B+%5B%5D%5D+%5B+%5B%5D%5D%20=%2010%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p><a href="http://justjavac.com/javascript/2012/05/24/can-you-explain-why-10.html" target="_blank" rel="noopener">原文链接</a></p><p>首先，问“这个问题(英文)”的人是个天才，他怎么会遇到这样的一个问题。 其次，回答这个问题的人更是一个天才，我难以想象他会回答这个问题，更难以想象的是，他的回答是如此的详细和丰富和完整，真正称得上诲人不倦。<br>既然遇到了这个问题，我们不妨也跟着提高一下。<br>这是一个Javascript 语言题目，一个完全有效的等式，不信自己可以试一下，下面看看高人的题解：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++[[]][+[]]+[+[]]</span><br></pre></td></tr></table></figure><p>如果把这段表达式拆分开来，它相等于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">++[[]][+[]]</span><br><span class="line">+</span><br><span class="line">[+[]]</span><br></pre></td></tr></table></figure><p>在 JavaScript 里，+[] === 0 是完全正确的。 + 会把一些字符转化成数字，在这里，这个式子会变成 +”” 或 0。<br>因此，我们可以简化一下(++ 比 + 有更高的优先级)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">++[[]][<span class="number">0</span>]</span><br><span class="line">+</span><br><span class="line">[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>因为 [[]][0] 的意思是：获取 [[]] 的第一个元素，这就得出了下面的结果：</p><p>[[]][0] 返回内部数组 ([])。根据语言规范，我们说 [[]][0] === [] 是不正确的，但让我们把这个内部数组称作 A，以避免错误的写法。<br>++[[]][0] == A + 1， 因为 ++ 的意思是”加一”。<br>++[[]][0] === +(A + 1)；换句话说，你得到的永远是个数值( +1 并不一定得到的是个数值，但 ++ 一定是)。<br>同样，我们可以把这一堆代码简化的更清晰。让我们把 A 换回成 [] :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+([] + <span class="number">1</span>)</span><br><span class="line">+</span><br><span class="line">[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>在 JavaScript 里，这也是正确的：[] + 1 === “1”，因为 [] == “” (这相当于一个空的数组的内部元素连接)，于是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+([] + <span class="number">1</span>) === +(<span class="string">"” + 1)，并且 </span></span><br><span class="line"><span class="string">+("</span>” + <span class="number">1</span>) === +(<span class="string">"1"</span>)，并且 </span><br><span class="line">+(<span class="string">"1"</span>) === <span class="number">1</span></span><br></pre></td></tr></table></figure><p>让我们再次简化一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">+</span><br><span class="line">[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>同样，在 Javascript 里，这是正确的：[0] == “0”，因为这是相当于一个有一个元素的数组的内部元素的连接。 各元素会使用，分隔。 当只有一个元素时，你可以推论出这个过程的结果就是它自身的第一个元素。<br>所以，最终我们得到 (数字 + 字符串 = 字符串)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">+</span><br><span class="line"><span class="string">"0"</span></span><br><span class="line">=== <span class="string">"10"</span> <span class="comment">// 耶！</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 收藏 </category>
          
          <category> js技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> geek </tag>
            
            <tag> 技巧 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>阿根廷出线了</title>
      <link href="/2018/06/27/%E9%98%BF%E6%A0%B9%E5%BB%B7%E5%87%BA%E7%BA%BF%E4%BA%86/"/>
      <url>/2018/06/27/%E9%98%BF%E6%A0%B9%E5%BB%B7%E5%87%BA%E7%BA%BF%E4%BA%86/</url>
      <content type="html"><![CDATA[<p>之前上学的时候都没咋熬夜看过球，后面随着年龄越来越大，熬一次夜需要缓上一个礼拜，生病以后更是不敢熬夜了。世界杯开赛以来，其实就认真看了三场球，揭幕战俄罗斯vs沙特，第二天的葡萄牙对西班牙，我喜欢巴萨，自然也喜欢西班牙。这几场球赛看的时候其实挺佛系的，赶上就看赶不上就不看了。但是今天凌晨这场球，我是订的闹钟半夜起来看的。我喜欢梅西是一方面，更重要的是这场是梅西向世人证明自己的最后机会，是梅西给那些无良自媒体，无脑跟风的伪球迷以及人人痛恨的赌狗们扇耳光的最后机会。  </p><p>C罗第一场就帽子戏法，以一己之力生生从西班牙手里抢来了一分，而此时阿根廷被冰岛逼平，梅西罚丢点球，绝代双骄自然不可避免的被拿来对比。于是，各种冷嘲热讽和赌狗们的谩骂铺天盖地的涌过来，对阵克罗地亚又被血虐，梅西俨然成了一个笑话。 我是梅西：我现在慌的一批，我是梅西，我只是天生要凉。各种P图，各种段子霸占了各大媒体头条和朋友圈，赌狗们的歇斯底里我都懒得提。我看到有人说他二姨的朋友圈都在转那张P过的蒙牛广告，事实上这样的人可不在少数，有好多盲目跟风的人估计在这之前都不知道梅西是干嘛的，更别说看过他踢球了。试问你们谁有理由和资格去中伤一个陌生人呢？更何况梅西这样一个伟大的球员。</p><p>罪魁祸首就是那些无良媒体，为了流量啥都能写，其实大多数民众是不具备独立思考的能力的，他们的思想容易被一些看上去专业的业内消息所左右，曾经有人拿出来了一大堆所谓的权威数据来说明梅西只是个体系球员，离开巴萨啥都不是，跟风者必然是没看过球的，看着这一堆自己也不咋懂的数据，再对比这两场阿根廷的表现，恍然大悟，还真是这样。于是开始自以为懂球的大肆传播这种思想，毕竟这是有”权威数据“做支撑的，他们交流的群体自然是跟他同等水平的无知者，三人成虎，世界杯看球的真球迷能有多少，尤其这届充斥着赌狗的世界杯，于是这种奇怪的论调就开始在无知者中像病毒一样疯狂传播，不嘲讽两句梅西好像自己不懂球一样。我还记得一开始的时候说冰岛是牙医带着一堆律师，工人啥的在踢世界杯，简直是在造谣。但是这多吸引眼球啊，拿这个来埋汰国足得有多带劲儿啊，人们可不就是喜欢这种戏码吗。 我只能说，这些媒体真的坏！</p><p>所以，这场球梅西必须赢，不能让那些眼巴巴等着看你笑话的人如意了，我不由得想起了鲁迅笔下的中国人。<br>第一个进球来的很快，梅西还是那个梅西，大腿停球，趟一步，右脚射门，射门动作的流畅和高难度自不必说，这次突然启动前插让我从阿根廷身上看到了巴萨的影子，还有后面给伊瓜因的直塞球以及打到门柱前场任意球，真的特别欣慰，梅西踢球就应该是这样子的，迪马利亚跑动特别积极，马斯切拉诺也很拼命，比赛开始之前我就有莫名的自信，阿根廷肯定能赢，看到这支老年球队的顽强后我更加坚信他们一定能赢。然而，伴随着马斯切拉诺的送点，局势似乎变得复杂了起来，平均年龄最大的球队对阵平均年龄最小的球队，体力的巨大消耗加上被追平以后的心态变化，下半场开始的时候阿根廷全队不在状态，连续的传球失误，真的特别揪心。而且时间过的很快，如果再不追回来就真的没机会了，我想所有阿根廷球迷应该都像我一样在盼着有英雄出来，锋线上这么多人，随便站出来一个人都行啊。86分钟，罗霍站出来了，又是他，历史总是惊人的相似，此刻尼日利亚人估计杀了罗霍的心都有。 全场沸腾了，梅西跳到了罗霍背上，兴奋之情溢于言表，阿根廷人完成了自我救赎。梅西给了那些跟风的无知者们一记响亮的耳光，我当时最强烈的感受是扬眉吐气，真他妈解气。</p><p>下一场对阵法国，我还是觉得阿根廷能赢，因为他们有梅西。</p><p>最后我告诉每一个看球的观众一个浅显易懂的道理，场上每一位球员都比我们台下的看客更想赢，不懂的话看就好了，不是有解说嘛，发表那些自以为是的言论是对这些斗士们的极大不尊重。</p>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阿根廷 </tag>
            
            <tag> 梅西 </tag>
            
            <tag> 世界杯 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我爹今年六十六，第一次过生日</title>
      <link href="/2018/06/20/%E6%88%91%E7%88%B966%EF%BC%8C%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%BF%87%E7%94%9F%E6%97%A5/"/>
      <url>/2018/06/20/%E6%88%91%E7%88%B966%EF%BC%8C%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%BF%87%E7%94%9F%E6%97%A5/</url>
      <content type="html"><![CDATA[<p>最近老赵的电话有点勤，刚好赶上端午节放假，抓紧回家看看吧。 我回家一般都不会事先通知，并不是想给他个惊喜，而是怕他知道了以后盼的着急。</p><p>假期前一天接到我哥的电话，说是他们厂里最近停产了，他在家休息，问我端午节回家不，刚好明天老爹过生日。 </p><p>我一愣，老赵过生日。</p><p>我哥跟我嫂子帮他订了个蛋糕，我们全家人在外面吃了个饭，老赵生平第一次吹了生日蜡烛，吃了一碗长寿面。</p><p>算起来，老赵今年六十六了，在我将近三十年的记忆里他没有过过生日，也没有生日的概念。我记得在高中的时候有一次我问到这个事情，我问他的生日是什么时候，他说：” 我也不知道，可能是个六月初几吧 “。他自己都不知道自己的生日是哪天，我奶奶应该知道他的生日，但是奶奶没了都多少年了，当然我大姑或许也会记得这个弟弟的生日吧。想想真的令人唏嘘，老赵是个没有生日的人。 我哥这次也只是按照他身份证上的出生日期来过的。我突然想到，或许我应该去找大姑问问清楚老赵的真实生日，不然过不了几年这世上可就真的没有知道他的生日了。</p><p>仔细想想，从母亲病了以后，这个男人就没有再为自己活过一天。</p><p>我哥跟我嫂子在亲戚的那个群里发了一堆照片，祝老赵父亲节快乐。我还纳闷呢，结果发现第二天还真是父亲节。当然老赵不知道什么是微信群，更不知道什么父亲节。</p><p>人们常说救命之恩无以为报，养育之恩又何尝不是呢。他老去的速度远远超过了我挣钱的速度，我不得不面对他精神状态的每况日下。老赵一直不是很同意我离开现在的单位，他怕我离开以后就找不到工作了，因为在我们老家有一份稳定的工作真的很不容易。没有工作是可怕的，就像现在的他，出了一辈子苦力，但是现在的年龄不允许他继续这么干了，现在他没次试图想要出去打点零工的时候都被我阻止了，其实我也很矛盾，我不知道这样算不算是为他好，我的出发点是不想他太累，怕累坏身体，但是我也深知他赋闲在家不能挣钱的煎熬，不过几次医院的经历告诉我还是保养身体为重。老赵的养育之恩我注定报答不完了，我能做的就是尽量让他改变自己的思想，能过的尽量舒心一点，这样我心里的亏欠也能相对少一点。话又说回来，如何让他过的舒心呢，很简单，让他知道我过的很好，显然当下的状况并不足以给他证明我过的有多好，所以生活一直在逼我往前走。</p><p>他一直希望我考公务员，农村人对铁饭碗的痴迷让人匪夷所思，老人们互相拉起家常的时候，在外年薪二三十万远不如一个老家月入两千五的县政府办事员来的硬气，老赵也是一个普普通通的农村老人，他一直这么认为，每月有稳定的收入才是最踏实的，公务员们退休之后还有退休工资，这样就算赋闲在家也能保证月月有进账。而这种思想也已经开始慢慢渗透到了老家下一代脑海里，其实这也是我不愿意继续留在老家的原因，或许这只是不同的生活方式，说不上谁对谁错，但是我知道自己内心喜欢哪一种就好。</p><p>曾经的他是家里的顶梁柱，生活的窘迫，家庭的变故他都能应付自如。现如今他老了，不再像曾经那样胸有成竹，身体的衰老其实并不可怕，让一个男人真正难受的是那种力不从心和不再被需要的感觉。他曾经的骄傲在岁月面前变得一文不值。当他变得不再强势，当他开始听取我的意见，当他明明认为自己的观点正确却不再坚持的时候，我并没有感到一点点成就，更多的是那种痛彻心扉的酸楚。祈求时间过得慢一点，再慢一点。。</p><p>不过好在老赵不再是一个没有生日的人了。</p>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 父亲 </tag>
            
            <tag> 感恩 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我和blog</title>
      <link href="/2018/06/09/%E5%85%B3%E4%BA%8Eblog/"/>
      <url>/2018/06/09/%E5%85%B3%E4%BA%8Eblog/</url>
      <content type="html"><![CDATA[<p>我是个资深的前端API调用工作者，同时又是个重度<a href="https://www.zhihu.com/people/troubledot" target="_blank" rel="noopener">知乎</a>只读用户，所以每天我会看各种各样的文章，有技术文档，也有扯淡消遣的，往往后者居多。看的多了就想自己也写一点东西，美其名曰希望记录一下自己的学习和生活。</p><p>2015年开始正式从事程序员的工作，没多久就有了想写点东西的想法，其实也是当时看到我<a href="http://www.littlemusic.tv/" target="_blank" rel="noopener">同事兼师傅的个站</a>， 我就想自己也有这样一个站。适逢刚入职工作量还没有那么大，就用自己仅有的一点html和css知识，做了几个简单的静态页面，而这几个页面后面因为知识的匮乏和热情的缺失就搁浅了。这是最开始筹备，其实当时都没想过是做一个blog。</p><p>在一个性质偏国企的外包公司工作，如果你没有很强学习欲望和动力，日子荒废起来快得吓人，一转眼就到了16年年中了，我打算重新拾起来那个搁浅了的计划，注册了域名，买了个阿里云的web弹性托管，我当时还只是个入门级的切图仔，不懂主机，不懂域名，更不懂数据库，有问题全都是靠百度和问别人，感谢百度也感谢耐心的同事。 一开始用的是wordpress ，第一次访问到自己网站的时候心里还是有一点兴奋的。但是因为空间有限，我又想存挺多图，还是同事教的，七牛给每个账户10G的空间，可以把图片放到那里，这里又折腾了一个月吧，把这个也弄好了。那段时间热情还是很高的，晚上会看看犀牛书，抄点笔记到blog上，开始的计划是每周更新，记录下自己的学习进程。好景不长，可能是一次加班，可能是突然犯懒，计划制定的容易，打破的更加容易。于是这次又这样搁置了。</p><p>我看了一下最后一篇是在2017年6月1号写的，那会儿庄才结婚，今天他都生儿子了。突然发现，整整一年了。</p><p>再一次开始做blog是在今年年初吧，部门开始将提了好久的前后端分离提上了日程，前端我们用的vuejs。磕磕巴巴边学边做了一个项目以后，算是有了点基本的认识，但是在项目中我这边只负责前端这一块，非科班出身的短板一览无余，后端知识匮乏，缺少编程思维。提升不足，需要上手，刚好我想自己做我的blog，前后端都由我来做，然后又开始了折腾。 前端用vue，后端用的node的<a href="http://expressjs.com/" target="_blank" rel="noopener">express</a>框架，数据库用的mysql。花了一点功夫，调通了前后台，blog的增删改查都实现了。但是我想把他做好，每一行代码，每一格缩进，每一个函数命名，我都要做好，我想让自己做的东西看上去像是一个程序员做的东西，显然这对我来讲不是一个小工程。我花了不少时间去看express，我看了一段时间的sql语句，当然我还需要系统的学习下es6，我也需要深入研究一下vuex，可能后面还有好多我现在都说不上来的东西。我要坚持做完这个东西，因为这二十几年来我能坚持下来的事情实在少的可怜。</p><p>来来回回绕了这么久，我好像忘了自己最初想要干嘛了，我不是想要自己写点东西吗？而且随着年龄的增长，见过的人和事越来越多，有时候真的会特别想写点自己的感悟。而我那个纯手工打造的blog还需要一段时间，而且我更看重那个blog搭建的过程。但是我又想要记录一些事情，于是就有了现在这个基于github和hexo的blog的出现。我会在这里记录以后的学习和生活，等那个好了以后两边内容会保持同步。</p>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>My New Post</title>
      <link href="/2018/06/08/My-New-Post/"/>
      <url>/2018/06/08/My-New-Post/</url>
      <content type="html"><![CDATA[<h1 id="English-blog"><a href="#English-blog" class="headerlink" title="English blog"></a>English blog</h1><p>This is my first hexo blog .<br>I want to write it in english , it must be very diffcult begin do it .<br>Just do it .</p><p>Beacuse I heard a word : if what you did is easy , it’s unuseful .</p><p><img src="http://pa00if26f.bkt.clouddn.com/image/jpgv2-763c35eb9cfe47731ee6a86838dc1988_r.jpg" alt="image description"></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/06/08/hello-world/"/>
      <url>/2018/06/08/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
