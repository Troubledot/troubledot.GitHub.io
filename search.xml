<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>leetCode3——回文数</title>
      <link href="/2019/07/22/leetCode3%E2%80%94%E2%80%94%E5%9B%9E%E6%96%87%E6%95%B0/"/>
      <url>/2019/07/22/leetCode3%E2%80%94%E2%80%94%E5%9B%9E%E6%96%87%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p>示例 1:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">121</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">-121</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。<br>示例 3:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">10</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>解释: 从右向左读, 为 01 。因此它不是一个回文数。</p><p>我自己的思路，数字转成字符串，长度为len，当该数为偶数位数时，从左往右看前len/2位和从右往左看后len/2位相同，如1221前两位位‘12’，后两位也是‘12’；如果位数为奇数时，前(len+1)/2位和后(len+1)/2位相同，如12321，前三位位‘123’，后三位也是‘123’。</p><p>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; x</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> str = <span class="built_in">String</span>(x)</span><br><span class="line">    <span class="keyword">const</span> len = str.length</span><br><span class="line">    <span class="keyword">const</span> times = len % <span class="number">2</span> == <span class="number">0</span> ? len/<span class="number">2</span> : (len+<span class="number">1</span>)/<span class="number">2</span></span><br><span class="line">    <span class="keyword">let</span> head = <span class="string">''</span></span><br><span class="line">    <span class="keyword">let</span> tail = <span class="string">''</span></span><br><span class="line">    <span class="keyword">let</span> res</span><br><span class="line">    <span class="built_in">console</span>.log(len, times)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; times; index++) &#123;</span><br><span class="line">      head += str[index] </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = len<span class="number">-1</span>; index &gt;= len - times; index--) &#123;</span><br><span class="line">      tail += str[index]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(head, tail)</span><br><span class="line">    res = head === tail</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="http://res.troubledot.cn/palindrome.png" alt="可怜的5%"></p><p>如果不转字符串还有一种办法，昨天刚做过的整数反转，负数肯定不是回文数，正数反转一下看是否和原来的数字相同就知道是否是回文数了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; x</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = x;  <span class="comment">//复制一个x</span></span><br><span class="line">  <span class="keyword">let</span> z = <span class="number">0</span>;  <span class="comment">//反转需要累加的基数</span></span><br><span class="line">  <span class="keyword">let</span> res</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    res = <span class="literal">false</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">      <span class="keyword">const</span> digit = y % <span class="number">10</span></span><br><span class="line">      y = <span class="built_in">Math</span>.floor(y/<span class="number">10</span>)</span><br><span class="line">      z = z * <span class="number">10</span> + digit</span><br><span class="line">    &#125;</span><br><span class="line">    res = z === x</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果比转字符串好多了</p><p><img src="http://res.troubledot.cn/palindrome1.png" alt="反转比较"></p><p>最后看看下别人咋写的吧。。</p><p>同样是转字符串有的人这么写，不是多厉害的算法，这个写法让人眼前一亮。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; x</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x == x.toString().split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个没看明白，应该很厉害</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> w = x,</span><br><span class="line">      y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(w &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> z = w % <span class="number">10</span>;</span><br><span class="line">      y *= <span class="number">10</span>;</span><br><span class="line">      y += z;</span><br><span class="line">      w -= z;</span><br><span class="line">      w /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x === y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个配合讲解能看明白，反转一半就能知道该数是不是回文数了，巧妙的地方在于while的条件，如何知道已经反转了一半了，其实所谓的*10和/10说白了就是多一位和少一位，在while中，x每次少一位，要反转的数每次在多一位，当要反转的数大于x的时候，就是要反转的数位数要大于原始数了，此时说明反转的数已经超过一半了，所以while条件就是原始数大于反转数，这样就保证了反转不会超过一半。。太巧妙了这里。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; x</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span> ||(x % <span class="number">10</span> === <span class="number">0</span> &amp;&amp; x !== <span class="number">0</span>))&#123;</span><br><span class="line">    res = <span class="literal">false</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>( x &gt; y)&#123;</span><br><span class="line">      y = y * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">      x = <span class="built_in">Math</span>.floor(x / <span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    res = x == y || x == y / <span class="number">10</span> </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我感觉或许有些东西需要背下来的，包括前面的反转，和今天这个神奇的算法。</p><p>以上，判断回文数，共勉！</p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
          <category> leetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetCode </tag>
            
            <tag> easy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetCode2——整数反转</title>
      <link href="/2019/07/21/leetCode2%E2%80%94%E2%80%94%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
      <url>/2019/07/21/leetCode2%E2%80%94%E2%80%94%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
      <content type="html"><![CDATA[<p>题目</p><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><p>示例 1:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">123</span></span><br><span class="line">输出: <span class="number">321</span></span><br></pre></td></tr></table></figure><p> 示例 2:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">-123</span></span><br><span class="line">输出: <span class="number">-321</span></span><br><span class="line">示例 <span class="number">3</span>:</span><br></pre></td></tr></table></figure><p>输入: 120<br>输出: 21<br>注意:</p><p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p><p>反转首先想到的是数组的reverse方法，数字转字符串再转成数组，reverse以后再转回来，当然最后return的时候需要判断下是否溢出了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; x</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverse = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res</span><br><span class="line">  <span class="keyword">let</span> y = <span class="built_in">Math</span>.abs(x)</span><br><span class="line">  <span class="keyword">const</span> str = <span class="built_in">String</span>(y)</span><br><span class="line">  <span class="keyword">const</span> arr = str.split(<span class="string">''</span>)</span><br><span class="line">  <span class="keyword">const</span> newarr = arr.reverse()</span><br><span class="line">  <span class="keyword">let</span> val = newarr.join(<span class="string">''</span>)*<span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span>(val &lt; <span class="number">2</span>**<span class="number">31</span>)&#123;</span><br><span class="line">    res = x&gt;<span class="number">0</span>?val:-val</span><br><span class="line">  &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是提交结果：</p><p><img src="http://res.troubledot.cn/reverse.png" alt="数组reverse提交结果"></p><p>通过了，但是我感觉这道题考察的显然不是数组的reverse方法，再想想别的办法。</p><p>如果不使用reverse的话，我们其实可以把字符串从后往前遍历push进一个数组再转回来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; x</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverse = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> y = <span class="built_in">Math</span>.abs(x)</span><br><span class="line">  <span class="keyword">const</span> str = <span class="built_in">String</span>(y)</span><br><span class="line">  <span class="keyword">let</span> arr = []</span><br><span class="line">  <span class="keyword">let</span> res</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = str.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">    arr.push(str[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> val = arr.join(<span class="string">''</span>)*<span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span>(val &lt; <span class="number">2</span>**<span class="number">31</span>)&#123;</span><br><span class="line">    res = x &gt; <span class="number">0</span> ? val : -val</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看下提交结果:</p><p><img src="http://res.troubledot.cn/reverse1.png" alt="字符串倒序遍历提交结果"></p><p>内存没咋变，但是执行速度提高了点，超过92.47%了都。<br>这是我现有知识能想到的两种方法了，接下来我开始看评论里的大神们怎么写的。<br>看了才知道，原来整数的倒序是有算法的，而这道题真正要考察的也正是那个倒序的算法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; x</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverse = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="built_in">Math</span>.abs(x)</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> res</span><br><span class="line">  <span class="keyword">while</span> (y) &#123;</span><br><span class="line">    <span class="keyword">const</span> digit = y%<span class="number">10</span></span><br><span class="line">    y = <span class="built_in">Math</span>.floor(y/<span class="number">10</span>)</span><br><span class="line">    result = result * <span class="number">10</span> + digit</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (result &lt; <span class="number">2</span>**<span class="number">31</span>)&#123;</span><br><span class="line">    res = x &gt; <span class="number">0</span> ? result : -result</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>果然，看下结果吧</p><p><img src="http://res.troubledot.cn/reverse2.png" alt="倒序算法"></p><p>倒序算法，假设要需要倒序的数为想x：</p><ol><li>把x除以10取余，也就是拿到其个位数digit，1234的话digit为4；</li><li>将x除以10取整，也就是拿到除个位数外的其他位数赋值给他自身，此时1234变成了123；</li><li>结果从0开始加，<em>result = result </em> 10 + digit*也就是 0x10+4 = 4；</li><li>x大于0就继续执行上面的操作，digit = 123%10 = 3，x再除以10取整为12，此时的result为 4x10+3=43；x为12仍然需要继续执行，12%10 = 2，12/10取整为1，result = 43x10+2 = 432；此时x=1还需要执行，x%10商0余1,1/10取整结果为0，result = 432x10+1 = 4321；x=0了，while执行结束了。</li></ol><p>以上 leetcode 整数反转， 共勉！</p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
          <category> leetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetCode </tag>
            
            <tag> easy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetCode1——两数之和</title>
      <link href="/2019/07/20/leetCode1%E2%80%94%E2%80%94%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2019/07/20/leetCode1%E2%80%94%E2%80%94%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      <content type="html"><![CDATA[<p>我打算在后面持续更新下leetCode，希望能再坚持成功一件事情，这是第一题，直接开始。</p><p>题目：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p>示例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span></span><br><span class="line">所以返回 [<span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>一个毫无算法基础的非科班程序员，看到这个题目直接硬刚，两层循环。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; target</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> nums)&#123;</span><br><span class="line">    <span class="keyword">for</span> (j <span class="keyword">in</span> nums)&#123;</span><br><span class="line">      <span class="keyword">if</span> (i + j == target &amp;&amp; i !== j)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Array</span>(i, j)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可能一开始刷leetCode会有点吃力，会有考虑不周的地方，但是也还算有思路，比如我第一次做的时候就没想到要排除i和j相等的情况。</p><p>最后提交的时候执行用时：5808 ms，好像超过了5%的人，就是菜鸟的意思。</p><p>我后面试过递归，也没能行，想不明白了，那就翻答案吧，然后就了解到了一个新的概念——哈希表。</p><p>一个完全陌生的概念，加上官方答案里面是java代码，而且这道题貌似考察的就是哈希表，我上网查了下关于哈希表的概念，大多数都比较晦涩，直到看到了<a href="https://www.zhihu.com/question/330112288/answer/744362539" target="_blank" rel="noopener">这篇文章</a>，文中举的停车场的例子真的生动至极，让人茅塞顿开。</p><p>具体什么是哈希表呢？如果我能把这个东西说清楚那么应该就算是理解了吧。</p><p>哈希表也叫散列表，在维基百科里面是这么解释的：</p><blockquote><p>散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。</p></blockquote><p>这里有几个关键字：<strong>键（key）</strong>，<strong>散列函数</strong>。</p><p>想象一下这样一种场景，有几个数字，2312、1333、1236、2580、9362、9457。</p><p>我们需要把这几个数字存起来，并且我需要某一个数字的时候能快速找到，有什么好的办法？</p><p>第一种办法，直接存数组里面：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">2312</span>,<span class="number">1333</span>,<span class="number">1236</span>,<span class="number">2580</span>,<span class="number">9362</span>,<span class="number">9457</span>]</span><br></pre></td></tr></table></figure><p>如果我需要9362，那么从a[0]开始一个个往后找，找到9362为止，这里会涉及到一个复杂度的问题，不细究了，总之我们能想象到这显然不是一个好办法，如果数字足够多，而你要找的又在最后那就很慢了。再快一点的找法，把a从小到大排序，从中间开始找，9362大于中间的数，那么我们直接往后找，这样能够快一点，但是显然还是不够快。</p><p>第二种办法，像下面这样一个表我们把这几个数按照一定的规则插入表中，并假定这个规则为关键字除以10的余数作为地址。</p><table><thead><tr><th style="text-align:center">地址</th><th style="text-align:center">空表</th><th style="text-align:center">插入2312</th><th style="text-align:center">插入1333</th><th style="text-align:center">插入1236</th><th style="text-align:center">插入2580</th><th style="text-align:center">插入9362</th><th style="text-align:center">插入9457</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">2580</td><td style="text-align:center">2580</td><td style="text-align:center">2580</td><td></td></tr><tr><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">2</td><td style="text-align:center"></td><td style="text-align:center">2312</td><td style="text-align:center">2312</td><td style="text-align:center">2312</td><td style="text-align:center">2312</td><td style="text-align:center">2312</td><td style="text-align:center">2312</td><td></td></tr><tr><td style="text-align:center">3</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">1333</td><td style="text-align:center">1333</td><td style="text-align:center">1333</td><td style="text-align:center">1333</td><td style="text-align:center">1333</td><td></td></tr><tr><td style="text-align:center">4</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"><strong>9362</strong></td><td style="text-align:center"><strong>9362</strong></td><td></td></tr><tr><td style="text-align:center">5</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">6</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">1236</td><td style="text-align:center">1236</td><td style="text-align:center">1236</td><td style="text-align:center">1236</td><td></td></tr><tr><td style="text-align:center">7</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">9457</td><td></td></tr><tr><td style="text-align:center">8</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">9</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr></tbody></table><p>插入数据的过程中，2312和9362除以10取余都是2，所以在插入9362的时候，在2号位置上已经有了2312，这时候就出现了哈希中的<strong>冲突</strong>，解决冲突的办法很多，我们用了最简单的往后顺延存到3号位置上，发现3号位置也被占用了，那就继续往后存到4号上了。</p><p>我们来看下这样存入数据以后查的时候真的会很快吗？<br>比如说我要查2312，用根据哈希函数除以10取余为2，我们知道应该去2号位置找，直接hash[2],就是2312。<br>再查找一个9362，同样我们根据哈希函数去2号位置找，发现不是9362，确定哈希函数没有问题的话那么知道这肯定是冲突了，这里我们知道冲突解决的规则是往后顺延，直接找3号位置，发现也不是继续顺延hash[4]是9362了。<br>发现这样找起来的确比较省事，如果没有发生冲突的话，一次就找到了。关于冲突的问题又会衍生出来好多内容，以后如果需要再细究。</p><p>这里我们可以看到最后的结果好像也是一个数组，与其说数组其实更像是一个对象，毕竟数组给我们的印象大都是连续的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">obj = &#123;</span><br><span class="line">  <span class="string">'0'</span>: <span class="string">'2580'</span>,</span><br><span class="line">  <span class="string">'1'</span>: <span class="string">''</span>,</span><br><span class="line">  <span class="string">'2'</span>: <span class="string">'2312'</span>,</span><br><span class="line">  <span class="string">'3'</span>: <span class="string">'1333'</span>,</span><br><span class="line">  <span class="string">'4'</span>: <span class="string">'9362'</span>,</span><br><span class="line">  <span class="string">'5'</span>: <span class="string">''</span>,</span><br><span class="line">  <span class="string">'6'</span>: <span class="string">'1236'</span>,</span><br><span class="line">  <span class="string">'7'</span>: <span class="string">'9457'</span>,</span><br><span class="line">  <span class="string">'8'</span>: <span class="string">''</span>,</span><br><span class="line">  <span class="string">'9'</span>: <span class="string">''</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其实，js中的对象底层就是哈希表。</p></blockquote><p>不难看出来所谓“哈希表”，其实就是一个对象，而这个对象的键值（key）长得跟数组的索引（index）一样。</p><p>大致了解了哈希，我们再看这个题目，大致思路：</p><ol><li>把这些数字(num)挨个往哈希表中插入；</li><li>插入的时候判断一下目标数字(target - num)是否存在于哈希表中，存在就返回索引不存在就插入哈希表中；</li></ol><p>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; target</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> hash = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>( target-nums[i] <span class="keyword">in</span> hash)&#123;</span><br><span class="line">      <span class="keyword">return</span> [hash[target-nums[i]], i]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      hash[nums[i]] = i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们在插入哈希表的时候用 <em>hash[nums[i]] = i</em>，这样得到的哈希表中值是数组索引，而键是数组中的值。<br>拿测试的例子就是这样子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line">nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>]</span><br><span class="line"><span class="comment">// 哈希</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">'2'</span>: <span class="string">'0'</span>,</span><br><span class="line">  <span class="string">'7'</span>: <span class="string">'1'</span>,</span><br><span class="line">  <span class="string">'11'</span>: <span class="string">'2'</span>,</span><br><span class="line">  <span class="string">'15'</span>: <span class="string">'3'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的好处就在于我们可以用in运算符去判断目标值是否在哈希表中：<em>target-nums[i] in hash</em></p><p>最后也能以目标值作为键来取到索引 <em>hash[target-nums[i]]</em></p><p>这下好了，超过了99.57%。</p><p><img src="http://res.troubledot.cn/twosum.png" alt="99.57%"></p><p>再去看看别人的写法，真的是大开眼界，强烈建议去刷国外的leetcode，那上面讨论更多，有意思的答案更多。</p><p>比如可以把里面的判断写一个方法用some来执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; target</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> hash = &#123;&#125;</span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  nums.some(<span class="function">(<span class="params">num, index</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> k = target - num</span><br><span class="line">    <span class="keyword">if</span>(k <span class="keyword">in</span> hash)&#123;</span><br><span class="line">      res = [hash[k], index]</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      hash[num] = index</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里注意最后需要返回值，我自己照着写的时候把返回值写在some里面的方法中，最后整个函数没有返回值，一直是undefined。</p><p>还有好多有意思的代码就不意义罗列了，看别人的代码，真的长姿势！！</p><p>第一道leetCode，写的有点啰嗦，后面慢慢简略点。</p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
          <category> leetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetCode </tag>
            
            <tag> easy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>手动实现一个Symbol</title>
      <link href="/2019/07/18/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AASymbol/"/>
      <url>/2019/07/18/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AASymbol/</url>
      <content type="html"><![CDATA[<p>ES6中新引入了一种原始数据类型symbol，表示一个独一无二的值。我们可以通过了解它的特性，尝试去手动实现一个symbol。</p><h3 id="Symbol特性"><a href="#Symbol特性" class="headerlink" title="Symbol特性"></a>Symbol特性</h3><h4 id="1、Symbol通过Symbol-函数生成，使用typeof操作符返回结果是”symbol”"><a href="#1、Symbol通过Symbol-函数生成，使用typeof操作符返回结果是”symbol”" class="headerlink" title="1、Symbol通过Symbol()函数生成，使用typeof操作符返回结果是”symbol”"></a>1、Symbol通过Symbol()函数生成，使用typeof操作符返回结果是”symbol”</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">Symbol</span>()</span><br><span class="line">consle.log(<span class="keyword">typeof</span> s)  <span class="comment">//symbol</span></span><br></pre></td></tr></table></figure><h4 id="2、Symbol函数前不能使用new命令，否则会报错"><a href="#2、Symbol函数前不能使用new命令，否则会报错" class="headerlink" title="2、Symbol函数前不能使用new命令，否则会报错"></a>2、Symbol函数前不能使用new命令，否则会报错</h4><p>这是因为生成的Symbol是一个原始类型的值，不是一个对象</p><h4 id="3、instanceof结果为false"><a href="#3、instanceof结果为false" class="headerlink" title="3、instanceof结果为false"></a>3、instanceof结果为false</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="built_in">console</span>.log(s <span class="keyword">instanceof</span> <span class="built_in">Symbol</span>)  <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h4 id="4、Symbol接受一个字符串作为参数来表示对其的描述，用以在打印或者转为字符串的时候便与区分"><a href="#4、Symbol接受一个字符串作为参数来表示对其的描述，用以在打印或者转为字符串的时候便与区分" class="headerlink" title="4、Symbol接受一个字符串作为参数来表示对其的描述，用以在打印或者转为字符串的时候便与区分"></a>4、Symbol接受一个字符串作为参数来表示对其的描述，用以在打印或者转为字符串的时候便与区分</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'s1'</span>)</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'s2'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1))  <span class="comment">// Symbol(s1)</span></span><br><span class="line"><span class="built_in">console</span>.log(s2)). <span class="comment">// Symbol(s2)</span></span><br></pre></td></tr></table></figure><h4 id="5、Symbol的参数如果是一个对象，就会调用该对象的toString方法，将其转换成字符串，然后生成Symbol值"><a href="#5、Symbol的参数如果是一个对象，就会调用该对象的toString方法，将其转换成字符串，然后生成Symbol值" class="headerlink" title="5、Symbol的参数如果是一个对象，就会调用该对象的toString方法，将其转换成字符串，然后生成Symbol值"></a>5、Symbol的参数如果是一个对象，就会调用该对象的toString方法，将其转换成字符串，然后生成Symbol值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'abc'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> s1 = <span class="built_in">Symbol</span>(obj)</span><br><span class="line"><span class="built_in">console</span>.log(s1)  <span class="comment">//'abc'</span></span><br></pre></td></tr></table></figure><h4 id="6、Symbol的参数只是对当前值的一个描述，并不代表Symbol的值，也就是说就算参数相同，这两个Symbol也是不相等的"><a href="#6、Symbol的参数只是对当前值的一个描述，并不代表Symbol的值，也就是说就算参数相同，这两个Symbol也是不相等的" class="headerlink" title="6、Symbol的参数只是对当前值的一个描述，并不代表Symbol的值，也就是说就算参数相同，这两个Symbol也是不相等的"></a>6、Symbol的参数只是对当前值的一个描述，并不代表Symbol的值，也就是说就算参数相同，这两个Symbol也是不相等的</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有参数的情况</span></span><br><span class="line"><span class="built_in">Symbol</span>() == <span class="built_in">Symbol</span>() <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 有参数的情况</span></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">'123'</span>) == <span class="built_in">Symbol</span>(<span class="string">'123'</span>)  <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h4 id="7、Symbol不能与其他类型的值进行运算否则会报错"><a href="#7、Symbol不能与其他类型的值进行运算否则会报错" class="headerlink" title="7、Symbol不能与其他类型的值进行运算否则会报错"></a>7、Symbol不能与其他类型的值进行运算否则会报错</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mysymbol = <span class="built_in">Symbol</span>(<span class="string">'123'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'my symbol is'</span> + mysymbol) <span class="comment">//TypeError: Cannot convert a Symbol value to a string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> + mysymbol) <span class="comment">//Cannot convert a Symbol value to a number</span></span><br></pre></td></tr></table></figure><h4 id="8、Symbol可以显式的转换为字符串"><a href="#8、Symbol可以显式的转换为字符串" class="headerlink" title="8、Symbol可以显式的转换为字符串"></a>8、Symbol可以显式的转换为字符串</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> symbol = <span class="built_in">Symbol</span>(<span class="string">'mysymbol'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(toString(symbol))  <span class="comment">//'Symbol('mysymbol')'</span></span><br><span class="line"><span class="built_in">console</span>.log(symbol.toString()) <span class="comment">// 'Symbol(mysymbol)'</span></span><br></pre></td></tr></table></figure><h4 id="9、Symbol可以作为对象的属性值，保证属性不会冲突"><a href="#9、Symbol可以作为对象的属性值，保证属性不会冲突" class="headerlink" title="9、Symbol可以作为对象的属性值，保证属性不会冲突"></a>9、Symbol可以作为对象的属性值，保证属性不会冲突</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sys = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">obj[sys] = <span class="string">'Troubledot'</span></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line">obj&#123;</span><br><span class="line">  [sys]: <span class="string">'Troubledot'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第三种写法</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, symbol ,&#123;<span class="attr">value</span>: <span class="string">'Troubledot'</span>&#125;);</span><br></pre></td></tr></table></figure><h4 id="10、Symbol作为属性名，该属性不会出现在for…in，for…of中，也不会被Object-keys-、Object-getOwnPropertyNamens、JSON-stringify-返回。但是也不是私有属性，有一个Object-getOwnpropertySymbols方法，可以获取指定对象的所有Symbol属性名"><a href="#10、Symbol作为属性名，该属性不会出现在for…in，for…of中，也不会被Object-keys-、Object-getOwnPropertyNamens、JSON-stringify-返回。但是也不是私有属性，有一个Object-getOwnpropertySymbols方法，可以获取指定对象的所有Symbol属性名" class="headerlink" title="10、Symbol作为属性名，该属性不会出现在for…in，for…of中，也不会被Object.keys()、Object.getOwnPropertyNamens、JSON.stringify()返回。但是也不是私有属性，有一个Object.getOwnpropertySymbols方法，可以获取指定对象的所有Symbol属性名"></a>10、Symbol作为属性名，该属性不会出现在for…in，for…of中，也不会被Object.keys()、Object.getOwnPropertyNamens、JSON.stringify()返回。但是也不是私有属性，有一个Object.getOwnpropertySymbols方法，可以获取指定对象的所有Symbol属性名</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>(<span class="string">'a'</span>)</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Symbol</span>(<span class="string">'b'</span>)</span><br><span class="line">obj[a] = <span class="string">'Hello'</span></span><br><span class="line">obj[b] = <span class="string">'World'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> objectSymbol = <span class="built_in">Object</span>.getOwnPropertySymbols(obj)</span><br><span class="line"><span class="built_in">console</span>.log(objectSymbol) <span class="comment">//[Symbol('a'), Symbol('b')]</span></span><br></pre></td></tr></table></figure><h3 id="11、如果我们希望使用同一个Symbol值，可以用for，它接受一个字符串作为参数，然后搜索有没有以这个字符串作为key值得Symbol，有的话就返回，否则就新建并返回以该字符串为名称的Symbol值"><a href="#11、如果我们希望使用同一个Symbol值，可以用for，它接受一个字符串作为参数，然后搜索有没有以这个字符串作为key值得Symbol，有的话就返回，否则就新建并返回以该字符串为名称的Symbol值" class="headerlink" title="11、如果我们希望使用同一个Symbol值，可以用for，它接受一个字符串作为参数，然后搜索有没有以这个字符串作为key值得Symbol，有的话就返回，否则就新建并返回以该字符串为名称的Symbol值"></a>11、如果我们希望使用同一个Symbol值，可以用for，它接受一个字符串作为参数，然后搜索有没有以这个字符串作为key值得Symbol，有的话就返回，否则就新建并返回以该字符串为名称的Symbol值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>)</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>)</span><br><span class="line">a == b <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="12、Symbol的keyfor方法返回已登记的Symbol类型的key值"><a href="#12、Symbol的keyfor方法返回已登记的Symbol类型的key值" class="headerlink" title="12、Symbol的keyfor方法返回已登记的Symbol类型的key值"></a>12、Symbol的keyfor方法返回已登记的Symbol类型的key值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1.keyfor())  <span class="comment">//'foo'</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s2.keyfor())  <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>了解了Symbol的特性，实现一个Symbol就是去实现这些特性。<br>先看下再规范中调用Symbol的时候都做了哪些工作：</p><ol><li>If NewTarget is not undefined, throw a TypeError exception.</li><li>If description is undefined, var descString be undefined.</li><li>Else, var descString be ToString(description).</li><li>ReturnIfAbrupt(descString).</li><li>ReturnIfAbrupt(descString).</li></ol><p>翻译下 ：</p><ol><li>如果使用 new ，就报错</li><li>如果 description 是 undefined，让 descString 为 undefined</li><li>否则 让 descString 为 ToString(description)</li><li>如果报错，就返回</li><li>返回一个新的唯一的 Symbol 值，它的内部属性 [[Description]] 值为 descString</li></ol><p>按照Symbol的特性一条条往下写。</p><p>1、使用typeof的时候返回Symbol，无法修改typeof的结果。放弃！</p><p>2、使用new关键字的时候报错 可以实现</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> root = <span class="keyword">this</span></span><br><span class="line"><span class="keyword">var</span> Generatesymbol = <span class="function"><span class="keyword">function</span> <span class="title">Symbol</span>(<span class="params">description</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Generatesymbol) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Symbol is not a constructor'</span>)</span><br><span class="line">  <span class="keyword">return</span> symbol</span><br><span class="line">&#125;</span><br><span class="line">root.Generatesymbol = Generatesymbol</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>3、instanceof结果为false，不是由new生成的，所以这条不用专门去实现。</p><p>4、Symbol接受一个字符串作为参数来表示对其的描述，用以在打印或者转为字符串的时候便与区分，因为我们在模拟的时候返回的是一个对象，实现不了。</p><p>5、如果Symbol的参数是一个对象，调用toString方法转换成字符串在返回Symbol，如果参数是undefined直接返回undefined，否则对参数执行toString方法再返回，用一个三元表达式就好</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> descString = description === <span class="literal">undefined</span> ? <span class="literal">undefined</span> : description.toString()</span><br></pre></td></tr></table></figure><p>6、因为我们模拟的symbol是一个对象，每次都要创建一个新对象，引用不同，再加上后面会增加了一个<strong>Name</strong>属性，每次都不同，所以即使参数相同返回值也不同</p><p>7、Symbol不能参与运算，否则会报错。</p><p>  这里我们以‘+’运算为例，在做‘+’运算的时候，先执行了valueOf方法进行了隐式类型转换再进行运算的，所以我们可以在对Symbol执行valueOf()的时候抛出个错误就行。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> symbol = <span class="built_in">Object</span>.create(&#123;</span><br><span class="line">  valueOf:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Cannot convert a Symbol value'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>  但是这样的结果就是symbol无法显式的调用valueOf方法，因为一调用就会报错，看下实际上不是这样的</p><p>  <img src="http://res.troubledot.cn/symbolvalueof.png" alt="symbolvalueof"></p><p>  我们能看到symbol执行valueOf方法的时候并没有报错，而是返回了这个symbol值，也就是它本身。所以我们为了使其不能参与运算就改变了它的valueOf方法显然是不合理的，在能否参与运算和它显式调用valueOf方法之中显然后者要更加重要，所以我们可以舍弃它不能参与运算的特性而来实现它的valueOf方法。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> symbol = <span class="built_in">Object</span>.create(&#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>8、我们模拟的symbol最后返回的是一个对象，对象显式调用toString，我们在控制台里打印下发现长这样[object,object]，显然不是我们想要的结果，所以我们可以给该对象绑定一个toString方法，P拼出我们想要的值’Generatesymbol(‘+<strong>Description</strong>+’)’,返回即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> symbol = <span class="built_in">Object</span>.create(&#123;</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Generatesymbol('</span>+__Description__+<span class="string">')'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>9、symbol作为对象的属性可以保证不会出现重名属性，要作为对象的属性，需要先调用toString方法进行隐式类型转换，而在第8条中我们给它绑定的toString方法返回的是字符串’Generatesymbol(‘+<strong>Description</strong>+’)’，这样的话，只要传入的参数相同，那么返回值就是相等的字符串，它作为属性名的时候就不能避免重名。也就是说这一条和第8条是冲突的，我们也需要做取舍，显然作为对象属性不重名这几乎是symbol诞生的初衷，肯定是要比调用toString返回字符串重要。我们可以舍弃第8条来实现这一条，保证唯一性，创建一个生成唯一标识的方法generateName。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//每次加入一个flag值保证每次拿到的值不同</span></span><br><span class="line"><span class="keyword">var</span> generateName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> flag = <span class="number">0</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">descString</span>)</span>&#123;</span><br><span class="line">     flag++</span><br><span class="line">     <span class="keyword">return</span> <span class="string">'troubledot'</span> + descString + <span class="string">'_'</span> + flag</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>然后改造toString方法，保证在symbol在类型转换以后返回的字符串每次都不相同。当然此时已经无法满足第8条了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperties(symbol,&#123;</span><br><span class="line">  <span class="string">'__Description__'</span>: &#123;</span><br><span class="line">    value: descString,</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'__Name__'</span>: &#123;</span><br><span class="line">    value: generateName(descString),</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> symbol = <span class="built_in">Object</span>.create(&#123;</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.__Name__</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>10、Symbol 作为属性名，该属性不会出现在 for…in、for…of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回。但是，它也不是私有属性，有一个 Object.getOwnPropertySymbols 方法，可以获取指定对象的所有 Symbol属性名。 这条实现不了</p><p>11、使用for可以访问相同的symbol，前两天整数求和里面的哈希表，把创建的symbol都存在一个哈希表里面，for的时候去搜索，有的话直接返回，没有就存起来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> symbolMap = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(Generatesymbol, &#123;</span><br><span class="line">  <span class="keyword">for</span>:&#123;</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params">description</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> descString = description == <span class="literal">undefined</span> ? <span class="literal">undefined</span> : <span class="built_in">String</span>(description)</span><br><span class="line">      <span class="keyword">return</span> symbolMap[descString] ? symbolMap[descString] : symbolMap[descString] = Generatesymbol(descString)</span><br><span class="line">    &#125;,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>12、keyFor返回一个已经登记的symbol类型的key，遍历symbolMap，返回key即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> symbolMap = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(Generatesymbol,&#123;</span><br><span class="line">  keyFor:&#123;</span><br><span class="line">    value: &#123;</span><br><span class="line">      <span class="function"><span class="keyword">function</span>(<span class="params">symbol</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> symbolMap)&#123;</span><br><span class="line">          <span class="keyword">if</span> (symbolMap[key] === symbol)</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">return</span> key</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>下面看下完整实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> root = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">var</span> generateName = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> flag = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">      flag++</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'troubledot'</span>+ name +<span class="string">'_'</span>+ flag</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)()</span><br><span class="line">  <span class="keyword">var</span> Generatesymbol = <span class="function"><span class="keyword">function</span> <span class="title">Symbol</span>(<span class="params">description</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> descString = description == <span class="literal">undefined</span> ? <span class="literal">undefined</span> : <span class="built_in">String</span>(description)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Generatesymbol) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Symbol is not a constructor'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> symbol = <span class="built_in">Object</span>.create(&#123;</span><br><span class="line">      toString : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.__Name__</span><br><span class="line">      &#125;,</span><br><span class="line">      valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">Object</span>.defineProperties(symbol, &#123;</span><br><span class="line">      __Description__:&#123;</span><br><span class="line">        value: descString,</span><br><span class="line">        writable: <span class="literal">false</span>,</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        configurable: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      __Name__:&#123;</span><br><span class="line">        value: generateName(descString),</span><br><span class="line">        writable: <span class="literal">false</span>,</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        configurable: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> symbol</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> symbolMap = &#123;&#125;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperties(Generatesymbol, &#123;</span><br><span class="line">      <span class="string">'for'</span>: &#123;</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params">description</span>)</span>&#123;</span><br><span class="line">          <span class="keyword">var</span> descString = description == <span class="literal">undefined</span> ? <span class="literal">undefined</span> : <span class="built_in">String</span>(description)</span><br><span class="line">          <span class="keyword">return</span> symbolMap[descString] ? symbolMap[descString] : symbolMap[descString] = Generatesymbol(description)</span><br><span class="line">        &#125;,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">'keyFor'</span>: &#123;</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params">symbol</span>)</span>&#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> symbolMap) &#123;</span><br><span class="line">            <span class="keyword">if</span> (symbolMap[key] === symbol)&#123;</span><br><span class="line">              <span class="keyword">return</span> key</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  root.Generatesymbol = Generatesymbol</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>手动实现Symbol，有好多基础的API需要学习，共勉！</p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
          <category> js </category>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 自检清单 </tag>
            
            <tag> 前端工程师 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端工程师自检清单（一）JavaScript基础</title>
      <link href="/2019/07/17/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%87%AA%E6%A3%80%E6%B8%85%E5%8D%95%EF%BC%88%E4%B8%80%EF%BC%89JavaScript%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/07/17/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%87%AA%E6%A3%80%E6%B8%85%E5%8D%95%EF%BC%88%E4%B8%80%EF%BC%89JavaScript%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<p>这是在网上看到别人整理的前端知识体系，希望自己在剩下的半年里面能有个比较不错的提升吧。</p><p><img src="http://res.troubledot.cn/zstx" alt="前端知识体系"></p><blockquote><p>JavaScript是前端必备能力，深度和广度都不能差。</p></blockquote><h3 id="一、变量和类型"><a href="#一、变量和类型" class="headerlink" title="一、变量和类型"></a>一、变量和类型</h3><h4 id="1、-js规定了哪几种数据类型"><a href="#1、-js规定了哪几种数据类型" class="headerlink" title="1、 js规定了哪几种数据类型"></a>1、 js规定了哪几种数据类型</h4><p>js一共规定了7种数据类型，分别是undefined，null，字符串（String），数字（Number），布尔值（Boolean），对象（Object），Symbol（ES6新引入）</p><h4 id="2、js对象的底层数据结构是什么"><a href="#2、js对象的底层数据结构是什么" class="headerlink" title="2、js对象的底层数据结构是什么"></a>2、js对象的底层数据结构是什么</h4><p>对象的底层数据结构是哈希</p><h4 id="3、Symbol类型在实际开发中的应用，手动实现一个Symbol"><a href="#3、Symbol类型在实际开发中的应用，手动实现一个Symbol" class="headerlink" title="3、Symbol类型在实际开发中的应用，手动实现一个Symbol"></a>3、Symbol类型在实际开发中的应用，手动实现一个Symbol</h4><p>Symbol是ES6新引入的原始数据类型，表示一个独一无二的值，根据这个特性，我们可以用它来定义属性或者方法名防止与现有的方法发生冲突。</p><p><a href="http://localhost:4000/2019/07/18/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AASymbol/" target="_blank" rel="noopener">手动实现一个symbol</a></p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 自检清单 </tag>
            
            <tag> 前端工程师 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js设计循环队列</title>
      <link href="/2019/07/17/js%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/"/>
      <url>/2019/07/17/js%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/</url>
      <content type="html"><![CDATA[<p>循环队列是一种线性数据结构，其操作基于FIFO（先进先出）原则并且队尾被连接在队首形成一个循环。它也被称为“环形缓冲器”。循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里面，一旦队列满了，我们就不能再插入元素，即使再队列前面还有空间。但是在循环队列里面，我们就能继续利用前面的这些空间去存储新的值。</p><p>设计一个队列，实现应该支持一下操作：</p><ul><li><strong>MyCircularQueue(k)</strong>：构造器，设置队列长度为k。</li><li><strong>Front</strong>：从队首获取元素，如果队列为空则返回-1。</li><li><strong>Rear</strong>：从队尾获取元素，如果队列为空则返回-1。</li><li><strong>enQueue(value)</strong>：向循环队列插入一个元素。如果成功则返回真。</li><li><strong>deQueue()</strong>：从循环队列中删除一个元素，如果成功则返回真。</li><li><strong>isEmpty()</strong>：判断队列是否为空。</li><li><strong>isFull()</strong>：判断队列是否满了。</li></ul><blockquote><p>示例</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MycircularQueue  circularQueue = <span class="keyword">new</span> MrcircularQueue(<span class="number">3</span>)    <span class="comment">//设置队列长度为3</span></span><br><span class="line">circularQueue.enQueue(<span class="number">1</span>) <span class="comment">//向队列中插入1 返回true</span></span><br><span class="line">circularQueue.enQueue(<span class="number">2</span>)  <span class="comment">//向队列中插入2 返回true</span></span><br><span class="line">circularQueue.enQueue(<span class="number">3</span>)  <span class="comment">//向队列中插入3 返回true</span></span><br><span class="line">circularQueue.enQueue(<span class="number">4</span>)  <span class="comment">//返回false因为队列已经满了</span></span><br><span class="line">circularQueue.Rear()  <span class="comment">//返回3</span></span><br><span class="line">circularQueue.isFull()  <span class="comment">//返回true</span></span><br><span class="line">circularQueue.deQueue()  <span class="comment">//返回true从队首删掉一个元素</span></span><br><span class="line">circularQueue.enQueue(<span class="number">4</span>)  <span class="comment">//像队列中新增一个元素，因为之前删掉了一个元素，所以队列中有位置可以插入，返回true</span></span><br><span class="line">circularQueue.Rear()  <span class="comment">//返回4</span></span><br></pre></td></tr></table></figure><p>下面是js代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MycircularQueue = <span class="function"><span class="keyword">function</span>(<span class="params">k</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.size = k</span><br><span class="line">  <span class="keyword">this</span>.head = <span class="number">-1</span></span><br><span class="line">  <span class="keyword">this</span>.tail = <span class="number">-1</span></span><br><span class="line">  <span class="keyword">this</span>.data = []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MycircularQueue.prototype.enQueue(value)&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.isFull())&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty())&#123;</span><br><span class="line">    <span class="keyword">this</span>.head = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.tail = (<span class="keyword">this</span>.tail+<span class="number">1</span>)%<span class="keyword">this</span>.size</span><br><span class="line">  <span class="keyword">this</span>.data[<span class="keyword">this</span>.tail] = value</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MycircularQueue.prototype.deQueue()&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.isEmpty())&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.head===<span class="keyword">this</span>.tail)&#123;</span><br><span class="line">      <span class="keyword">this</span>.head = <span class="number">-1</span></span><br><span class="line">      <span class="keyword">this</span>.tail = <span class="number">-1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.head = (<span class="keyword">this</span>.head+<span class="number">1</span>)%<span class="keyword">this</span>.size</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MycircularQueue.prototype.Front()&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.isEmpty()?<span class="number">-1</span>:<span class="keyword">this</span>.data[<span class="keyword">this</span>.head]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MycircularQueue.prototype.Rear()&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.isEmpty()?<span class="number">-1</span>:<span class="keyword">this</span>.data[<span class="keyword">this</span>.tail]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MycircularQueue.prototype.isFull()&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">this</span>.tail+<span class="number">1</span>)%<span class="keyword">this</span>.size === <span class="keyword">this</span>.head</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MycircularQueue.prototype.isEmpty()&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.head === <span class="number">-1</span> &amp;&amp; <span class="keyword">this</span>.tail === <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MycircularQueue.prototype.isEmpty()&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.head === <span class="keyword">this</span>.tail === <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其中有几个地方有过疑惑，一个是Front和Rear那里<br>在取Front和Rear的时候，我判断了队列是否为空，空则返回-1，否则返回对应值，如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MycircularQueue.prototype.Front()&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.isEmpty()?<span class="number">-1</span>:<span class="keyword">this</span>.data[<span class="keyword">this</span>.head]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我看了有些人是这么写的，Front的时候判断head值是否等于-1，Rear的时候判断tail是否为-1，也就是判断是否有队首或者队尾，有则返回，无则返回-1。诚然，在这道题下，两种方法其实并无区别，因为队列是根本不可能存在有头无尾或者有尾无头的情况的。但是从这个区别中也能反应出一种思维习惯，就是编程中比较常见的思想：模块和独立。队首我们只关心head，队尾只关心tail，这样能保证所有的方法高度独立，是一个值得去刻意培养的习惯。代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MycircularQueue.prototype.Front()&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.head === <span class="number">-1</span>?<span class="number">-1</span>:<span class="keyword">this</span>.data[<span class="keyword">this</span>.head]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rear同理。</p><p>还有一处区别就是：我把普通的&amp;&amp;写成了连等的形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MycircularQueue.prototype.isEmpty()&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.head === <span class="keyword">this</span>.tail === <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个地方就是isFull的时候，因为自己初识算法，思维比较固化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MycircularQueue.prototype.isFull()&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.tail+<span class="number">1</span> = <span class="keyword">this</span>.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在回头来看错误就比较明显了，循环算法head不可能永远在第一位的。</p><p>以上就是如何用js实现一个循环队列。 共勉</p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
          <category> js </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Promise</title>
      <link href="/2019/07/01/Promise/"/>
      <url>/2019/07/01/Promise/</url>
      <content type="html"><![CDATA[<p>Promise作为es6中出现的新概念，改变了js的异步编程，现代前端的大多数异步请求都是通过Promise实现的，fetch这个web api也是基于Promise实现的，这里不得简述一下之前统治JS异步编程的回调函数，回调函数有什么缺点，Promise又是怎么改善这些缺点</p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>js一开始的作用就是操作dom元素，如果多线程改变dom很可能会导致界面紊乱，所以js一开始的设计就是单线程的，但是浏览器是多线程的，这使得JS同时具有异步的操作，即定时器，请求，事件监听等，而这个时候就需要一套事件的处理机制去决定这些事件的顺序，即Event Loop（事件循环），这里不会详细讲解事件循环，只需要知道，前端发出的请求，一般都是会进入浏览器的http请求线程，等到收到响应的时候会通过回调函数推入异步队列，等处理完主线程的任务会读取异步队列中任务，执行回调</p><p>在《你不知道的JavaScript》下卷中，这么介绍</p><p>使用回调函数处理异步请求相当于把你的回调函数置于了一个黑盒，虽然你声明了等到收到响应后执行你提供的回调函数,可是你并不知道这个第三方库会在什么时候具体会怎么执行回调函数</p><p>使用第三方的请求库你可能会这么写:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ajax(<span class="string">"http://localhost:3000"</span>)=&gt;&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'你扣了1000块钱'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>收到响应以后执行你提供的回调函数，打印字符串，但是如果这个第三方库有类似超时重试的功能，如果这是一个支付功能，那么你被扣的可能就不是1000块钱了。</p><p>第二个众所周知的问题就是在回调里面套回调函数，成了可怕的“回调地狱”，代码难懂难维护。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ajax(<span class="string">"http://localhost:3000"</span>)=&gt;&#123;</span><br><span class="line">  ajax(<span class="string">"http://localhost:3001"</span>)=&gt;&#123;</span><br><span class="line">    ajax(<span class="string">"http://localhost:3002"</span>)=&gt;&#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有就是如果第三方库没有提供错误的回调，那么请求失败的一些信息可能就会被吞掉，而你却完全不知情(nodejs提供了err-first风格的回调,即异步操作的第一个回调永远是错误的回调处理,但是你还是不能保证所有的库都提供了发送错误时的执行的回调函数)</p><ol><li>多重嵌套，导致回调地狱；</li><li>代码跳跃，不符合人类思维模式；</li><li>信任问题，不能把回调完全交给第三方来执行，因为我们不知道他到底如何来执行；</li><li>第三方库可能没有错误回调；</li><li>不清楚回调是否都是异步调用的（可以同步调用ajax，在收到响应前会阻塞整个线程，会陷入假死状态，很不推荐。）</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(<span class="string">"GET"</span>,<span class="string">"/try/ajax/ajax_info.txt"</span>,<span class="literal">false</span>); <span class="comment">//通过设置第三个async为false可以同步调用ajax</span></span><br></pre></td></tr></table></figure><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>针对回调函数函数的这么多缺点，Promis应运而生，Promise是一个构造函数，通过new关键字来创建一个Promise实例，来看下Promise是如何解决回调函数的这些缺点的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'I have been resolved'</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res) <span class="comment">//两秒后打印字符串</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>Promise并不是回调函数的衍生，而是两个概念，所以需要将之前的回调函数改为支持Promise的版本，这个过程成为”提升”，或者”promisory”，现代MVVM框架常用的第三方请求库axios就是一个典型的例子，另外nodejs中也有bluebird，Q等。</strong></p><h4 id="1、多重嵌套导致回调地狱"><a href="#1、多重嵌套导致回调地狱" class="headerlink" title="1、多重嵌套导致回调地狱"></a>1、多重嵌套导致回调地狱</h4><p>Promise在设计的时候引入了链式调用的概念，每个then方法同是也是一个Promise，所以只要你愿意可以一直then下去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">"http://localhost:3000"</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> axios.get(<span class="string">"http://localhost:3001"</span>))</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> axios.get(<span class="string">"http://localhost:3002"</span>))</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> axios.get(<span class="string">"http://localhost:3003"</span>))</span><br></pre></td></tr></table></figure><p>配合箭头函数，明显的比之前回调函数的多层嵌套优雅很多</p><h4 id="2、代码跳跃，不符合人类思维模式"><a href="#2、代码跳跃，不符合人类思维模式" class="headerlink" title="2、代码跳跃，不符合人类思维模式"></a>2、代码跳跃，不符合人类思维模式</h4><p>Promise使我们在写异步的时候使用同步思维，上述代码就是自上而下执行，格式符合正常思维模式</p><h4 id="3、信任问题，不能把回调完全交给第三方来执行，因为我们不知道他到底如何来执行"><a href="#3、信任问题，不能把回调完全交给第三方来执行，因为我们不知道他到底如何来执行" class="headerlink" title="3、信任问题，不能把回调完全交给第三方来执行，因为我们不知道他到底如何来执行"></a>3、信任问题，不能把回调完全交给第三方来执行，因为我们不知道他到底如何来执行</h4><p>Promise本身是一个状态机，有以下三种状态：</p><ul><li>pending（等待）</li><li>fulfilled（成功）</li><li>rejected（拒绝）</li></ul><p>当请求发送没有得到响应的时候是pending状态，得到响应后会resolve（决议）当前这个Promise实例，将它变成fulfilled还是rejected。<br>当请求发生错误后会执行reject(拒绝)将这个Promise实例变为rejected状态</p><p>一个Promise实例的状态只能从pending变成fulfilled或者从pending变成rejected，也就是说一个Promise实例自pending状态改变以后就不能在改变了，也就是说不存在从rejected到fulfilled或者从fulfilled到rejected的情况。</p><p>而Promise实例必须主动调用then方法才能从Promise实例中取到值（前提是Promise不是pending状态），这个主动的做法正是解决这一问题的关键，也就是说第三方库做的就是改变Promise的状态，至于响应的值怎么处理就是开发者来做的事情了，而es6的Promise中我们可以主动的去掉用then方法来改变状态，这就实现控制反转，将原来第三方库的控制权移到了自己手上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">"http://localhost:3000"</span>) <span class="comment">//收到响应后这个promise的状态会变成resolved，但是取到值需要用户主动去调用then方法</span></span><br><span class="line">axios.get(<span class="string">"http://localhost:3000"</span>)</span><br><span class="line">      .then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res) <span class="comment">//主动调用then方法取到值再对值进行处理</span></span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure><h4 id="4、第三方库可能没有提供错误回调-catch"><a href="#4、第三方库可能没有提供错误回调-catch" class="headerlink" title="4、第三方库可能没有提供错误回调 catch"></a>4、第三方库可能没有提供错误回调 catch</h4><p>Promise的then方法接受两个函数作为参数，一个是响应resolved的回调，一个是响应rejected的回调，其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用Promise在异步请求发送错误的时候，即使没有捕获错误，也不会阻塞主线程的代码（准确的来说，异步的错误都不会阻塞主线程的代码）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">'ok'</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; <span class="built_in">console</span>.log(value) &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123; <span class="built_in">console</span>.log(error) &#125;);</span><br><span class="line"><span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>上面代码中，Promise 在resolve语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。</p><p>Promise的错误具有冒泡性质，会一直向后传递，知道被捕获，也就是说，错误总会被下一个catch捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">'/post/1.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(post.commentURL);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">comments</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理前面三个Promise产生的错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，一共有三个 Promise 对象：一个由getJSON产生，两个由then产生。它们之中任何一个抛出的错误，都会被最后一个catch捕获。</p><p>一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。</p><p>如果再then方法中抛出错误，也会被后面的catch捕获到，而使用then的第二个参数就不可以。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someAsyncThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    resolve(x + <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">someAsyncThing().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'everything is great'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="number">123</span>) &#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="comment">// Uncaught (in promise) ReferenceError: x is not defined</span></span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>上面的代码，resolve中x没有定义会报错，所以then方法的回调没有执行，但是两秒会还是会打印出123来，证明promise内部的错误不会影响到外面，会吞掉错误。</p><h4 id="5、不清楚回调是否是异步的"><a href="#5、不清楚回调是否是异步的" class="headerlink" title="5、不清楚回调是否是异步的"></a>5、不清楚回调是否是异步的</h4><p>Promise在设计的时候保证所有响应的处理回调都是异步调用的，不会阻塞代码的执行，Promise将then方法的回调放入一个叫微任务的队列中（MicroTask），确保这些回调任务在同步任务执行完以后再执行，这部分同样也是事件循环的知识点，有兴趣的朋友可以深入研究一下</p><p>对于第三个问题中,为什么说执行了resolve函数后”大部分情况”会进入fulfilled状态呢?考虑以下情况</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="built_in">Promise</span>.reject(<span class="string">'报错了'</span>))</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(promise)</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>这里用一个定时器再下一轮事件循环中打印promise吗，不然promise的状态一直是pending。</p><p><img src="http://res.troubledot.cn/promise.png" alt="promise"></p><p>我们可以看到打印的结果返回的仍然是一个拒绝状态的promise，原因是如果在一个promise的resolve函数中又传入了一个Promise,会展开传入的这个promise，也就是说上面的代码等同于这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.reject(<span class="string">'报错了'</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(promise)</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>日常开发中建议全面使用Promise，配合后面的async和await可以使用同步的形式来写异步代码，并且能够更优雅的实现异步代码顺序执行以及在发生异步的错误时提供更精准的错误信息。</p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
          <category> js </category>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>es6 iterator迭代器</title>
      <link href="/2019/06/28/es6-iterator%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
      <url>/2019/06/28/es6-iterator%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>iterator迭代器是ES6非常重要的概念，但是很多人对它了解的不多，但是它却是另外4个ES6常用特性的实现基础（解构赋值，剩余/扩展运算符，生成器，for of循环），了解迭代器的概念有助于了解另外4个核心语法的原理，另外ES6新增的Map,Set数据结构也有使用到它。</p><p>对于可迭代的数据解构，ES6在内部部署了一个[Symbol.iterator]属性，它是一个函数，执行后会返回iterator对象（也叫迭代器对象），而生成iterator对象[Symbol.iterator]属性叫iterator接口,有这个接口的数据结构即被视为可迭代的</p><p>数组中的Symbol.iterator方法(iterator接口)默认部署在数组原型上:</p><p><img src="http://res.troubledot.cn/1.png" alt="symbol"></p><p>默认部署iterator接口的数据结构有一下几个，普通对象是默认没有iterator接口的。</p><ul><li>Array</li><li>Map</li><li>Set</li><li>String</li><li>TypeArray（类数组）</li><li>函数的argument对象</li><li>Nodelist对象</li></ul><p>其实interator就是一个对象，又一个叫next的方法，执行以后又返回一个对象，包含两个属性一个done，一个value，done是迭代结束的标志，结束为true否则是false，value为值，迭代结束以后为undefined，我们可以尝试用es5来实现一个interator；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// es5 实现interator</span><br><span class="line">function crateInterator(items)&#123;</span><br><span class="line">  var i = 0</span><br><span class="line">  return &#123;</span><br><span class="line">    next: function() &#123;</span><br><span class="line">      done = i &gt;= items.length</span><br><span class="line">      value = done?undefined:items[i++]</span><br><span class="line">      return &#123;</span><br><span class="line">        done: done,</span><br><span class="line">        value: value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var interator = crateInterator([1,2,3])</span><br><span class="line"></span><br><span class="line">interator.next()   //&#123;done: false, value: 1&#125;</span><br><span class="line">interator.next()   //&#123;done: false, value: 2&#125;</span><br><span class="line">interator.next()   //&#123;done: false, value: 3&#125;</span><br><span class="line">interator.next()   //&#123;done: true, value: undefined&#125;</span><br></pre></td></tr></table></figure><p>最后整理下：</p><ul><li>可迭代的数据结构都有个[Symbol.interator]方法</li><li>[Symbol.interator]执行以后会返回一个interator对象</li><li>interator对象有个next方法</li><li>next方法执行后会返回一个对象，这个对象有两个属性done和value，done是迭代是否结束的标志，结束为true否则为false，value为每次迭代返回的值。</li></ul>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
          <category> js </category>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一条统计代码行数的正则</title>
      <link href="/2019/06/14/%E4%B8%80%E6%9D%A1%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0%E7%9A%84%E6%AD%A3%E5%88%99/"/>
      <url>/2019/06/14/%E4%B8%80%E6%9D%A1%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0%E7%9A%84%E6%AD%A3%E5%88%99/</url>
      <content type="html"><![CDATA[<p>项目做完需要统计代码行数，我都忘了上次是怎么做的统计了，吸取教训，这次记录一下，上网找了一条统计代码行数的正则，去掉了空行，注释，甚至独占一行的大括号也去掉了。在vscode中搜索即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(?!(\s*\*))(?!(\s*\-\-\&gt;))(?!(\s*\&lt;\!\-\-))(?!(\s*\n))(?!(\s*\*\/))(?!(\s*\/\*))(?!(\s*\/\/\/))(?!(\s*\/\/))(?!(\s*\&#125;))(?!(\s*\&#123;))(?!(\s(using))).*</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 收藏 </category>
          
          <category> js技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>你加我不等于我们</title>
      <link href="/2019/02/27/%E4%BD%A0%E5%8A%A0%E6%88%91%E4%B8%8D%E7%AD%89%E4%BA%8E%E6%88%91%E4%BB%AC/"/>
      <url>/2019/02/27/%E4%BD%A0%E5%8A%A0%E6%88%91%E4%B8%8D%E7%AD%89%E4%BA%8E%E6%88%91%E4%BB%AC/</url>
      <content type="html"><![CDATA[<p>前两天偶然在知乎上看到一个男生在吐苦水：他对女朋友特别好，每天拼了命的工作想买车买房为她提供更好的条件，但是最好她却跟另外一个男生好了，仅仅因为那个男生送了她一只卡西欧的手表，把手机壁纸换成了她的照片。</p><p>乍一看，确实令人不解，但是这时候有人问到：你买车买房真的是为了她吗？</p><p>我们仔细想想，其实车房是为了将来跟你结婚组建家庭的那个人，那个人可以是她也可以是别人。这么看来那块卡西欧手表倒是真正的属于她，这份爱廉价但却很真实。</p><p>好多人以为两个人在一起的关系就像这样简单：</p><p><img src="http://res.troubledot.cn/we-1.png" alt="关系1"></p><p>你和我组成了我们，我为我们的努力也都是为了你。</p><p>实际上我感觉两个人在一起更像是这样</p><p><img src="http://res.troubledot.cn/we.png" alt="关系2"></p><p>你我并非我们的子集。怎么理解呢，两个人在一起，即使他们已经结婚生子，但每个人依然会有一部分真正属于自己的东西和空间，就是图中的12区域，比如说女生的口红包包，男生的游戏机手办之类的。上面那位男生提到的车房应该是属于4区域，是那类两人共用但是偏向于自己的物品，而另一位男生的手表和壁纸都是在1区的，如此看来女生get不到他深沉的爱也就不难理解了。</p><p>刚好前段时间情人节，那天没有给自己女朋友或者妻子准备礼物的男生借口应该都差不多：工作忙，平时为了家都这么累了，没有精力准备以及不过这种西方节日。</p><p>内心戏也都差不多：难道就因为今天没有礼物就要否定我平时对你的好吗？</p><p>而女孩子面对这种情况大体就这几种情况：</p><p>知书达理内心善良女生面对这种情况只是嘴上抱怨几句，心里会有一点小失落：如果能像别人那样收到礼物该多好呀。</p><p>有点小矫情的女生：会跟你吵一架，闹闹脾气。</p><p>关注咪蒙的小仙女们：这样的男朋友不分还留着过年？</p><p>生活中大多数女生是前两种，其实我们只要花一点点功夫就能让她们开心好久，哪怕是你临时买的一支花，再或者楼下小超市买的一盒酸奶甚至是同事酒席上装口袋里的一把瓜子喜糖。</p><p>之前刷抖音的时候，看到一个小视频，一个农村阿姨正在地头劳作，收到了老公的一束花，但是这应该是她一生中第一次收到花，她先是一脸惊讶，紧接着眼泪唰一下就下来了，嘴上抱怨着：买这干啥，买这干啥。手上小心翼翼的把花拿过去了。我们知道这花有可能是为了拍视频准备的，但是这种感动是演不出来的。她是家里的女主人，所以她理解丈夫的压力，理解生活的艰辛，同时她又是妻子，她也渴望着丈夫的爱。</p><p>都说男生的快乐很简单，女生何尝不是呢。许多男人在抱怨妻子不理解的时候，可曾想过自己在为1区付出过多少，爱是需要表达出来的，而那个将与你相互扶持走过大半生的人值得你所有的爱。</p><p>换男生的角度来说，这个大冬天下楼给你买早点，碰到啥好吃的都为你留一口的男孩子其实也需要关怀和爱，他跟你其实没有多大区别，如果你们没有在一起，他可能就是你公司里面的小张小李，生病的时候同样需要人来照顾，月底交房租水电费的时候同样也会仔细多算几次，被领导批评的时候同样会难堪。。。在当前这个社会背景下，跟你年纪相仿的他要承载更多，你的一句关心，一个笑脸就能给他带来一个轻松的心情，何乐不为呢。</p><p>礼物只是一种经营关系的方式，其实不需要太过贵重，只要在12区域即可，男朋友生日你送他剃须刀肯定是要好过豆浆机的，哪怕你答应她天天6点起来给他打豆浆喝，这里的豆浆机就是5区的物品，女朋友过生日，你送她一支十块钱的玫瑰花都要强过一台2000块的全自动洗衣机（例子比较极端，当然不排除真有人这么干）。</p><p>跟一个完全陌生的人结合并共度人生的大部分时间，本就不是一件简单的事情。将这份感情经营好是要花费精力在上面的，千万不要妄想着靠那点可怜的荷尔蒙来为我们今后的几十年持续不断的提供多巴胺。</p><p>从现代人的出现到现在，有统计显示地球上生活过1170亿人，能在同一时空相遇又相爱需要多大的缘分啊，这份缘分难道不值得我们花精力去守护吗？</p>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 情感 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>三十出头的你还想有个人依靠？</title>
      <link href="/2019/02/25/%E4%B8%89%E5%8D%81%E5%87%BA%E5%A4%B4%E7%9A%84%E4%BD%A0%E8%BF%98%E6%83%B3%E6%9C%89%E4%B8%AA%E4%BA%BA%E4%BE%9D%E9%9D%A0%EF%BC%9F/"/>
      <url>/2019/02/25/%E4%B8%89%E5%8D%81%E5%87%BA%E5%A4%B4%E7%9A%84%E4%BD%A0%E8%BF%98%E6%83%B3%E6%9C%89%E4%B8%AA%E4%BA%BA%E4%BE%9D%E9%9D%A0%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>90年生人，身份证上是89年。按照老家的说法满打满算三十了。在这个城市待了8年多了，生活毫无起色，前几天和她吵架了，常常在她面前说教控制情绪的我还是没能幸免，该说的不该说的都说了。</p><p>仔细想想自己做人做事好像都挺失败的，只不过一直不愿意承认罢了，其实身边最熟悉的人们也都在极力帮我隐瞒这个事实，也难为他们了。</p><p>一个人在外边晃了三天了，昨晚上十一点多在大街上不停地打开“美团”刷附近的酒店，路过汉庭进去问了下，一夜240，喝了一口水掩饰尴尬：“那算了，我再去找找”。甚至不敢多看一眼前台服务人员，像极了上学时候问到一条200多的裤子。</p><p>背个包在大街上继续游荡，仿佛一个孤魂野鬼，路过万达，对面是一家24小时营业的牛肉面馆，在隔壁KTV喝嗨了的人三五成群的来这里吃饭，有一对小情侣说说笑笑的闹着走进了旁边的小区，突然发现我也许从来就没有属于过这座城市。我曾经给她说过在这里只有我们俩相依为命，我一直以为这只是我安慰她的话，毕竟这可是我甘肃老家啊，现在发现这个城市于她于我并无两样。</p><p><strong>家不是地方也不是房子，我们在这个陌生的城市里真的只有彼此。</strong></p><p>她说她要跟她妈一起回家。妈是依靠，家是依靠。委屈的时候可以回家找妈，真好。。</p><p>我也想家了，有点想老赵了，想回家或者打个电话给他。随即马上打消了这个念头，只会让他徒增烦恼罢了，我并不算是个多争气的儿子。</p><p>早上在外面吃饭的时候，接到老赵的电话：“一切都好，不要再操心了，放心吧都好着呢。”匆匆挂了电话，差点没忍住哭出声来。</p><p>正好赶上旁边一所中学放学了，到处都是中学生，感觉自己真的有点格格不入，仔细看看就会发现他们脸上的笑真的好好看啊。</p><p>突然想到了自己初中的时候，想起了我的发小mtr，其实我真的很感激他，母亲病了以后父亲为生活疲于奔命，我哥也自顾不暇。从初中开始就是他一直在照顾我，去食堂他负责打饭付钱，我等着吃就好了，去网吧上网他负责开机子登记身份证，我开机玩就成，去酒吧喝酒他负责订包厢去跟各路朋友应酬交涉，我只负责玩我自己的，甚至我叫了我的朋友他也可以帮我暖场招呼好，跟同学打闹的时候我被踢了一脚，他误会了给我出头要跟人动手，他妈也对我特别好，做各种各样好吃的给我俩，来给他陪读的时候下午会把我的饭也做好，那会儿其实也会羡慕。说实话自我记事起好像就再没有过这样的经历。</p><p>前段时间他打电话跟我说怕我现在过的不好怪他当年带我瞎玩没好好学习，提到了他特别想在我结婚的时候能给我全程操办着，给我把面子涨足，虽然当时表现的很云淡风轻，说实话我被感动到了。</p><p>找他吗？他儿子一岁了，他有他的家长里短，生活过的没有那么顺心，这些琐事好像说不到他头上。</p><p>突然发现除了她我好像本来就没有一个能说说话的人，可笑的是我还曾说过她没有什么好闺蜜。</p><p>我并不是一个能独当一面的人，不是一个能给别人安全感的人，以前有朋友说过我自己都是一个需要照顾的人还怎么去照顾别人，事实证明也的确如此。其实我的性格有明显的缺陷：极度敏感，抱怨领导，抱怨同事，有时候负能量爆棚，不断的逃避现实，好多事情的处理显得极为幼稚，而最后只能默默的自吞苦果。好多时候我清楚我的内心其实并不豁达，我的性子也并非玩世不恭，只是不愿意面对这个让自己失望的自己而已。</p><p>白天时间过的好快啊，天又快黑了，冬天的这种时候还在大街上没能回家，这是最让我烦心的事情。</p><p>车水马龙，万家灯火，广场上的大叔大妈们按时跳起了广场舞，我突然感觉好讨厌这里，好讨厌这个城市。</p>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>函数的扩展</title>
      <link href="/2019/01/16/%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/"/>
      <url>/2019/01/16/%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/</url>
      <content type="html"><![CDATA[<h3 id="1-函数参数的默认值"><a href="#1-函数参数的默认值" class="headerlink" title="1.函数参数的默认值"></a>1.函数参数的默认值</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>es6之前，函数的参数不能给默认值的，如果一定要给，只能用变通的方法；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  y = y||<span class="string">'Word'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x,y)</span><br><span class="line">&#125;</span><br><span class="line">log(<span class="string">'Hello'</span>) <span class="comment">// Hello World</span></span><br><span class="line">log(<span class="string">'Hello'</span>, <span class="string">'China'</span>) <span class="comment">// Hello China</span></span><br><span class="line">log(<span class="string">'Hello'</span>, <span class="string">''</span>) <span class="comment">// Hello World</span></span><br></pre></td></tr></table></figure><p>这样的问题就在于如果y是一个boll值为false的值，那么他就会取到默认值。就像上面最后一行代码，我们预期输出的应该是‘Hello ’，但是因为我们给y赋的值对应的布尔值为false，所以他最后读了默认值World。这里我们就需要额外判断一次y是否被赋值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> y === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">  y = <span class="string">'World'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是现在es6解决了这个问题，我们可以在定义参数的时候直接为其赋一个默认值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y = <span class="string">'World'</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(<span class="string">'Hello'</span>) <span class="comment">// Hello World</span></span><br><span class="line">log(<span class="string">'Hello'</span>, <span class="string">'China'</span>) <span class="comment">// Hello China</span></span><br><span class="line">log(<span class="string">'Hello'</span>, <span class="string">''</span>) <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure><p>这样的写法比较自然也符合我们正常的思维。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x = <span class="number">0</span>, y = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Point();</span><br><span class="line">p <span class="comment">// &#123; x: 0, y: 0 &#125;</span></span><br></pre></td></tr></table></figure><p>除了简洁，ES6 的写法还有两个好处：首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。</p><p>参数变量是默认声明的，所以不能用let或const再次声明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x = <span class="number">5</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>; <span class="comment">// error</span></span><br><span class="line">  <span class="keyword">const</span> x = <span class="number">2</span>; <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，参数变量x是默认声明的，在函数体中，不能用let或const再次声明，否则会报错。</p><p>使用参数默认值时，函数不能有同名参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, x, y</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, x, y = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SyntaxError: Duplicate parameter name not allowed in this context</span></span><br></pre></td></tr></table></figure><p>另外，一个容易忽略的地方是，参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">99</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">p = x + <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">100</span>;</span><br><span class="line">foo() <span class="comment">// 101</span></span><br></pre></td></tr></table></figure><p>上面代码中，参数p的默认值是x + 1。这时，每次调用函数foo，都会重新计算x + 1，而不是默认p等于 100。</p><h4 id="与解构赋值默认值结合使用"><a href="#与解构赋值默认值结合使用" class="headerlink" title="与解构赋值默认值结合使用"></a>与解构赋值默认值结合使用</h4><p>参数默认值可以和解构赋值的默认值结合起来使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(&#123;&#125;) <span class="comment">// undefined 5</span></span><br><span class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;) <span class="comment">// 1 5</span></span><br><span class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;) <span class="comment">// 1 2</span></span><br><span class="line">foo() <span class="comment">// TypeError: Cannot read property 'x' of undefined</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
          <category> js </category>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>系统学习ES6（数值的扩展）</title>
      <link href="/2019/01/07/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0ES6%EF%BC%88%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95%EF%BC%89/"/>
      <url>/2019/01/07/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0ES6%EF%BC%88%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="1-二进制和八进制的表示方法"><a href="#1-二进制和八进制的表示方法" class="headerlink" title="1.二进制和八进制的表示方法"></a>1.二进制和八进制的表示方法</h3><p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0b111110111</span> === <span class="number">503</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0o767</span> === <span class="number">503</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>从es5开始，严格模式下八进制就不允许使用前缀0来表示，es6中进一步明确要用0o来表示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非严格模式</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">0o11</span> === <span class="number">011</span>);</span><br><span class="line">&#125;)() <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 严格模式</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">0o11</span> === <span class="number">011</span>);</span><br><span class="line">&#125;)() <span class="comment">// Uncaught SyntaxError: Octal literals are not allowed in strict mode.</span></span><br></pre></td></tr></table></figure><p>如果要将0b和0o表示的数转换成十进制要使用Number方法；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number(&apos;ob11&apos;)   3</span><br><span class="line">Number(&apos;0o10&apos;)   8</span><br></pre></td></tr></table></figure><h3 id="2-Number-isFinite-、Number-isNaN"><a href="#2-Number-isFinite-、Number-isNaN" class="headerlink" title="2.Number.isFinite()、Number.isNaN()"></a>2.Number.isFinite()、Number.isNaN()</h3><p>es6在number对象上提供了两个新方法，isFinite()和isNaN()；很明显是用来检测一个数值是否是finite和NaN的。</p><p>Number.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">15</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">0.8</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(-<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">'foo'</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">'15'</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">true</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>参数类型不是数值的时候，均返回false；</p><p>isNaN是用来检查一个数值是否是NaN</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">15</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">'15'</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">true</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">9</span>/<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">'true'</span> / <span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">'true'</span> / <span class="string">'true'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果参数类型不是NaN，一律返回false；</p><p>他们与全局方法isFinite和isNaN有的区别在于，传统方法先调用Number()方法将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isInfinite()对于非数值一律返回false，Number.isNaN只有对于NaN才返回true</p><h3 id="3-Number-parseInt-Number-parseFloat"><a href="#3-Number-parseInt-Number-parseFloat" class="headerlink" title="3.Number.parseInt(), Number.parseFloat()"></a>3.Number.parseInt(), Number.parseFloat()</h3><p>ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'12.34'</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'123.45#'</span>) <span class="comment">// 123.45</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="built_in">Number</span>.parseInt(<span class="string">'12.34'</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">Number</span>.parseFloat(<span class="string">'123.45#'</span>) <span class="comment">// 123.45</span></span><br></pre></td></tr></table></figure><h3 id="4-Number-isInteger"><a href="#4-Number-isInteger" class="headerlink" title="4.Number.isInteger()"></a>4.Number.isInteger()</h3><p>Number.isInteger()用来判断一个数值是否为整数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25.1</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>js内部，浮点数和整数采用的是同样的储存方法，所以25和25.0被视为同一个值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger() <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="string">'15'</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="literal">true</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>注意，由于 JavaScript 采用 IEEE 754 标准，数值存储为64位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）。如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，Number.isInteger可能会误判。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">3.0000000000000002</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，Number.isInteger的参数明明不是整数，但是会返回true。原因就是这个小数的精度达到了小数点后16个十进制位，转成二进制位超过了53个二进制位，导致最后的那个2被丢弃了。</p><p>类似的情况还有，如果一个数值的绝对值小于Number.MIN_VALUE（5E-324），即小于 JavaScript 能够分辨的最小值，会被自动转为 0。这时，Number.isInteger也会误判。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">5E-324</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">5E-325</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，5E-325由于值太小，会被自动转为0，因此返回true。</p><p>总之，如果对数据精度的要求较高，不建议使用Number.isInteger()判断一个数值是否为整数。</p><h3 id="5-Number-EPSILON"><a href="#5-Number-EPSILON" class="headerlink" title="5.Number.EPSILON"></a>5.Number.EPSILON</h3><p>ES6 在Number对象上面，新增一个极小的常量Number.EPSILON。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。</p><p>对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的1.00..001，小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.EPSILON === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">-52</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.EPSILON</span><br><span class="line"><span class="comment">// 2.220446049250313e-16</span></span><br><span class="line"><span class="built_in">Number</span>.EPSILON.toFixed(<span class="number">20</span>)</span><br><span class="line"><span class="comment">// "0.00000000000000022204"</span></span><br></pre></td></tr></table></figure><p>Number.EPSILON实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。</p><p>引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span></span><br><span class="line"><span class="comment">// 0.30000000000000004</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> - <span class="number">0.3</span></span><br><span class="line"><span class="comment">// 5.551115123125783e-17</span></span><br><span class="line"></span><br><span class="line"><span class="number">5.551115123125783e-17</span>.toFixed(<span class="number">20</span>)</span><br><span class="line"><span class="comment">// '0.00000000000000005551'</span></span><br></pre></td></tr></table></figure><p>上面代码解释了，为什么比较0.1 + 0.2与0.3得到的结果是false。</p><p>Number.EPSILON可以用来设置“能够接受的误差范围”。比如，误差范围设为 2 的-50 次方（即Number.EPSILON * Math.pow(2, 2)），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5.551115123125783e-17</span> &lt; <span class="built_in">Number</span>.EPSILON * <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>因此，Number.EPSILON的实质是一个可以接受的最小误差范围。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withinErrorMargin</span> (<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.abs(left - right) &lt; <span class="built_in">Number</span>.EPSILON * <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span> <span class="comment">// false</span></span><br><span class="line">withinErrorMargin(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.1</span> + <span class="number">1.3</span> === <span class="number">2.4</span> <span class="comment">// false</span></span><br><span class="line">withinErrorMargin(<span class="number">1.1</span> + <span class="number">1.3</span>, <span class="number">2.4</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面的代码为浮点数运算，部署了一个误差检查函数。</p><h3 id="6-安全整数和-Number-isSafeInteger"><a href="#6-安全整数和-Number-isSafeInteger" class="headerlink" title="6.安全整数和 Number.isSafeInteger()"></a>6.安全整数和 Number.isSafeInteger()</h3><p>JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) <span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="number">9007199254740992</span>  <span class="comment">// 9007199254740992</span></span><br><span class="line"><span class="number">9007199254740993</span>  <span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，超出 2 的 53 次方之后，一个数就不精确了。</p><p>ES6 引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MAX_SAFE_INTEGER === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.MAX_SAFE_INTEGER === <span class="number">9007199254740991</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.MIN_SAFE_INTEGER === -<span class="built_in">Number</span>.MAX_SAFE_INTEGER</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.MIN_SAFE_INTEGER === <span class="number">-9007199254740991</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，可以看到 JavaScript 能够精确表示的极限。</p><p>Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="string">'a'</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="literal">NaN</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="literal">Infinity</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(-<span class="literal">Infinity</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">3</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">1.2</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">9007199254740990</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">9007199254740992</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="built_in">Number</span>.MIN_SAFE_INTEGER - <span class="number">1</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="built_in">Number</span>.MIN_SAFE_INTEGER) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="built_in">Number</span>.MAX_SAFE_INTEGER) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="built_in">Number</span>.MAX_SAFE_INTEGER + <span class="number">1</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>这个函数的实现很简单，就是跟安全整数的两个边界值比较一下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isSafeInteger = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">typeof</span> n === <span class="string">'number'</span> &amp;&amp;</span><br><span class="line">    <span class="built_in">Math</span>.round(n) === n &amp;&amp;</span><br><span class="line">    <span class="built_in">Number</span>.MIN_SAFE_INTEGER &lt;= n &amp;&amp;</span><br><span class="line">    n &lt;= <span class="built_in">Number</span>.MAX_SAFE_INTEGER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际使用这个函数时，需要注意。验证运算结果是否落在安全整数的范围内，不要只验证运算结果，而要同时验证参与运算的每个值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">9007199254740993</span>)</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">990</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">9007199254740993</span> - <span class="number">990</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="number">9007199254740993</span> - <span class="number">990</span></span><br><span class="line"><span class="comment">// 返回结果 9007199254740002</span></span><br><span class="line"><span class="comment">// 正确答案应该是 9007199254740003</span></span><br></pre></td></tr></table></figure><p>上面代码中，9007199254740993不是一个安全整数，但是Number.isSafeInteger会返回结果，显示计算结果是安全的。这是因为，这个数超出了精度范围，导致在计算机内部，以9007199254740992的形式储存。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9007199254740993</span> === <span class="number">9007199254740992</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>所以，如果只验证运算结果是否为安全整数，很可能得到错误结果。下面的函数可以同时验证两个运算数和运算结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trusty</span> (<span class="params">left, right, result</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="built_in">Number</span>.isSafeInteger(left) &amp;&amp;</span><br><span class="line">    <span class="built_in">Number</span>.isSafeInteger(right) &amp;&amp;</span><br><span class="line">    <span class="built_in">Number</span>.isSafeInteger(result)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">'Operation cannot be trusted!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trusty(<span class="number">9007199254740993</span>, <span class="number">990</span>, <span class="number">9007199254740993</span> - <span class="number">990</span>)</span><br><span class="line"><span class="comment">// RangeError: Operation cannot be trusted!</span></span><br><span class="line"></span><br><span class="line">trusty(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h3 id="7-Math-对象的扩展"><a href="#7-Math-对象的扩展" class="headerlink" title="7.Math 对象的扩展"></a>7.Math 对象的扩展</h3><p>ES6 在 Math 对象上新增了 17 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用。</p><h4 id="Math-trunc"><a href="#Math-trunc" class="headerlink" title="Math.trunc()"></a>Math.trunc()</h4><p>Math.trunc方法用于去除一个数的小数部分，返回整数部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">4.1</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">4.9</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">-4.1</span>) <span class="comment">// -4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">-4.9</span>) <span class="comment">// -4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">-0.1234</span>) <span class="comment">// -0</span></span><br></pre></td></tr></table></figure><p>对于非数值，Math.trunc内部使用Number方法将其先转为数值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.trunc(<span class="string">'123.456'</span>) <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">true</span>) <span class="comment">//1</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">false</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">null</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>对于空值和无法截取整数的值，返回NaN</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">NaN</span>);      <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="string">'foo'</span>);    <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.trunc();         <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.trunc = <span class="built_in">Math</span>.trunc || <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &lt; <span class="number">0</span> ? <span class="built_in">Math</span>.ceil(x) : <span class="built_in">Math</span>.floor(x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Math-sign"><a href="#Math-sign" class="headerlink" title="Math.sign()"></a>Math.sign()</h4><p>Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。</p><p>它会返回五种值。</p><ul><li>参数为正数，返回+1；</li><li>参数为负数，返回-1；</li><li>参数为 0，返回0；</li><li>参数为-0，返回-0;</li><li>其他值，返回NaN。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.sign(<span class="number">-5</span>) <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="number">5</span>) <span class="comment">// +1</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="number">0</span>) <span class="comment">// +0</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="number">-0</span>) <span class="comment">// -0</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="literal">NaN</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p>如果参数是非数值，会自动转为数值。对于那些无法转为数值的值，会返回NaN。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.sign(<span class="string">''</span>)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="literal">true</span>)  <span class="comment">// +1</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="literal">false</span>)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="literal">null</span>)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="string">'9'</span>)  <span class="comment">// +1</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="string">'foo'</span>)  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.sign()  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="literal">undefined</span>)  <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.sign = <span class="built_in">Math</span>.sign || <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  x = +x; <span class="comment">// convert to a number</span></span><br><span class="line">  <span class="keyword">if</span> (x === <span class="number">0</span> || <span class="built_in">isNaN</span>(x)) &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Math-cbrt"><a href="#Math-cbrt" class="headerlink" title="Math.cbrt()"></a>Math.cbrt()</h4><p>Math.cbrt方法用于计算一个数的立方根。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.cbrt(<span class="number">-1</span>) <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">Math</span>.cbrt(<span class="number">0</span>)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.cbrt(<span class="number">1</span>)  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.cbrt(<span class="number">2</span>)  <span class="comment">// 1.2599210498948734</span></span><br></pre></td></tr></table></figure><p>对于非数值，Math.cbrt方法内部也是先使用Number方法将其转为数值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.cbrt(<span class="string">'8'</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">Math</span>.cbrt(<span class="string">'hello'</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.cbrt = <span class="built_in">Math</span>.cbrt || <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="built_in">Math</span>.pow(<span class="built_in">Math</span>.abs(x), <span class="number">1</span>/<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> x &lt; <span class="number">0</span> ? -y : y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Math-clz32"><a href="#Math-clz32" class="headerlink" title="Math.clz32()"></a>Math.clz32()</h4><p>JavaScript 的整数使用 32 位二进制形式表示，Math.clz32方法返回一个数的 32 位无符号整数形式有多少个前导 0。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">0</span>) <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">1</span>) <span class="comment">// 31</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">1000</span>) <span class="comment">// 22</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">0b01000000000000000000000000000000</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">0b00100000000000000000000000000000</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，0 的二进制形式全为 0，所以有 32 个前导 0；1 的二进制形式是0b1，只占 1 位，所以 32 位之中有 31 个前导 0；1000 的二进制形式是0b1111101000，一共有 10 位，所以 32 位之中有 22 个前导 0。</p><p>clz32这个函数名就来自”count leading zero bits in 32-bit binary representation of a number“（计算一个数的 32 位二进制形式的前导 0 的个数）的缩写。</p><p>左移运算符（&lt;&lt;）与Math.clz32方法直接相关。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">0</span>) <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">1</span>) <span class="comment">// 31</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">1</span> &lt;&lt; <span class="number">1</span>) <span class="comment">// 30</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">1</span> &lt;&lt; <span class="number">2</span>) <span class="comment">// 29</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">1</span> &lt;&lt; <span class="number">29</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>对于小数，Math.clz32方法只考虑整数部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">3.2</span>) <span class="comment">// 30</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="number">3.9</span>) <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><p>对于空值或其他类型的值，Math.clz32方法会将它们先转为数值，然后再计算。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.clz32() <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="literal">NaN</span>) <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="literal">Infinity</span>) <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="literal">null</span>) <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="string">'foo'</span>) <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">Math</span>.clz32([]) <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(&#123;&#125;) <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="literal">true</span>) <span class="comment">// 31</span></span><br></pre></td></tr></table></figure><h4 id="Math-imul"><a href="#Math-imul" class="headerlink" title="Math.imul()"></a>Math.imul()</h4><p>Math.imul方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.imul(<span class="number">2</span>, <span class="number">4</span>)   <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">Math</span>.imul(<span class="number">-1</span>, <span class="number">8</span>)  <span class="comment">// -8</span></span><br><span class="line"><span class="built_in">Math</span>.imul(<span class="number">-2</span>, <span class="number">-2</span>) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>如果只考虑最后 32 位，大多数情况下，Math.imul(a, b)与 (a x b)的结果是相同的，即该方法等同于( a x b )|0的效果（超过 32 位的部分溢出）。之所以需要部署这个方法，是因为 JavaScript 有精度限制，超过 2 的 53 次方的值无法精确表示。这就是说，对于那些很大的数的乘法，低位数值往往都是不精确的，Math.imul方法可以返回正确的低位数值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0x7fffffff</span> * <span class="number">0x7fffffff</span>)|<span class="number">0</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>上面这个乘法算式，返回结果为 0。但是由于这两个二进制数的最低位都是 1，所以这个结果肯定是不正确的，因为根据二进制乘法，计算结果的二进制最低位应该也是 1。这个错误就是因为它们的乘积超过了 2 的 53 次方，JavaScript 无法保存额外的精度，就把低位的值都变成了 0。Math.imul方法可以返回正确的值 1。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.imul(<span class="number">0x7fffffff</span>, <span class="number">0x7fffffff</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h4 id="Math-fround"><a href="#Math-fround" class="headerlink" title="Math.fround()"></a>Math.fround()</h4><p>Math.fround方法返回一个数的32位单精度浮点数形式。</p><p>对于32位单精度格式来说，数值精度是24个二进制位（1 位隐藏位与 23 位有效位），所以对于 -224 至 224 之间的整数（不含两个端点），返回结果与参数本身一致。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.fround(<span class="number">0</span>)   <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">1</span>)   <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">2</span> ** <span class="number">24</span> - <span class="number">1</span>)   <span class="comment">// 16777215</span></span><br></pre></td></tr></table></figure><p>如果参数的绝对值大于 224，返回的结果便开始丢失精度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.fround(<span class="number">2</span> ** <span class="number">24</span>)       <span class="comment">// 16777216</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">2</span> ** <span class="number">24</span> + <span class="number">1</span>)   <span class="comment">// 16777216</span></span><br></pre></td></tr></table></figure><p>Math.fround方法的主要作用，是将64位双精度浮点数转为32位单精度浮点数。如果小数的精度超过24个二进制位，返回值就会不同于原值，否则返回值不变（即与64位双精度值一致）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未丢失有效精度</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">1.125</span>) <span class="comment">// 1.125</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">7.25</span>)  <span class="comment">// 7.25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 丢失精度</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">0.3</span>)   <span class="comment">// 0.30000001192092896</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">0.7</span>)   <span class="comment">// 0.699999988079071</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">1.0000000123</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>对于 NaN 和 Infinity，此方法返回原值。对于其它类型的非数值，Math.fround 方法会先将其转为数值，再返回单精度浮点数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.fround(<span class="literal">NaN</span>)      <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="literal">Infinity</span>) <span class="comment">// Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="string">'5'</span>)      <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="literal">true</span>)     <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="literal">null</span>)     <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.fround([])       <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.fround(&#123;&#125;)       <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.fround = <span class="built_in">Math</span>.fround || <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Float32Array</span>([x])[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Math-hypot"><a href="#Math-hypot" class="headerlink" title="Math.hypot()"></a>Math.hypot()</h4><p>Math.hypot方法返回所有参数的平方和的平方根。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.hypot(<span class="number">3</span>, <span class="number">4</span>);        <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">Math</span>.hypot(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);     <span class="comment">// 7.0710678118654755</span></span><br><span class="line"><span class="built_in">Math</span>.hypot();            <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.hypot(<span class="literal">NaN</span>);         <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.hypot(<span class="number">3</span>, <span class="number">4</span>, <span class="string">'foo'</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.hypot(<span class="number">3</span>, <span class="number">4</span>, <span class="string">'5'</span>);   <span class="comment">// 7.0710678118654755</span></span><br><span class="line"><span class="built_in">Math</span>.hypot(<span class="number">-3</span>);          <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码中，3 的平方加上 4 的平方，等于 5 的平方。</p><p>如果参数不是数值，Math.hypot方法会将其转为数值。只要有一个参数无法转为数值，就会返回 NaN。</p><h4 id="对数方法"><a href="#对数方法" class="headerlink" title="对数方法"></a>对数方法</h4><p>ES6 新增了 4 个对数相关方法。</p><h5 id="（1）-Math-expm1"><a href="#（1）-Math-expm1" class="headerlink" title="（1） Math.expm1()"></a>（1） Math.expm1()</h5><p>Math.expm1(x)返回 e^x - 1，即Math.exp(x) - 1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.expm1(<span class="number">-1</span>) <span class="comment">// -0.6321205588285577</span></span><br><span class="line"><span class="built_in">Math</span>.expm1(<span class="number">0</span>)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.expm1(<span class="number">1</span>)  <span class="comment">// 1.718281828459045</span></span><br></pre></td></tr></table></figure><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.expm1 = <span class="built_in">Math</span>.expm1 || <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.exp(x) - <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="（2）Math-log1p"><a href="#（2）Math-log1p" class="headerlink" title="（2）Math.log1p()"></a>（2）Math.log1p()</h5><p>Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.log1p(<span class="number">1</span>)  <span class="comment">// 0.6931471805599453</span></span><br><span class="line"><span class="built_in">Math</span>.log1p(<span class="number">0</span>)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.log1p(<span class="number">-1</span>) <span class="comment">// -Infinity</span></span><br><span class="line"><span class="built_in">Math</span>.log1p(<span class="number">-2</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p>没有部署这个方法的环境可用如下代码模拟</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.log1p = <span class="built_in">Math</span>.log1p || <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.log(<span class="number">1</span> + x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="（3）Math-log10"><a href="#（3）Math-log10" class="headerlink" title="（3）Math.log10()"></a>（3）Math.log10()</h5><p>Math.log10(x)返回以 10 为底的x的对数。如果x小于 0，则返回 NaN。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.log10(<span class="number">2</span>)      <span class="comment">// 0.3010299956639812</span></span><br><span class="line"><span class="built_in">Math</span>.log10(<span class="number">1</span>)      <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.log10(<span class="number">0</span>)      <span class="comment">// -Infinity</span></span><br><span class="line"><span class="built_in">Math</span>.log10(<span class="number">-2</span>)     <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.log10(<span class="number">100000</span>) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.log10 = <span class="built_in">Math</span>.log10 || <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.log(x) / <span class="built_in">Math</span>.LN10;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="（4）Math-log2"><a href="#（4）Math-log2" class="headerlink" title="（4）Math.log2()"></a>（4）Math.log2()</h5><p>Math.log2(x)返回以 2 为底的x的对数。如果x小于 0，则返回 NaN。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.log2(<span class="number">3</span>)       <span class="comment">// 1.584962500721156</span></span><br><span class="line"><span class="built_in">Math</span>.log2(<span class="number">2</span>)       <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.log2(<span class="number">1</span>)       <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.log2(<span class="number">0</span>)       <span class="comment">// -Infinity</span></span><br><span class="line"><span class="built_in">Math</span>.log2(<span class="number">-2</span>)      <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.log2(<span class="number">1024</span>)    <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">Math</span>.log2(<span class="number">1</span> &lt;&lt; <span class="number">29</span>) <span class="comment">// 29</span></span><br></pre></td></tr></table></figure><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.log2 = <span class="built_in">Math</span>.log2 || <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.log(x) / <span class="built_in">Math</span>.LN2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="8-指数运算符"><a href="#8-指数运算符" class="headerlink" title="8.指数运算符"></a>8.指数运算符</h3><p>ES2016 新增了一个指数运算符（**）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">2</span> <span class="comment">// 4</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">3</span> <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><p><strong>这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相当于 2 ** (3 ** 2)</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">3</span> ** <span class="number">2</span></span><br><span class="line"><span class="comment">// 512</span></span><br></pre></td></tr></table></figure><p>上面代码中，首先计算的是第二个指数运算符，而不是第一个。</p><p>指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1.5</span>;</span><br><span class="line">a **= <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 等同于 a = a * a;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">4</span>;</span><br><span class="line">b **= <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 等同于 b = b * b * b;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，V8 引擎的指数运算符与Math.pow的实现不相同，对于特别大的运算结果，两者会有细微的差异。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">99</span>, <span class="number">99</span>)</span><br><span class="line"><span class="comment">// 3.697296376497263e+197</span></span><br><span class="line"></span><br><span class="line"><span class="number">99</span> ** <span class="number">99</span></span><br><span class="line"><span class="comment">// 3.697296376497268e+197</span></span><br></pre></td></tr></table></figure><p>上面代码中，两个运算结果的最后一位有效数字是有差异的。</p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
          <category> js </category>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>系统学习ES6（变量的解构赋值）</title>
      <link href="/2018/12/12/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0ES6%EF%BC%88%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%EF%BC%89/"/>
      <url>/2018/12/12/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0ES6%EF%BC%88%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="1-数组的解构赋值"><a href="#1-数组的解构赋值" class="headerlink" title="1.数组的解构赋值"></a>1.数组的解构赋值</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><blockquote><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p></blockquote><p>以前的变量赋值都是直接指定值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>ES6里可以写成这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b] = [<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>表示我们可以从数组中提取对应值，按照对应的位置对变量赋值。</p><p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。</p><p>其实这种匹配模式比较好理解，我记得上学的时候有学过一个比较系数法，就是这个意思；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo,[[bar],baz]] = [<span class="number">1</span>,[[<span class="number">2</span>],<span class="number">3</span>]];</span><br><span class="line">foo <span class="comment">// 1;</span></span><br><span class="line">bar <span class="comment">// 2;</span></span><br><span class="line">baz <span class="comment">// 3;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [ , , third] = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>];</span><br><span class="line">third <span class="comment">// "baz"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">head <span class="comment">// 1</span></span><br><span class="line">tail <span class="comment">// [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">'a'</span>];</span><br><span class="line">x <span class="comment">// "a"</span></span><br><span class="line">y <span class="comment">// undefined</span></span><br><span class="line">z <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>如果解构不成功，变量的值就是undefined；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [b] = [];</span><br><span class="line"><span class="keyword">let</span> [a,b] = [];</span><br></pre></td></tr></table></figure><p>上面这两种情况下，b的值都是undefined；</p><p>还有一种情况是不完全解构，就是说等号左右两边不一定一一对应，这样也能解构成功；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x,y] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">x <span class="comment">//1</span></span><br><span class="line">y<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a,[b,c],d] = [<span class="number">1</span>,[<span class="number">2</span>],<span class="number">3</span>]</span><br><span class="line">a <span class="comment">//1</span></span><br><span class="line">b <span class="comment">//2</span></span><br><span class="line">c <span class="comment">//undefined</span></span><br><span class="line">d <span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>上面的情况都属于不完全解构，但是可以成功；</p><p>如果等号右边不是数组的话，会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = &#123;&#125;;</span><br></pre></td></tr></table></figure><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><blockquote><p>解构赋值允许指定默认值</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</span><br><span class="line">foo <span class="comment">//true</span></span><br><span class="line"><span class="keyword">let</span> [x,y = <span class="string">'b'</span>] = [<span class="string">'a'</span>]  <span class="comment">//x = 'a' y = 'b'</span></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>, <span class="literal">undefined</span>]; <span class="comment">// x='a', y='b'</span></span><br></pre></td></tr></table></figure><p><strong>注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。</strong></p><p>上呢判断y等于undefined，默认值生效，y = ‘b’；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>这里x = null，null不严格等于undefined，所以默认值没有生效，x = null；</p><p>如果默认值是一个表达式，那么这个表达式是惰性求值的，也就是说如果要用到的时候才会求值；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'aaa'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [x=f()] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>这里x不用执行f就能取到值，所以函数不会执行，上面的代码等价于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'aaa'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ([<span class="number">1</span>][<span class="number">0</span>] === <span class="literal">undefined</span>)&#123;</span><br><span class="line">  f()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">  x = [<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认值也可以引用解构赋值的其他变量，但是该变量必须被声明；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let [x = 1, y = x] = [];     // x=1; y=1</span><br><span class="line">let [x = 1, y = x] = [2];    // x=2; y=2</span><br><span class="line">let [x = 1, y = x] = [1, 2]; // x=1; y=2</span><br><span class="line">let [x = y, y = 1] = [];     // ReferenceError: y is not defined</span><br></pre></td></tr></table></figure><p>这里又复习了暂时性死区的概念。</p><h3 id="2-对象的解构赋值"><a href="#2-对象的解构赋值" class="headerlink" title="2.对象的解构赋值"></a>2.对象的解构赋值</h3><p>明白了匹配的话对象的解构赋值也就很好理解了；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;name,age&#125; = &#123;<span class="attr">name</span>:<span class="string">'troubledot'</span>,<span class="attr">age</span>:<span class="number">28</span>&#125;</span><br><span class="line">name <span class="comment">//'troubledot'</span></span><br><span class="line">age <span class="comment">// 28</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;age,name&#125; = &#123;<span class="attr">name</span>:<span class="string">'troubledot'</span>,<span class="attr">age</span>:<span class="number">28</span>&#125;</span><br><span class="line">name <span class="comment">//'troubledot'</span></span><br><span class="line">age <span class="comment">// 28</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;sex&#125; = &#123;<span class="attr">name</span>:<span class="string">'troubledot'</span>,<span class="attr">age</span>:<span class="number">28</span>&#125;;</span><br><span class="line">sex <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>不难发现，数组的解构赋值是用索引来匹配的，对象的解构赋值是用key来匹配的；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">name</span>:me&#125; = &#123;<span class="attr">name</span>:<span class="string">'troubledot'</span>&#125;</span><br><span class="line">me <span class="comment">// 'troubledot'</span></span><br></pre></td></tr></table></figure><p>在对象的解构赋值中，对象的属性是一个连通变量和值的桥梁。打个比方就是我的年龄是a，我的年龄是28，那么a = 28，而年龄就是连通a和28的桥梁，年龄是一种<strong>模式</strong>，真正被赋值的不是年龄，而是a；</p><p>嵌套结构的对象也可以解构；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    <span class="string">'Hello'</span>,</span><br><span class="line">    &#123; <span class="attr">y</span>: <span class="string">'World'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x <span class="comment">// "Hello"</span></span><br><span class="line">y <span class="comment">// "World"</span></span><br></pre></td></tr></table></figure><p>这里的p对应的是我的比方里面的年龄，被赋值的不是它而是x和y；</p><p>如果需要对p赋值，应该这样写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    <span class="string">'Hello'</span>,</span><br><span class="line">    &#123; <span class="attr">y</span>: <span class="string">'World'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;p&#125; = obj;</span><br><span class="line"></span><br><span class="line">p <span class="comment">//['Hello',&#123; y: 'World' &#125;]</span></span><br></pre></td></tr></table></figure><p>这里只对p进行了解构，如果我们还是需要x和y的话，需要对x和y再进行解构；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    <span class="string">'Hello'</span>,</span><br><span class="line">    &#123; <span class="attr">y</span>: <span class="string">'World'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;p,<span class="attr">p</span>:[x,&#123;y&#125;]&#125; = obj;</span><br><span class="line"></span><br><span class="line">p <span class="comment">//['Hello',&#123; y: 'World' &#125;]</span></span><br><span class="line">x <span class="comment">// "Hello"</span></span><br><span class="line">y <span class="comment">// "World"</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> node = &#123;</span><br><span class="line">  loc: &#123;</span><br><span class="line">    start: &#123;</span><br><span class="line">      line: <span class="number">1</span>,</span><br><span class="line">      column: <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; loc, <span class="attr">loc</span>: &#123; start &#125;, <span class="attr">loc</span>: &#123; <span class="attr">start</span>: &#123; line &#125;&#125; &#125; = node;</span><br><span class="line">line <span class="comment">// 1</span></span><br><span class="line">loc  <span class="comment">// Object &#123;start: Object&#125;</span></span><br><span class="line">start <span class="comment">// Object &#123;line: 1, column: 5&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码分别对loc，start和line进行了解构；</p><p>看一个对象嵌套赋值的例子；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line">(&#123;<span class="attr">name</span>:obj.name,<span class="attr">age</span>:arr[<span class="number">0</span>]&#125; = &#123;<span class="attr">name</span>:<span class="string">'troubledot'</span>,<span class="attr">age</span>:<span class="number">28</span>&#125;)</span><br><span class="line"><span class="comment">//obj = &#123;name:'troubledot'&#125;</span></span><br><span class="line"><span class="comment">//arr = [28]</span></span><br></pre></td></tr></table></figure><p>对象的解构也可以指定默认值；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;&#125;;</span><br><span class="line">x <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;x, y = <span class="number">5</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;&#125;;</span><br><span class="line">y <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">5</span>&#125;;</span><br><span class="line">y <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">message</span>: msg = <span class="string">'Something went wrong'</span> &#125; = &#123;&#125;;</span><br><span class="line">msg <span class="comment">// "Something went wrong"</span></span><br></pre></td></tr></table></figure><p>同样当对象的属性值严格等于undefined的时候，默认值生效；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line">x <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">null</span>&#125;;</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>null不严格等于undefined，所以x不等于其默认值。</p><p>解构失败，变量的值等于undefined，如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a&#125; = &#123;<span class="attr">b</span>:<span class="number">3</span>&#125;</span><br><span class="line">a <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//报错</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">name</span>:&#123;firstname&#125;&#125; = &#123;<span class="attr">age</span>:<span class="number">28</span>&#125;</span><br></pre></td></tr></table></figure><p>这个报错，我们倒着看的时候会比较好理解；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> me = &#123;<span class="attr">age</span>:<span class="number">28</span>&#125;;</span><br><span class="line">me.name = <span class="literal">undefined</span>;</span><br><span class="line">me.name.firstname <span class="comment">//报错</span></span><br></pre></td></tr></table></figure><p>由于JavaScript 引擎会把大括号包裹的部分视为一个代码块处理，所以我们在对已经声明的对象进行解构的时候需要特别注意，下面这段代码会因为把{a}当作代码块处理而发生语法错误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line">&#123;a&#125; = &#123;<span class="attr">a</span>:<span class="number">20</span>&#125;</span><br><span class="line"><span class="comment">// SyntaxError: syntax error</span></span><br></pre></td></tr></table></figure><p>解决这个问题我们只需要不在行首出现括号就好</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line">(&#123;a&#125; = &#123;<span class="attr">a</span>:<span class="number">20</span>&#125;)</span><br><span class="line"><span class="comment">// SyntaxError: syntax error</span></span><br></pre></td></tr></table></figure><p>解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&#123;&#125; = [<span class="literal">true</span>, <span class="literal">false</span>]);</span><br><span class="line">(&#123;&#125; = <span class="string">'abc'</span>);</span><br><span class="line">(&#123;&#125; = []);</span><br></pre></td></tr></table></figure><p>上面的表达式虽然毫无意义，但是语法是合法的，可以执行。</p><p>对象的解构赋值可以很方便地将现有对象的方法，赋值到某个变量。</p><p>我们可以这么理解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">我：&#123;</span><br><span class="line">  姓名：张三，</span><br><span class="line">  年龄：28，</span><br><span class="line">  性别：男，</span><br><span class="line">  宠物：&#123;</span><br><span class="line">    狗：&#123;</span><br><span class="line">      名字：’薯条‘，</span><br><span class="line">      品种：’金毛‘</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;，</span><br><span class="line">  技能：写js</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 现在有一个王六</span><br><span class="line"> &#123;年龄，性别，技能&#125;  = 我</span><br><span class="line">//我们就知道王六也是个28岁的男性，也会写js 。这里相当于我们解构了年龄性别和技能</span><br><span class="line"></span><br><span class="line">&#123;宠物&#125;  = 我</span><br><span class="line"></span><br><span class="line">// 这样的话我们只解构了宠物这个属性，我们也知道王六有只宠物狗。品种和名字我们都不知道。</span><br><span class="line">&#123;</span><br><span class="line">宠物：&#123;</span><br><span class="line">  狗：&#123;</span><br><span class="line">      名字：’毛毛‘，</span><br><span class="line">      品种：’泰迪‘</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; = 我；</span><br><span class="line">//这样的话我们就知道了王六的狗子是一只叫毛毛的泰迪。</span><br></pre></td></tr></table></figure><p>这是自创的中文编程。</p><p>明白了上面的道理我们就好理解下面的代码了；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; log, sin, cos &#125; = <span class="built_in">Math</span>;</span><br></pre></td></tr></table></figure><p>这里我们给log，sin，cos赋值，分别等于Math.log，Math.sin，Math.cos，这样在使用的时候会比较方便；</p><p>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="number">0</span> : first, [arr.length - <span class="number">1</span>] : last&#125; = arr;</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">last <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h3 id="3-字符串的解构赋值"><a href="#3-字符串的解构赋值" class="headerlink" title="3.字符串的解构赋值"></a>3.字符串的解构赋值</h3><p>我们可以把字符串当作数组来处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">'hello'</span>;</span><br><span class="line">a <span class="comment">// "h"</span></span><br><span class="line">b <span class="comment">// "e"</span></span><br><span class="line">c <span class="comment">// "l"</span></span><br><span class="line">d <span class="comment">// "l"</span></span><br><span class="line">e <span class="comment">// "o"</span></span><br></pre></td></tr></table></figure><p>所以类似数组的对象都有个length属性，我么也可以对其进行解构赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">'hello'</span>;</span><br><span class="line">len<span class="comment">//5</span></span><br></pre></td></tr></table></figure><h3 id="4-数组和布尔值的解构赋值"><a href="#4-数组和布尔值的解构赋值" class="headerlink" title="4.数组和布尔值的解构赋值"></a>4.数组和布尔值的解构赋值</h3><p>解构赋值的时候如果等号右边是布尔值和数值，会先转化为对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line">s === <span class="built_in">Boolean</span>.prototype.toString <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面的这两个例子，toString是一个模式，对s解构赋值的时候我们，需要找123和true的toString属性，他们本身没有toString属性，但是他们的原型有，所以s能取到值；如果改成这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">otherfn</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line">s <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">otherfn</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line">s <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>这里的s就是undefined了，因为123和true都没有ohterfn属性，他们的原型也没有。这样的话下面这个例子就很好理解了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: x &#125; = <span class="literal">undefined</span>; <span class="comment">// TypeError</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: y &#125; = <span class="literal">null</span>; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p>null和undefined不能转换成对象，所以会报错。</p><h3 id="5-函数参数的解构赋值"><a href="#5-函数参数的解构赋值" class="headerlink" title="5.函数参数的解构赋值"></a>5.函数参数的解构赋值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>add的参数是一个数组，但是在执行的时候解构成了变量x和y；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]].map(<span class="function">(<span class="params">[a, b]</span>) =&gt;</span> a + b);</span><br><span class="line"><span class="comment">// [ 3, 7 ]</span></span><br></pre></td></tr></table></figure><p>函数参数的解构也可以使用默认值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, 0]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [0, 0]</span></span><br><span class="line">move(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure><p>上面函数的参数是一个对象，函数执行的时候对参数进行解构，如果解构失败就取默认值。</p><p>注意，下面的写法会得到不一样的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, undefined]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [undefined, undefined]</span></span><br><span class="line">move(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure><p>这里的默认值是参数对象的默认值，不是x和y的默认值。</p><p>move({x: 3}) 的时候其实相当于move({x: 3,y:undefined});</p><p>同理 move({}); // [undefined, undefined]也就很好理解了。</p><p>move()的时候，相当于参数等于undefined，此时取其默认值。 move(); // [0, 0]</p><blockquote><p>undefined会触发函数参数的默认值</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">x = <span class="string">'yes'</span></span>) =&gt;</span> x);</span><br><span class="line"><span class="comment">// [ 1, 'yes', 3 ]</span></span><br></pre></td></tr></table></figure><h3 id="6-圆括号问题"><a href="#6-圆括号问题" class="headerlink" title="6.圆括号问题"></a>6.圆括号问题</h3><p>解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。</p><p>由此带来的问题是，如果模式中出现圆括号怎么处理。ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。</p><p>但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。</p><h4 id="不能使用圆括号的情况"><a href="#不能使用圆括号的情况" class="headerlink" title="不能使用圆括号的情况"></a>不能使用圆括号的情况</h4><p>以下三种情况解构赋值不得使用圆括号</p><h5 id="1-变量声明语句"><a href="#1-变量声明语句" class="headerlink" title="1. 变量声明语句"></a>1. 变量声明语句</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line"><span class="keyword">let</span> [(a)] = [<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">x</span>: (c)&#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> (&#123;<span class="attr">x</span>: c&#125;) = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;(x: c)&#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;(x): c&#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">o</span>: (&#123; <span class="attr">p</span>: p &#125;) &#125; = &#123; <span class="attr">o</span>: &#123; <span class="attr">p</span>: <span class="number">2</span> &#125; &#125;;</span><br></pre></td></tr></table></figure><p>变量声明语句，模式不能使用小括号；</p><h5 id="2-函数参数"><a href="#2-函数参数" class="headerlink" title="2.函数参数"></a>2.函数参数</h5><p>函数参数其实也属于变量声明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[(z</span>)]) </span>&#123; <span class="keyword">return</span> z; &#125;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[z,(x</span>)]) </span>&#123; <span class="keyword">return</span> x; &#125;</span><br></pre></td></tr></table></figure><h5 id="3-赋值语句的模式"><a href="#3-赋值语句的模式" class="headerlink" title="3.赋值语句的模式"></a>3.赋值语句的模式</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line">(&#123; <span class="attr">p</span>: a &#125;) = &#123; <span class="attr">p</span>: <span class="number">42</span> &#125;;</span><br><span class="line">([a]) = [<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line">[(&#123; <span class="attr">p</span>: a &#125;), &#123; <span class="attr">x</span>: c &#125;] = [&#123;&#125;, &#123;&#125;];</span><br></pre></td></tr></table></figure><p>不管是整个模式放在小括号中，还是将部分模式放在小括号中都会报错</p><h4 id="可以使用圆括号的情况"><a href="#可以使用圆括号的情况" class="headerlink" title="可以使用圆括号的情况"></a>可以使用圆括号的情况</h4><p>通过上面我们基本已经清楚可以使用圆括号的情况：</p><blockquote><p>赋值语句的非模式部分可以使用圆括号</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[(b)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br><span class="line">(&#123; <span class="attr">p</span>: (d) &#125; = &#123;&#125;); <span class="comment">// 正确</span></span><br><span class="line">[(<span class="built_in">parseInt</span>.prop)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>这三句都可以执行，我们来看下，第一行模式是数组的第一个元素跟b没关系，所以可以用圆括号，第二行模式是p，所以d用圆括号没有问题，第三行跟第一行是一样的。</p><h3 id="7-用途"><a href="#7-用途" class="headerlink" title="7.用途"></a>7.用途</h3><h4 id="1-交换变量的值"><a href="#1-交换变量的值" class="headerlink" title="(1) 交换变量的值"></a>(1) 交换变量的值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure><p>如果没有解构赋值，我们要交换变量的值需要一个中间量，但是现在可以直接解构赋值。</p><h4 id="（2）从函数返回多个值"><a href="#（2）从函数返回多个值" class="headerlink" title="（2）从函数返回多个值"></a>（2）从函数返回多个值</h4><p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure><h4 id="（3）函数参数的定义"><a href="#（3）函数参数的定义" class="headerlink" title="（3）函数参数的定义"></a>（3）函数参数的定义</h4><p>解构赋值可以方便的将一组参数与变量名对应起来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</span><br><span class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</span><br><span class="line">f(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><h4 id="4）提取-JSON-数据"><a href="#4）提取-JSON-数据" class="headerlink" title="(4）提取 JSON 数据"></a>(4）提取 JSON 数据</h4><p>前后端分离的项目中，我们经常需要提取json数据的值，使用解构赋值会变得特别方便</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">  id: <span class="number">42</span>,</span><br><span class="line">  status: <span class="string">"OK"</span>,</span><br><span class="line">  data: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(id, status, number);</span><br><span class="line"><span class="comment">// 42, "OK", [867, 5309]</span></span><br></pre></td></tr></table></figure><h4 id="（5）函数参数的默认值"><a href="#（5）函数参数的默认值" class="headerlink" title="（5）函数参数的默认值"></a>（5）函数参数的默认值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  async = true,</span></span></span><br><span class="line"><span class="function"><span class="params">  beforeSend = function (</span>) </span>&#123;&#125;,</span><br><span class="line">  cache = <span class="literal">true</span>,</span><br><span class="line">  complete = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  crossDomain = <span class="literal">false</span>,</span><br><span class="line">  global = <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// ... more config</span></span><br><span class="line">&#125; = &#123;&#125;) &#123;</span><br><span class="line">  <span class="comment">// ... do stuff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || ‘default foo’;这样的语句。</p><h4 id="（6）遍历-Map-结构"><a href="#（6）遍历-Map-结构" class="headerlink" title="（6）遍历 Map 结构"></a>（6）遍历 Map 结构</h4><p>任何部署了 Iterator 接口的对象，都可以用for…of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'first'</span>,<span class="string">'hello'</span>);</span><br><span class="line">map.set(<span class="string">'second'</span>,<span class="string">'world'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key,value] <span class="keyword">of</span> map)&#123;</span><br><span class="line">  key +<span class="string">'is'</span>+ value</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br></pre></td></tr></table></figure><p>也可以只取键和值；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'first'</span>,<span class="string">'hello'</span>);</span><br><span class="line">map.set(<span class="string">'second'</span>,<span class="string">'world'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [,value] <span class="keyword">of</span> map)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（7）输入模块的指定方法"><a href="#（7）输入模块的指定方法" class="headerlink" title="（7）输入模块的指定方法"></a>（7）输入模块的指定方法</h4><p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</p><p>某些按需引用的方法也是这个原理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">"source-map"</span>);</span><br><span class="line"><span class="keyword">import</span> &#123; Button, Table &#125; <span class="keyword">from</span> <span class="string">'iview'</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
          <category> js </category>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>你不是一个合格的父亲</title>
      <link href="/2018/12/06/%E4%BD%A0%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%90%88%E6%A0%BC%E7%9A%84%E7%88%B6%E4%BA%B2/"/>
      <url>/2018/12/06/%E4%BD%A0%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%90%88%E6%A0%BC%E7%9A%84%E7%88%B6%E4%BA%B2/</url>
      <content type="html"><![CDATA[<p>老赵属蛇，65了，生活过的并不幸福，甚至有点凄苦。</p><p>15年前母亲走后，家里就剩下我们父子二人了，彼时我还小，没有别人看上去那么懂事，并没有感觉到当时的生活有多苦，现在回想起来，生活最苦也不过如此吧。</p><p>记得印度佛教有苦行僧的说法，而纵观我父亲这一生，真可谓是尝尽人间疾苦。童年赶上自然灾害，命硬没饿死，上学？对不起没有这个预算，有一大家子人等着吃饭呢，18岁成年之后就担负起了养活十几口子的重任，到了结婚的年纪了，妻子勤劳善良，且不说洗衣做饭是一把好手，哪怕去工地干活也不比大小伙子差多少，小儿子出生以后，日子虽然苦，但是凭借两个人的努力，生活已经有了起色，自己修了房子，老大也快上大学了，用家里的28自行车驮回来了村里的第一台大彩电，后面甚至还有了一点存款，谁能想到，好景不长，随着妻子一病好几年，那点积蓄在医院里简直杯水车薪，但是即使是负债累累也要给发妻治病，家徒四壁也不能让儿子们辍学，没钱了就去借，只要有一口气早晚会翻身，然而生活跟电影不一样的地方就在于，现实并不是很喜欢那种坚持就是胜利的戏码。母亲病了好几年，我的父亲忍受着各种各样的冷眼，经济和心理的双重压力让他没有功夫去伤春悲秋，后来，他自己的母亲走了，第二年他父亲也走了，然后是自己的妻子，现在想想，母亲的故去对他来说又何尝不是一种解脱呢。</p><p>现在想到这些，我感觉父亲没疯没颓废已经胜过好多人了。</p><p>我经常在想，人的意志、信念到底是什么样子的存在。看看我父亲，他为人父的责任感和对自己亡妻的承诺是他如此负重前行的源动力。 毫不夸张，母亲走后他就再没有为自己活过一天了，好多写宠物的文章里面提到，我们的生活里有各种消遣娱乐，但是宠物的生活里面只有主人。每次读到这种论调，我第一个想到的就是我的老父亲，现在我们兄弟俩就是他的全部，我们俩都遗传到了母亲的病，他是亲眼看着母亲没了的，虽然我们现在不会有大问题，但是我知道他在想什么，特别担心我们的身体状况，那是一种恨不能用自己来替代的关心。</p><p>他自己的身体本来就不好，年纪大了免疫力又弱，特别容易感冒，又有高血压，但是他从来不把这些当回事，最常说的一句话就是我你不用操心。可我怎么可能不操心呢。</p><p>说实话这种关怀有时候真的让人心疼，我多希望他能像有些老人一样有点私心，为自己好好活一下。</p><p>有好多同事聊起来说自己的母亲沉迷广场舞很闹心，自己的父亲沉迷门球啥的都不做饭。我其实真的特别羡慕。他喜欢打打牌，输赢不到20块钱的那种，记忆里母亲还健康的时候，因为这个他没少被数落，农闲的时候一玩就是一通宵，赢了厚厚一沓钱，当然都是1毛的纸币，母亲在骂，他在乐。。现在想想这就是我父母的爱情吧。</p><p>现在没人管束了，打牌的乐趣好像也没有以前那么多了，不过这也是他仅有的一点自己的兴趣爱好，但是现在这个爱好给他带来的快乐好像在慢慢减退，我很担心，等他再老一点，如果生活中真的再没有什么乐趣的时候，一个人待在那么大的院子里，真的每一分钟都是煎熬。</p><p>我经常在想，以后我会成为一个怎样的父亲，首先我自己是一个独立的个体，其次才扮演父亲，丈夫，子女等等角色。而我的父亲，在我的记忆里，他的生活就是为了别人，自己的父母，自己的妻子，自己的儿子们。。更可怕的是他已经完全适应了这个节奏，将我们养大成人，为我们的琐事操心已经变成了吃饭睡觉般稀松平常，出了一辈子苦力，现在生活已经不需要他在拼搏了，他感受到的不是轻松，反倒是更大的负罪感，他一直因为不能给我和我哥好的生活而愧疚，一直为不能给我准备好婚房而愧疚，一直为不能给我的生活给予帮助而愧疚，可是他不知道曾经那么艰难的日子我们都没有辍学，我们没有比别人吃的差，穿的差。这一切都是他的功劳，这个恩情我们兄弟俩注定无以为报了。我想过好多的办法为了让他过得轻松一点，想给他样条狗，没事带着溜达溜达，也算有个念想，他说：我连自己都照顾不好你还想让我再养个狗。好吧，想让他发展个啥兴趣爱好，但他感觉是不务正业，气得我呀，都这把年纪了就不能享受下退休生活吗？我曾经苦口婆心的跟他说过，他过得轻松了我们在外面也会轻松，我们不求他能挣多少钱，只求他能开开心心、健健康康的，道理都能懂，但是劳碌一生的他也确实做不到如此心宽体胖。</p><p>我常常在想，他的确不能算得上一个合格的父亲，你心疼子女满怀愧疚的无私奉献，但是这一切都是基于你的身体和心理的压力的，长此以往，我们互相愧疚，我们感觉自己不孝不能让你省心，你感觉对不起我们没给我们好的物质条件，有时候我都在想，如果我不会想这么多，心安理得的接受你的好，不再把你的这份愧疚当回事，或许也能找到一种平衡，但是如果真的这样做了，那你对我们穷尽一生的付出和教育岂不是像一个笑话。</p><p>当然，农村的大环境对人的影响也很大，在我们老家，为人父母一生的目标基本就是养大子女帮子女准备好物质条件结婚生子，然后带孙子，等哪天身体扛不住了，这一生也便到尽头了，没有退休也没有养老，人人都是如此。大家都在犯错的时候，对的那个人就会显得特别突兀，自然也会受到排挤。一直想把父亲接出来，体验下没有闲言碎语的环境，尝试一下更加轻松的活法。如果顺利的话，或许我们今年可以一起在外面过年。</p><p>事实上，你来心安理得的接受我们的好，心安理得的享受轻松的老年生活才更符合逻辑，毕竟你要知道你是老子啊。</p>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 父亲 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>系统学习ES6（let和const命令）</title>
      <link href="/2018/12/03/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0ES6%E4%B8%80/"/>
      <url>/2018/12/03/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0ES6%E4%B8%80/</url>
      <content type="html"><![CDATA[<h3 id="1、let命令"><a href="#1、let命令" class="headerlink" title="1、let命令"></a>1、let命令</h3><h4 id="let基本用法"><a href="#let基本用法" class="headerlink" title="let基本用法"></a>let基本用法</h4><p>ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">a  <span class="comment">// 1</span></span><br><span class="line">b  <span class="comment">// ReferenceError: a is not defined.</span></span><br></pre></td></tr></table></figure><p>以上分别用var和let声明了变量a和b，输出b的时候会报错，因为let声明的变量只有在let所在的代码块内有效。</p><p>for循环其实就比较适合用let。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">i <span class="comment">// ReferenceError: i is not defined.</span></span><br></pre></td></tr></table></figure><p>这里就比较符合我们的预期：i应该只有在for循环内部起作用；<br>如果换成var,输出i的时候就是10；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">i <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>这里的i是var声明的，在全局范围内有效，所以会输出最后一轮的i；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">2</span>]()   <span class="comment">//10</span></span><br></pre></td></tr></table></figure><p>这段代码里面a是一个数组，这个数组是由10个funcion组成的，像这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a <span class="comment">// [console.log(i),console.log(i),console.log(i),console.log(i),console.log(i),console.log(i),console.log(i),console.log(i),console.log(i),console.log(i)]</span></span><br></pre></td></tr></table></figure><p>我们会发现这里的i好像跟前面那个例子里面的i是一样的，其实函数里面console的这个i一直是一个东西，就是那个在全局声明的i，所以会输出最后一轮的i；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">2</span>]()   <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>如果换成let就会变成2了，怎么理解呢，let声明的变量只在当前这一轮循环中有用，也就是说，每次进入循环都会声明一次i，而不是像var那样直接取全局的变量。这样解释的话会有个疑问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？</p><blockquote><p>这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。</p></blockquote><p>另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">'abc'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br></pre></td></tr></table></figure><p>这段代码，第一次循环完成的时候，i被赋值为字符串’abc’，’abc’小于3为false，不满足循环条件，循环应该就结束了。但是事实上依然进了循环。这就很好的印证了上面的结论：</p><blockquote><p>函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。</p></blockquote><h4 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h4><p>所谓的变量提升，就是说对于一个变量，如果在声明之前使用它的话，会有个默认值undefined；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span> ;</span><br></pre></td></tr></table></figure><p>这样容易有一些不确定因素在里面，比如看到一个undefined，它有可能是变量提升的，还有可能它是被我们赋值的undefined；<br>而使用let的时候呢</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// Uncaught ReferenceError: a is not defined</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>显然这样更加符合逻辑，这个报错的意义也更加明确。<br>所以我感觉let不存在变量提升倒是比较规范的地方，规则越严谨，不确定因素越少。</p><h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><p>只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。</p><p>ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p><blockquote><p>总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p></blockquote><p>明白了这个道理，下面这段代码也就很好理解了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// TDZ开始</span></span><br><span class="line">  tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> tmp; <span class="comment">// TDZ结束</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">  tmp = <span class="number">123</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tmp在声明前都是其死区，所以一直报错；</p><p>这里我们需要注意一下typeof命令。如果没有用到let的话，typeof随便用；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> undeclared_variable <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure><p>这里的 undeclared_variable 没有被声明过，我们也可以用tpyeof，返回undefined；</p><p>但是如果用到let呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> a <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">'troubledot'</span></span><br></pre></td></tr></table></figure><p>现在我们知道<strong>暂时性死区</strong>这个概念了就很好理解了，typeof位于a的暂时性死区内，所以报错也就自然而然了。</p><blockquote><p>在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。</p></blockquote><p>还有一些比较隐蔽的死区不太容易发现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x = y, y = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>执行函数bar的时候，给x赋值y，但是y并没有声明，也就是说我们在y的暂时性死区使用了它，所以会报错。说白了咱们认死理就好</p><blockquote><p>先声明，再使用</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x = <span class="number">2</span>, y = x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">bar(); <span class="comment">// [2,2]</span></span><br></pre></td></tr></table></figure><p>使用x之前已经声明过x了，所以不会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">var</span> x = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> x = x;</span><br><span class="line"><span class="comment">// ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure><p>上面这种情况也比较有意思，其实我们要理解这个只需要明白变量的声明是 ‘let x = x’这句执行完以后才完成的。也就是说，在执行这一句的过程中遇到了x这样一个变量，此时因为赋值语句还没有执行完，所以这里也算是x的暂时性死区，当然就会报错了。</p><h4 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h4><blockquote><p>let不允许在相同作用域内，重复声明同一个变量。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们注意到，只要用到了let就不能有重复声明，不管重复的变量是不是用let声明的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arg; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能在函数内部重复声明参数，但是下面这种不会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> arg; <span class="comment">// 不报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回忆一下最开始的时候说的，let只在let命令所在的代码块内有效。</p><h3 id="2、块级作用域"><a href="#2、块级作用域" class="headerlink" title="2、块级作用域"></a>2、块级作用域</h3><p>通过对let的了解，看得出来let位JavaScript新增了块级作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(n); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子能够很好的帮我吗理解块级作用域，let声明的变量，只在自己的作用域内有效，代码块外层不会收到内层的影响。<br>ES6 允许块级作用域的任意嵌套。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;&#123;<span class="keyword">let</span> insane = <span class="string">'Hello World'</span>&#125;&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure><p>上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  &#123;<span class="keyword">let</span> insane = <span class="string">'Hello World'</span>&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(insane); <span class="comment">// 报错</span></span><br><span class="line">&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure><p>外层读取不到内存定义的变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  <span class="keyword">let</span> insane = <span class="string">'Hello World'</span>;</span><br><span class="line">  &#123;<span class="keyword">let</span> insane = <span class="string">'Hello World'</span>&#125;</span><br><span class="line">&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure><p>内层作用域可以定义外层作用域内的同名变量。</p><p>我们知道，立即执行函数就是为了隔离作用域，避免变量污染，所以块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IIFE 写法</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 块级作用域写法</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h4><p>函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题。</p><p>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种情况，根据es5的规定，都是非法的。<br>但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。</p><p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 重复声明一次函数f</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>上面代码在 ES5 中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>ES6 就完全不一样了，理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响。但是，如果你真的在 ES6 浏览器中运行一下上面的代码，是会报错的，这是为什么呢？</p><p>原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。</p><ul><li>允许在块级作用域内声明函数。</li><li>函数声明类似于var，即会提升到全局作用域或函数作用域的头部。</li><li>同时，函数声明还会提升到所在的块级作用域的头部。</li></ul><p>注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。</p><p>根据这三条规则，在浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器的 ES6 环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 重复声明一次函数f</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure><p>上面的代码在符合 ES6 的浏览器中，都会报错，因为实际运行的是下面的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 浏览器的 ES6 环境</span><br><span class="line">function f() &#123; console.log(&apos;I am outside!&apos;); &#125;</span><br><span class="line">(function () &#123;</span><br><span class="line">  var f = undefined;</span><br><span class="line">  if (false) &#123;</span><br><span class="line">    function f() &#123; console.log(&apos;I am inside!&apos;); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line">// Uncaught TypeError: f is not a function</span><br></pre></td></tr></table></figure><p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明语句</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">'secret'</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">'secret'</span>;</span><br><span class="line">  <span class="keyword">let</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，还有一个需要注意的地方。ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="3-const命令"><a href="#3-const命令" class="headerlink" title="3.const命令"></a>3.const命令</h3><h4 id="const基本用法"><a href="#const基本用法" class="headerlink" title="const基本用法"></a>const基本用法</h4><p>const声明一个只读的常量。一旦声明，常量的值就不能改变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.1415</span>;</span><br><span class="line">PI <span class="comment">// 3.1415</span></span><br><span class="line"></span><br><span class="line">PI = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure><p>改变const声明的PI的值就会报错。</p><p>const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo;</span><br><span class="line"><span class="comment">// SyntaxError: Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure><p>只声明不赋值就会报错。<br>其他的地方，const和let一样，不能重复声明，存在暂时性死区，只能在声明以后再使用。</p><h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 foo 添加一个属性，可以成功</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br><span class="line">foo.prop <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 foo 指向另一个对象，就会报错</span></span><br><span class="line">foo = &#123;&#125;; <span class="comment">// TypeError: "foo" is read-only</span></span><br></pre></td></tr></table></figure><p>这里的foo是一个对象，它存储的其实是一个地址，这个地址指向一个对象。对象本身可以改变的，所以我们给他添加一个属性的时候没有报错，但是如果改变了指向的话，就会报错了。</p><p>对象是这样，数组也是。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [];</span><br><span class="line">a.push(<span class="string">'Hello'</span>); <span class="comment">// 可执行</span></span><br><span class="line">a.length = <span class="number">0</span>;    <span class="comment">// 可执行</span></span><br><span class="line">a = [<span class="string">'Dave'</span>];    <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>当然，有时候或许我们还真的需要这种功能，就是真正的让对象都不能变化，我们可以使用Object.freeze方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规模式时，下面一行不起作用；</span></span><br><span class="line"><span class="comment">// 严格模式时，该行会报错</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>这里的foo指向一个冻结的对象Object，所以添加新属性不起作用，严格模式时还会报错。</p><p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> constantize = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach( <span class="function">(<span class="params">key, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span> ) &#123;</span><br><span class="line">      constantize( obj[key] );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="ES6声明变量的6种方法"><a href="#ES6声明变量的6种方法" class="headerlink" title="ES6声明变量的6种方法"></a>ES6声明变量的6种方法</h4><p>ES5声明变量只有var和function两种命令；ES6中除了这两种，还有四种：我们前面提到的let、const，还有import和class命令；</p><h3 id="4-顶层对象的属性"><a href="#4-顶层对象的属性" class="headerlink" title="4.顶层对象的属性"></a>4.顶层对象的属性</h3><p>顶层对象，在浏览器环境指的是window对象，在node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.a = <span class="number">1</span>;</span><br><span class="line">a. <span class="comment">// 1</span></span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>也就是所有我们定义的全局变量，都可以看作是顶层对象的属性；也就是说上面的顶层对象的属性赋值和全局变量的赋值其实是同一件事情。</p><p>顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</p><p>ES6 为了改变这一点：</p><ul><li>一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；</li><li>另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果在 Node 的 REPL 环境，可以写成 global.a</span></span><br><span class="line"><span class="comment">// 或者采用通用方法，写成 this.a</span></span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">window</span>.b <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>这里var声明的全局变量a就是顶层对象的属性，而用let声明的b则不是。</p><h3 id="5-global对象"><a href="#5-global对象" class="headerlink" title="5.global对象"></a>5.global对象</h3><p>ES5 的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。</p><ul><li>浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。</li><li>浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。</li><li>Node 里面，顶层对象是global，但其他环境都不支持。</li></ul><p>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。</p><ul><li>全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块。</li><li>函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。</li><li>不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么eval、new Function这些方法都可能无法使用。</li></ul><p>也就是说，我们的js代码有可能因为换了执行环境就出错了<br>综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">(<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span></span><br><span class="line">    ? <span class="built_in">window</span></span><br><span class="line">    : (<span class="keyword">typeof</span> process === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">      <span class="keyword">typeof</span> <span class="built_in">require</span> === <span class="string">'function'</span> &amp;&amp;</span><br><span class="line">      <span class="keyword">typeof</span> global === <span class="string">'object'</span>)</span><br><span class="line">      ? global</span><br><span class="line">      : <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">var</span> getGlobal = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> self; &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> <span class="built_in">window</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> global !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> global; &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'unable to locate global object'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有点猥琐。。</p><p>现在有一个提案，在语言标准的层面，引入global作为顶层对象。也就是说，在所有环境下，global都是存在的，都可以从它拿到顶层对象。</p><p>垫片库system.global模拟了这个提案，可以在所有环境拿到global。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS 的写法</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'system.global/shim'</span>)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 模块的写法</span></span><br><span class="line"><span class="keyword">import</span> shim <span class="keyword">from</span> <span class="string">'system.global/shim'</span>; shim();</span><br></pre></td></tr></table></figure><p>上面代码可以保证各种环境里面，global对象都是存在的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS 的写法</span></span><br><span class="line"><span class="keyword">var</span> global = <span class="built_in">require</span>(<span class="string">'system.global'</span>)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 模块的写法</span></span><br><span class="line"><span class="keyword">import</span> getGlobal <span class="keyword">from</span> <span class="string">'system.global'</span>;</span><br><span class="line"><span class="keyword">const</span> global = getGlobal();</span><br></pre></td></tr></table></figure><p>上面代码将顶层对象放入变量global。</p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
          <category> js </category>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ztree的自定义编辑</title>
      <link href="/2018/08/29/ztree%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%96%E8%BE%91/"/>
      <url>/2018/08/29/ztree%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%96%E8%BE%91/</url>
      <content type="html"><![CDATA[<p>组织架构树是项目中特别常见的一类组件，我一般都用<a href="http://www.ztree.me/" target="_blank" rel="noopener">ztree</a>，前两天又用到这个，不过需求跟平时有点区别，我感觉也算比较常见，就把他稍微整理一下。</p><p>需求大致是这样：一个普通的树结构，点击编辑。</p><p><img src="http://res.troubledot.cn/edit.png" alt="图1"></p><p>会弹出来操作按钮，而且并不是所有用户都有增删改的权限，对该节点不具备的权限会置灰，如下图所示。</p><p><img src="http://res.troubledot.cn/WX20180830-122042@2x.png" alt="图2"></p><p>我们知道ztree是带编辑功能的，但是长这样子</p><p><img src="http://res.troubledot.cn/ztree.png" alt="图3"></p><p>而且ztree的官方demo的编辑按钮是在鼠标hover到节点以后才弹出来的，显然跟我们的需求不符合。我看了下代码，发现删除和编辑用的是这两个API</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">editName(node)    <span class="comment">//参数为要操作的节点</span></span><br><span class="line">removeNode (node, callbackFlag) <span class="comment">//参数为要操作的节点</span></span><br></pre></td></tr></table></figure><p>鼠标的hover其实不是伪类:hover,而是调用了 addHoverDom 和 removeHoverDom这两个API，目的是拿到要操作的节点。再看我们的需求，发现我们需要所有的节点（ztree对象的getNodes()方法可以拿到所有节点），因为我们需要让每个节点的操作按钮都显示出来。<br>基本思路：遍历所有节点，然后操作该节点对应的dom，拼接操作按钮图标（这里需要判断是否有权限，根据权限拼接不同的图标），再给按钮绑定事件，调用对应操作的API；</p><p> 代码如下，因为还有地方要调用，所以我将其封装成了方法</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">addnewBtn</span>(<span class="params">nodeList</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newCount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> zTree = $.fn.zTree.getZTreeObj(<span class="string">"tree"</span>);</span><br><span class="line">    nodeList.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">element, index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> sObj = $(<span class="string">"#"</span> + element.tId + <span class="string">"_span"</span>);</span><br><span class="line">        <span class="keyword">if</span> (zTree.setting.edit.enable) &#123;     <span class="comment">//判断当前是否可以编辑</span></span><br><span class="line">            <span class="keyword">var</span> addable = (element.addable == <span class="literal">undefined</span>) || (element.addable == <span class="literal">true</span>) ? <span class="string">"addable"</span> : <span class="string">""</span>; <span class="comment">//新增权限 权限增加了一个able的标记，根据class取不同图片，下面绑定事件也是绑在该class上 下同</span></span><br><span class="line">            <span class="keyword">var</span> editable = (element.editable == <span class="literal">undefined</span>) || (element.editable == <span class="literal">true</span>) ? <span class="string">"editable"</span> : <span class="string">""</span>;   <span class="comment">//编辑权限</span></span><br><span class="line">            <span class="keyword">var</span> removeable = (element.removeable == <span class="literal">undefined</span>) || (element.removeable == <span class="literal">true</span>) ? <span class="string">"removeable"</span> : <span class="string">""</span>;  <span class="comment">//删除权限</span></span><br><span class="line">            <span class="keyword">if</span> (element.editNameFlag || $(<span class="string">"#addBtn_"</span> + element.tId).length &gt; <span class="number">0</span> || $(<span class="string">"#remove_"</span> + element.tId).length &gt; <span class="number">0</span> || $(<span class="string">"#edit_"</span> + element.tId).length &gt; <span class="number">0</span>) <span class="keyword">return</span>;  <span class="comment">//有按钮就不再加了</span></span><br><span class="line">            <span class="keyword">var</span> addStr = <span class="string">"&lt;span class='button add "</span> + addable + <span class="string">"' id='addBtn_"</span> + element.tId +</span><br><span class="line">                <span class="string">"' title='add node' onfocus='this.blur();'&gt;&lt;/span&gt;"</span>; <span class="comment">//添加按钮</span></span><br><span class="line">            <span class="keyword">var</span> editStr = <span class="string">"&lt;span class='button edit "</span> + editable + <span class="string">"' id='edit_"</span> + element.tId +<span class="string">"' title='rename' onfocus='this.blur();'&gt;&lt;/span&gt;"</span>; <span class="comment">//编辑按钮</span></span><br><span class="line">            <span class="keyword">var</span> delStr = <span class="string">"&lt;span class='button remove "</span> + removeable + <span class="string">"' id='remove_"</span> + element.tId + <span class="string">"' title='remove' onfocus='this.blur();'&gt;&lt;/span&gt;"</span>; <span class="comment">//删除按钮</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">allstr</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> allstr;</span><br><span class="line">                <span class="keyword">if</span> (element.isParent) &#123;</span><br><span class="line">                    allstr = addStr + editStr + delStr;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    allstr = editStr + delStr;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> allstr;</span><br><span class="line">            &#125;   <span class="comment">// 子节点不需要新增按钮</span></span><br><span class="line">            sObj.after(allstr()); <span class="comment">//拼接html</span></span><br><span class="line">            <span class="keyword">if</span> ((element.addable == <span class="literal">undefined</span>) || (element.addable == <span class="literal">true</span>)) &#123;</span><br><span class="line">                <span class="keyword">var</span> btn = $(<span class="string">"#addBtn_"</span> + element.tId);  <span class="comment">//取到有权限的添加按钮</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (btn) btn.bind(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  <span class="comment">//给添加按钮绑定事件</span></span><br><span class="line">                <span class="keyword">var</span> newnode = zTree.addNodes(element, &#123; <span class="attr">id</span>: (<span class="number">100</span> + newCount), <span class="attr">pId</span>: element.id, <span class="attr">name</span>: <span class="string">"new node"</span> + (newCount++), <span class="attr">isParent</span>: <span class="literal">true</span> &#125;, <span class="literal">true</span>); <span class="comment">//新增文件夹（默认新增的是文件 需求有点怪😂）</span></span><br><span class="line">                <span class="keyword">var</span> tId = newnode[<span class="number">0</span>].tId; <span class="comment">//添加的节点  获取这个是因为添加的是文件夹 所以他还能继续添加</span></span><br><span class="line">                <span class="keyword">var</span> nStr = <span class="string">"&lt;span class='button add addable' id='addBtn_"</span> + tId + <span class="string">"' title='add node' onfocus='this.blur();'&gt;&lt;/span&gt;&lt;span class='button edit editable' id='edit_"</span> + tId + <span class="string">"' title='rename' onfocus='this.blur();'&gt;&lt;/span&gt;&lt;span class='button remove removeable' id='remove_"</span> + tId + <span class="string">"' title='remove' onfocus='this.blur();'&gt;&lt;/span&gt;"</span>; </span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> nobj = $(<span class="string">"#"</span> + tId + <span class="string">"_span"</span>).after(nStr); <span class="comment">//给添加的节点后面加操作按钮</span></span><br><span class="line">                <span class="keyword">var</span> nbtn = $(<span class="string">"#addBtn_"</span> + tId);</span><br><span class="line">                nbtn.bind(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  <span class="comment">//给添加的节点上的添加按钮绑定事件</span></span><br><span class="line">                    <span class="comment">/* Act on the event */</span></span><br><span class="line">                    zTree.addNodes(newnode[<span class="number">0</span>], &#123; <span class="attr">id</span>: (<span class="number">1000</span> + newCount), <span class="attr">pId</span>: newnode[<span class="number">0</span>].id, <span class="attr">name</span>: <span class="string">"new node"</span> + (newCount++), <span class="attr">isParent</span>: <span class="literal">true</span> &#125;, <span class="literal">true</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们发现增和删、改是有区别的。 其实比较好理解，删和改我们只需要知道操作的对象就可以了，但是添加的时候我们还需要知道添加的内容。  </p><p>这里需要注意一下，咱们添加的这几个操作按钮只对展开的节点有用，也就是说当我们点击编辑以后，展开那些一开始没有展开的节点，发现他们的子节点是没有操作按钮的，显然这是不符合我们需求的。最简单的办法，用节点展开的回调函数onExpand，展开节点的时候给他所有的子节点添加按钮，这也是我封装addnewBtn的主要原因</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">zTreeOnExpand</span>(<span class="params">event, treeId, treeNode</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> treeObj = $.fn.zTree.getZTreeObj(<span class="string">"tree"</span>);</span><br><span class="line">    <span class="keyword">var</span> nodes = treeObj.getNodesByFilter(filter,<span class="literal">false</span>,treeNode); <span class="comment">// 查找子节点集合</span></span><br><span class="line">    addnewBtn(nodes);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面就剩下编辑和删除了，我们前面只是拼了个按钮上去，并没有做功能，代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> operateNode;  <span class="comment">//定义一个变量存当前操作的节点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">zTreeOnClick</span>(<span class="params">event, treeId, treeNode</span>) </span>&#123;</span><br><span class="line">    operateNode = treeNode;  <span class="comment">//获取当前操作的节点存入 operateNode</span></span><br><span class="line">&#125;;</span><br><span class="line">$(<span class="built_in">document</span>).on(<span class="string">'click'</span>, <span class="string">'.button.edit.editable'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;  <span class="comment">//事件绑定到editable 上是为了区分权限 下同</span></span><br><span class="line">    <span class="keyword">var</span> treeObj = $.fn.zTree.getZTreeObj(<span class="string">"tree"</span>);</span><br><span class="line">    treeObj.editName(operateNode);    <span class="comment">// 编辑节点</span></span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="built_in">document</span>).on(<span class="string">'click'</span>, <span class="string">'.button.remove.removeable'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> treeObj = $.fn.zTree.getZTreeObj(<span class="string">"tree"</span>);</span><br><span class="line">    treeObj.removeNode(operateNode);   <span class="comment">// 删除节点</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里只是部分代码，<a href="https://github.com/Troubledot/Common-components" target="_blank" rel="noopener">完整的代码在这里</a>，自己整理的很简单的东西，如果运气好能帮到别人，那就太棒了。</p>]]></content>
      
      <categories>
          
          <category> 组件整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ztree </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>编译原理学习笔记--引论</title>
      <link href="/2018/08/06/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%BC%95%E8%AE%BA/"/>
      <url>/2018/08/06/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%BC%95%E8%AE%BA/</url>
      <content type="html"><![CDATA[<blockquote><p>想花点时间系统学习下计算机基础，我会把编译原理里面的习题和自己的一些笔记在这整理一下。</p></blockquote><h3 id="引论"><a href="#引论" class="headerlink" title="引论"></a>引论</h3><h4 id="1-1-语言处理器"><a href="#1-1-语言处理器" class="headerlink" title="1.1 语言处理器"></a>1.1 语言处理器</h4><p>编译器：一个编译器就是一个程序，它可以阅读以某一种语言（源语言）编写的程序，并把该程序翻译成为一个等价的、用另一种语言（目标语言）编写的程序。<strong>编译器的重要任务之一是报告它在翻译过程中发现的源程序中的错误</strong>。</p><p>如果目标程序是一个可执行的机器语言程序，那么他就可以被用户调用，处理输入并产生输出。</p><p>解释器：解释器是另一种常见的语言处理器。<strong>它并不通过翻译的方式生成目标程序</strong>。从用户的角度看，解释器直接利用用户提供的输入执行源程序中指定的操作。</p><p>在把用户输入映射成输出的过程中，由一个编译器产生的机器语言目标程序通常比一个解释器快很多。然而解释器的错误诊断效果通常比编译器更好，因为它逐个语句的执行源程序。</p><h5 id="习题1-1-1：编译器和解释器之间的区别是什么"><a href="#习题1-1-1：编译器和解释器之间的区别是什么" class="headerlink" title="习题1.1.1：编译器和解释器之间的区别是什么"></a>习题1.1.1：编译器和解释器之间的区别是什么</h5><p>编译器就是一个程序，它可以阅读以某一种语言（源语言）编写的程序，并把该程序翻译成一个等价的、用另一种语言（目标语言）编写的程序，而解释器不是通过翻译的方式生成目标程序的，用户的角度来看解释器是直接利用用户提供的输入执行源程序中指定的操作的。</p><h5 id="习题1-1-2：编译器相对于解释器的优点是什么？解释器相对于编译器的优点是什么"><a href="#习题1-1-2：编译器相对于解释器的优点是什么？解释器相对于编译器的优点是什么" class="headerlink" title="习题1.1.2：编译器相对于解释器的优点是什么？解释器相对于编译器的优点是什么"></a>习题1.1.2：编译器相对于解释器的优点是什么？解释器相对于编译器的优点是什么</h5><p>在把用户输入映射成输出的过程中，由编译器产生的机器语言目标程序比解释器快很多，但是解释器的错误诊断效果比编译器更好，因为它逐个语句的执行源程序。</p><h5 id="习题1-1-3：在一个语言处理系统中，编译器产生汇编语言而不是机器语言的好处是什么"><a href="#习题1-1-3：在一个语言处理系统中，编译器产生汇编语言而不是机器语言的好处是什么" class="headerlink" title="习题1.1.3：在一个语言处理系统中，编译器产生汇编语言而不是机器语言的好处是什么"></a>习题1.1.3：在一个语言处理系统中，编译器产生汇编语言而不是机器语言的好处是什么</h5><p>因为汇编语言比较容易输出和调试。</p><h5 id="习题1-1-4-把一种高级语言翻译成另一种高级语言的编译器称为源到源（source-to-sourc）的翻译器，编译器使用c语言作为目标语言有什么好处"><a href="#习题1-1-4-把一种高级语言翻译成另一种高级语言的编译器称为源到源（source-to-sourc）的翻译器，编译器使用c语言作为目标语言有什么好处" class="headerlink" title="习题1.1.4:把一种高级语言翻译成另一种高级语言的编译器称为源到源（source-to-sourc）的翻译器，编译器使用c语言作为目标语言有什么好处"></a>习题1.1.4:把一种高级语言翻译成另一种高级语言的编译器称为源到源（source-to-sourc）的翻译器，编译器使用c语言作为目标语言有什么好处</h5><p>就好比为什么编译器要产生汇编语言而是不是机器语言一样，C语言更简单更常用更加容易理解，同样方便调试和输出。</p><h5 id="习题1-1-5-描述一下汇编器所要完成的任务"><a href="#习题1-1-5-描述一下汇编器所要完成的任务" class="headerlink" title="习题1.1.5 描述一下汇编器所要完成的任务"></a>习题1.1.5 描述一下汇编器所要完成的任务</h5><p>汇编器就类似于编译器，只是它的源语言不是高级语言而是汇编语言。同样，它需要一个预处理器进行预处理，如聚合文件，展开宏等。写成的机器语言也要类似与连接器和加载器的程序，完成类似的工作。</p><h5 id="习题1-6-1-对照下面的c代码，指出赋给w，x，y，和z的值"><a href="#习题1-6-1-对照下面的c代码，指出赋给w，x，y，和z的值" class="headerlink" title="习题1.6.1 对照下面的c代码，指出赋给w，x，y，和z的值"></a>习题1.6.1 对照下面的c代码，指出赋给w，x，y，和z的值</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> w, x, y, z;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">4</span> ; <span class="keyword">int</span> j = <span class="number">5</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">7</span>;</span><br><span class="line">  i = <span class="number">6</span>;</span><br><span class="line">  w = i + j;</span><br><span class="line">&#125;</span><br><span class="line">x = i + j;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">8</span>;</span><br><span class="line">  y = i + j;</span><br><span class="line">&#125;</span><br><span class="line">z = i + j;</span><br></pre></td></tr></table></figure><p>w = 13; x = 11; y = 13; z = 11;</p><h5 id="习题1-6-2"><a href="#习题1-6-2" class="headerlink" title="习题1.6.2"></a>习题1.6.2</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> w, x, y, z;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span> ; <span class="keyword">int</span> j = <span class="number">4</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">  w = i + j;</span><br><span class="line">&#125;</span><br><span class="line">x = i + j;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">6</span>;</span><br><span class="line">  i = <span class="number">7</span>;</span><br><span class="line">  y = i + j;</span><br><span class="line">&#125;</span><br><span class="line">z = i + j;</span><br><span class="line">w = <span class="number">9</span>; x = <span class="number">7</span>; y = <span class="number">13</span>; z = <span class="number">11</span>;</span><br></pre></td></tr></table></figure><h5 id="习题1-6-2-如下块结构代码，假设使用常见的声明的静态作用域规则，请指出其中12个声明中的每一个的作用域"><a href="#习题1-6-2-如下块结构代码，假设使用常见的声明的静态作用域规则，请指出其中12个声明中的每一个的作用域" class="headerlink" title="习题1.6.2 如下块结构代码，假设使用常见的声明的静态作用域规则，请指出其中12个声明中的每一个的作用域"></a>习题1.6.2 如下块结构代码，假设使用常见的声明的静态作用域规则，请指出其中12个声明中的每一个的作用域</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="keyword">int</span> w, x, y, z;    <span class="comment">/* 块B1 */</span></span><br><span class="line">  &#123; <span class="keyword">int</span> x, z;   <span class="comment">/* 块B2 */</span></span><br><span class="line">    &#123;<span class="keyword">int</span> w, x;   <span class="comment">/* 块B3 */</span>  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> w, x;        <span class="comment">/* 块B4 */</span></span><br><span class="line">    &#123;<span class="keyword">int</span> y, z;   <span class="comment">/* 块B5 */</span>  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自上至下依次</p><p>w: B1 B2<br>x: B1<br>y: B1 B2 B3 B4<br>z: B1 B4</p><p>x: B2<br>z: B2 B3</p><p>w:B3<br>x:B3</p><p>w:B4 B5<br>x:B4 B5</p><p>y:B5<br>z:B5</p><blockquote><p>还有点疑问不太确定自己的理解对不对。</p></blockquote><h5 id="习题1-6-3-下面C代码的打印结果是什么"><a href="#习题1-6-3-下面C代码的打印结果是什么" class="headerlink" title="习题1.6.3 下面C代码的打印结果是什么"></a>习题1.6.3 下面C代码的打印结果是什么</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> a(x+1)</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,x)&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">c</span><span class="params">()</span></span>&#123;<span class="keyword">int</span> x = <span class="number">1</span>;<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;b();c()&#125;</span><br></pre></td></tr></table></figure><p>2</p><p>2</p><p>感觉还是考察作用域</p><h3 id="第一章总结"><a href="#第一章总结" class="headerlink" title="第一章总结"></a>第一章总结</h3><ul><li><strong>语言处理器：</strong>一个集成的软件开发环境，其中包括很多种类的语言处理器，比如编译器、解释器、汇编器、连接器、加载器、调试器以及程序概要提取工具。</li><li><strong>编译器的步骤：</strong>一个编译器的运作需要一系列的步骤，每个步骤把源程序从一个中间表示转换成另一个中间表示。</li><li><strong>机器语言和汇编语言：</strong>机器语言是第一代程序设计语言，然后是汇编语言。使用这些语言进行编程时既费时又容易出错。</li><li><strong>编译器设计中的建模：</strong>编译器设计是理论对实践有很大影响的领域之一。已知在编译器设计中有用的模型包括自动机、文法、正则表达式、树型结构和很多其他理论概念。</li><li><strong>代码优化：</strong>虽然代码不能达到真正最优化，但提高代码效率的科学既复杂又非常重要。它是编译技术研究的一个重要部分。</li><li><strong>高级语言：</strong>随着时间的流逝，程序设计语言担负了越来越多原先由程序员负责的任务，比如内存管理、类型一致性检查和代码并发执行。</li><li><strong>编译器和计算机体系结构：</strong>编译器技术影响了计算机的体系结构，同时也受到体系结构发展的影响。体系结构中的很多现代创新都依赖于编译器能够从源程序中抽取出有效利用硬件能力的机会。</li><li><strong>软件生产率和软件安全性：</strong>使得编译器能够优化代码的技术同样能够用于多种不同的程序分析任务。这些任务既包括探测常见的程序错误，也包括发现程序可能会受到已被黑客们发现的多种入侵方式之一的伤害。</li><li><strong>作用域规则：</strong>一个x的声明的作用域是一段上下文，在此上下文中对x的使用指向这个声明。如果仅仅通过阅读某个语言的程序就能确定它的作用域，那么这个语言就使用了静态作用域，或者说词法作用域。否则这个语言就使用了动态作用域。</li><li><strong>环境：</strong>名字和内存位置关联，然后再和值相关联。这个情况可以使用环境和状态来描述。其中环境把名字映射成为存储位置，而状态则把位置映射到它的值；</li><li><strong>快结构：</strong>允许语句块相互嵌套的语言称为快结构语言。假设一个块中有一个x的声明D，而嵌套于这个块中的块B中有一个对名字x的使用。如果在这两个块之间没有其他声明了x的块，那么这个x的使用位于D的作用域内；</li><li><strong>参数传递：</strong>参数可以通过值或引用的方式从调用过程传递给被调用过程。当通过值传递的方式传递大型对象时，实际被传递的值是指向这些对象本身的引用。这样就变成了一个高效的引用调用；</li><li><strong>别名：</strong>当参数被以引用的方式（高效地）传递时，两个形式参数会指向同一个对象。这会造成一个变量的修改改变了另一个变量的值。</li></ul>]]></content>
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
            <tag> 习题 </tag>
            
            <tag> 龙书 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>生命面前，众生并不平等</title>
      <link href="/2018/07/08/%E7%94%9F%E5%91%BD%E5%AF%B9%E4%BC%97%E7%94%9F%E5%B9%B6%E4%B8%8D%E5%B9%B3%E7%AD%89/"/>
      <url>/2018/07/08/%E7%94%9F%E5%91%BD%E5%AF%B9%E4%BC%97%E7%94%9F%E5%B9%B6%E4%B8%8D%E5%B9%B3%E7%AD%89/</url>
      <content type="html"><![CDATA[<p>机缘巧合去看了《我不是药神》，我第一次看完一个电影想了那么多，当然这也跟我看过的电影少有一些关系。但是不管怎么说这真的是一部非常棒的国产电影，引人深思。</p><p>程勇是一个普通人，就像我们身边的张叔李大伯一样，他没啥大本事脾气还臭，租了一个破店面卖保健品，他卖的药就跟邻居大爷说的一样：没逑用。自然也就没啥生意了。离婚以后老婆要带着儿子去移民，上面还有个有心脑血管疾病的老爹需要照顾，人生很失败，他自己也很颓废，就像大多数普通人一样过的小心翼翼，每周带儿子去澡堂子搓个澡，完事吃个大排档，儿子想要双球鞋，很拮据但是也还能拿得出来，生活如果按照当下的轨迹往前走的话，日子过的窝囊但是还能活。所以当吕受益第一次找到他的时候，他像大多数穷人一样，穷但是有底线，犯法的事情不会干。但是老父亲进医院了，病很重，不过能治，要八万。这里我感觉特别强烈，因为我们家曾经有过一模一样的经历，我想当时的老赵应该就像此时的程勇一样无助，不同的是老赵没有遇到吕受益，没有这条违法但是能马上来钱的路子。其实程勇也是一个受害者，他迈出这一步也恰恰是因为他父亲天价的手术费。他开始走私仿制药，500进的药卖3000一瓶，他赚了6倍病人还对他感恩戴德，因为他给这些白血病人省了十倍的药费。老父亲的手术做了，吃饭的时候都嫌喂的慢了，被房东上了锁的店门也重新开了，去夜店甚至都能拿钱砸老板了—有钱是真特么好。</p><hr><p>吕受益，黄毛，思慧和老神父跟着他有药吃，有钱赚，未来充满了希望，吕受益邀请程勇去他家的时候说现在好了，有药了也有钱了，儿子结婚早的话没准他还能当爷爷呢。随着张长林的一次卖假药活动，平静的日子被打破了。程勇不是圣人，就像黄毛说的，他做这些就是为了钱，他现在有钱了就不想继续干违法的事情了，怕坐牢——他把代理权以200多万的价格卖给了张长林。散伙的时候，他说了一句：我他妈又不是白血病人 。也是啊，这世上，除了自己和至亲至爱，别人的死活与我何干，谁都没有义务帮别人。这一段特别催泪：黄毛无畏，无牵无挂，他是最决绝的，满手鲜血冲进大雨里。老牧师，年事以高，再加上职业的原因，其实也早已看穿了生死。思慧：思慧不是病人，她女儿是，加上她算是有一份可以来钱的工作。所以这些人离开的没有一点拖泥带水。唯一不同的是吕受益，他真的以为大家喝多了吗？他只是不愿意相信刚看到的希望就这样破灭了而已，他是了解程勇的，他知道他能干得出来这种事情，同时他也是最想活下去的人，自己高大帅气，老婆美丽贤惠，儿子健康可爱，他不想做英雄，他没有资本也没有勇气像其他人那样潇洒从容，生死面前，一切的大义、勇气都显得那么奢侈。直到程勇冲他喊了那声滚。他内心的绝望和无助也应该是几个人里面最强烈的，他想活着，哪怕以那种最卑微的形式。我记得吕受益说过：他看到自己的儿子就不想死了，但是最后，看了一眼老婆孩子他自杀了。他只不过是无数绝症病人中的一个而已，生命的凋零就像落叶一般稀松平常，世界并不会因为谁的死就发生改变，吕受益走了但是其他的病人还需要继续想办法让自己活下去。 这里我感觉程勇其实有一点被道德绑架的感觉，他只是个普通人，没有义务帮任何人，更何况他已经帮过好多人了。但是这就是人和机器的区别，人有感情，只有计算机才会只讲道理。 我不杀伯仁，伯仁因我而死。 就这样程勇又开始卖药了。 好多人说他在赎罪，其实他何罪之有呢？我感觉他更多的是在弥补自己内心的愧疚，他把吕受益的死怪自己头上了，他不想再发生同样的事情，所以500进的药他卖500，到后面供应紧张，2000进的药也卖500，此时的他没了当年的嚣张跋扈，多了一些沉稳内敛。而且他不再像之前那样怕坐牢了，人们老在说成熟男人的人格魅力，这一点在此刻的程勇身上很能体现。</p><hr><p>好景不长，既然是违法的事情那么肯定会有人来追究，医药代表不断施压，警方的侦破力度也不断加大，黄毛帮程勇顶罪被车撞死了，他听了勇哥的话剃了头买了回家的火车票，他才二十岁啊，他想活着犯了什么罪，真的是灵魂的拷问。如果没有跟着勇哥卖药就没有警察抓他，但是如果没有程勇，他可能跟吕受益一样活不到出车祸的时候。剧情就是这么矛盾，而且矛盾也是整部剧的精髓。一开始的时候，程勇知道这事违法，很强烈的拒绝了吕受益的，因为老父亲的病，他很矛盾但还是选择了去卖印度药；吕受益带程勇去他们家的时候指着儿子跟程勇说过，我看到他就不想死了，最后呢，看了一眼自己的儿子选择了自杀；黄毛一开始是看不起程勇的，但是他为了自己的义气，为了帮到自己的朋友们选择了跟他干；思慧知道程勇的小心思，但是为了帮助更多的病友，更重要的是为了自己的女儿，她选择了妥协，而当程勇从她家里离开的时候，她的笑是发自内心的；病人求警察别再查案，放过假药贩子；警察开慢警车，让罪犯得到应有的尊重；真正的药神是诺华，但是却因为药价昂贵被推上了风口浪尖。。。</p><hr><p>药企的根本是一个企业，企业需要盈利才能长久发展。悬壶济世不求回报那是观世音菩萨，医生是上帝赐予我们最美好的职业，无论如何我们还是应该感谢那些医药工作者们的付出，白血病是本来是绝症，但是因为诺华的格列宁，绝症变成了一个慢性病，电影里的老太太哭诉道：我吃了两年的正版要，房子吃没了家人吃垮了。。咱们换个角度，如果没有诺华，别说你有一套房子，就算你有北京城的十套别墅又能怎样？其实是诺华给了那些有能力的人拿钱买命的资格，程勇做的事让这个有能力的标准降低了一大档。努力赚钱，不仅会让生活有所改观，开好车，住大房子，更重要的是能为自己守护更多东西，程勇为他父亲的手术费犯愁的时候，吕受益老婆因为感谢程勇喝那一大杯白酒的时候，思慧为了女儿在夜店跳钢管舞的时候，黄毛为了朋友去帮那个自己压根看不上的程勇的时候，老太太哭诉自己吃药吃垮了家人，吃掉了房子的时候。。。我一直在想，如果这种事情遇到我身上我该怎么办，我能怎么办？ 寿命的长短我们无法左右，但是生活的质量是可以追求的，如果可以，我想给身边的人足够好的生活，因为在生命面前，其实并不是我们想象的那样众生平等。</p>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 药神 </tag>
            
            <tag> 生命 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>为什么 ++[[]][+[]]+[+[]] = 10？</title>
      <link href="/2018/07/06/%E4%B8%BA%E4%BB%80%E4%B9%88%20++%5B%5B%5D%5D%5B+%5B%5D%5D+%5B+%5B%5D%5D%20=%2010%EF%BC%9F/"/>
      <url>/2018/07/06/%E4%B8%BA%E4%BB%80%E4%B9%88%20++%5B%5B%5D%5D%5B+%5B%5D%5D+%5B+%5B%5D%5D%20=%2010%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p><a href="http://justjavac.com/javascript/2012/05/24/can-you-explain-why-10.html" target="_blank" rel="noopener">原文链接</a></p><p>首先，问“这个问题(英文)”的人是个天才，他怎么会遇到这样的一个问题。 其次，回答这个问题的人更是一个天才，我难以想象他会回答这个问题，更难以想象的是，他的回答是如此的详细和丰富和完整，真正称得上诲人不倦。<br>既然遇到了这个问题，我们不妨也跟着提高一下。<br>这是一个Javascript 语言题目，一个完全有效的等式，不信自己可以试一下，下面看看高人的题解：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++[[]][+[]]+[+[]]</span><br></pre></td></tr></table></figure><p>如果把这段表达式拆分开来，它相等于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">++[[]][+[]]</span><br><span class="line">+</span><br><span class="line">[+[]]</span><br></pre></td></tr></table></figure><p>在 JavaScript 里，+[] === 0 是完全正确的。 + 会把一些字符转化成数字，在这里，这个式子会变成 +”” 或 0。<br>因此，我们可以简化一下(++ 比 + 有更高的优先级)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">++[[]][<span class="number">0</span>]</span><br><span class="line">+</span><br><span class="line">[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>因为 [[]][0] 的意思是：获取 [[]] 的第一个元素，这就得出了下面的结果：</p><p>[[]][0] 返回内部数组 ([])。根据语言规范，我们说 [[]][0] === [] 是不正确的，但让我们把这个内部数组称作 A，以避免错误的写法。<br>++[[]][0] == A + 1， 因为 ++ 的意思是”加一”。<br>++[[]][0] === +(A + 1)；换句话说，你得到的永远是个数值( +1 并不一定得到的是个数值，但 ++ 一定是)。<br>同样，我们可以把这一堆代码简化的更清晰。让我们把 A 换回成 [] :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+([] + <span class="number">1</span>)</span><br><span class="line">+</span><br><span class="line">[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>在 JavaScript 里，这也是正确的：[] + 1 === “1”，因为 [] == “” (这相当于一个空的数组的内部元素连接)，于是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+([] + <span class="number">1</span>) === +(<span class="string">"” + 1)，并且</span></span><br><span class="line"><span class="string">+("</span>” + <span class="number">1</span>) === +(<span class="string">"1"</span>)，并且</span><br><span class="line">+(<span class="string">"1"</span>) === <span class="number">1</span></span><br></pre></td></tr></table></figure><p>让我们再次简化一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">+</span><br><span class="line">[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>同样，在 Javascript 里，这是正确的：[0] == “0”，因为这是相当于一个有一个元素的数组的内部元素的连接。 各元素会使用，分隔。 当只有一个元素时，你可以推论出这个过程的结果就是它自身的第一个元素。<br>所以，最终我们得到 (数字 + 字符串 = 字符串)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">+</span><br><span class="line"><span class="string">"0"</span></span><br><span class="line">=== <span class="string">"10"</span> <span class="comment">// 耶！</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 收藏 </category>
          
          <category> js技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> geek </tag>
            
            <tag> 技巧 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>阿根廷出线了</title>
      <link href="/2018/06/27/%E9%98%BF%E6%A0%B9%E5%BB%B7%E5%87%BA%E7%BA%BF%E4%BA%86/"/>
      <url>/2018/06/27/%E9%98%BF%E6%A0%B9%E5%BB%B7%E5%87%BA%E7%BA%BF%E4%BA%86/</url>
      <content type="html"><![CDATA[<p>之前上学的时候都没咋熬夜看过球，后面随着年龄越来越大，熬一次夜需要缓上一个礼拜，生病以后更是不敢熬夜了。世界杯开赛以来，其实就认真看了三场球，揭幕战俄罗斯vs沙特，第二天的葡萄牙对西班牙，我喜欢巴萨，自然也喜欢西班牙。这几场球赛看的时候其实挺佛系的，赶上就看赶不上就不看了。但是今天凌晨这场球，我是订的闹钟半夜起来看的。我喜欢梅西是一方面，更重要的是这场是梅西向世人证明自己的最后机会，是梅西给那些无良自媒体，无脑跟风的伪球迷以及人人痛恨的赌狗们扇耳光的最后机会。  </p><p>C罗第一场就帽子戏法，以一己之力生生从西班牙手里抢来了一分，而此时阿根廷被冰岛逼平，梅西罚丢点球，绝代双骄自然不可避免的被拿来对比。于是，各种冷嘲热讽和赌狗们的谩骂铺天盖地的涌过来，对阵克罗地亚又被血虐，梅西俨然成了一个笑话。 我是梅西：我现在慌的一批，我是梅西，我只是天生要凉。各种P图，各种段子霸占了各大媒体头条和朋友圈，赌狗们的歇斯底里我都懒得提。我看到有人说他二姨的朋友圈都在转那张P过的蒙牛广告，事实上这样的人可不在少数，有好多盲目跟风的人估计在这之前都不知道梅西是干嘛的，更别说看过他踢球了。试问你们谁有理由和资格去中伤一个陌生人呢？更何况梅西这样一个伟大的球员。</p><p>罪魁祸首就是那些无良媒体，为了流量啥都能写，其实大多数民众是不具备独立思考的能力的，他们的思想容易被一些看上去专业的业内消息所左右，曾经有人拿出来了一大堆所谓的权威数据来说明梅西只是个体系球员，离开巴萨啥都不是，跟风者必然是没看过球的，看着这一堆自己也不咋懂的数据，再对比这两场阿根廷的表现，恍然大悟，还真是这样。于是开始自以为懂球的大肆传播这种思想，毕竟这是有”权威数据“做支撑的，他们交流的群体自然是跟他同等水平的无知者，三人成虎，世界杯看球的真球迷能有多少，尤其这届充斥着赌狗的世界杯，于是这种奇怪的论调就开始在无知者中像病毒一样疯狂传播，不嘲讽两句梅西好像自己不懂球一样。我还记得一开始的时候说冰岛是牙医带着一堆律师，工人啥的在踢世界杯，简直是在造谣。但是这多吸引眼球啊，拿这个来埋汰国足得有多带劲儿啊，人们可不就是喜欢这种戏码吗。 我只能说，这些媒体真的坏！</p><p>所以，这场球梅西必须赢，不能让那些眼巴巴等着看你笑话的人如意了，我不由得想起了鲁迅笔下的中国人。<br>第一个进球来的很快，梅西还是那个梅西，大腿停球，趟一步，右脚射门，射门动作的流畅和高难度自不必说，这次突然启动前插让我从阿根廷身上看到了巴萨的影子，还有后面给伊瓜因的直塞球以及打到门柱前场任意球，真的特别欣慰，梅西踢球就应该是这样子的，迪马利亚跑动特别积极，马斯切拉诺也很拼命，比赛开始之前我就有莫名的自信，阿根廷肯定能赢，看到这支老年球队的顽强后我更加坚信他们一定能赢。然而，伴随着马斯切拉诺的送点，局势似乎变得复杂了起来，平均年龄最大的球队对阵平均年龄最小的球队，体力的巨大消耗加上被追平以后的心态变化，下半场开始的时候阿根廷全队不在状态，连续的传球失误，真的特别揪心。而且时间过的很快，如果再不追回来就真的没机会了，我想所有阿根廷球迷应该都像我一样在盼着有英雄出来，锋线上这么多人，随便站出来一个人都行啊。86分钟，罗霍站出来了，又是他，历史总是惊人的相似，此刻尼日利亚人估计杀了罗霍的心都有。 全场沸腾了，梅西跳到了罗霍背上，兴奋之情溢于言表，阿根廷人完成了自我救赎。梅西给了那些跟风的无知者们一记响亮的耳光，我当时最强烈的感受是扬眉吐气，真他妈解气。</p><p>下一场对阵法国，我还是觉得阿根廷能赢，因为他们有梅西。</p><p>最后我告诉每一个看球的观众一个浅显易懂的道理，场上每一位球员都比我们台下的看客更想赢，不懂的话看就好了，不是有解说嘛，发表那些自以为是的言论是对这些斗士们的极大不尊重。</p>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阿根廷 </tag>
            
            <tag> 梅西 </tag>
            
            <tag> 世界杯 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我爹今年六十六，第一次过生日</title>
      <link href="/2018/06/20/%E6%88%91%E7%88%B966%EF%BC%8C%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%BF%87%E7%94%9F%E6%97%A5/"/>
      <url>/2018/06/20/%E6%88%91%E7%88%B966%EF%BC%8C%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%BF%87%E7%94%9F%E6%97%A5/</url>
      <content type="html"><![CDATA[<p>最近老赵的电话有点勤，刚好赶上端午节放假，抓紧回家看看吧。 我回家一般都不会事先通知，并不是想给他个惊喜，而是怕他知道了以后盼的着急。</p><p>假期前一天接到我哥的电话，说是他们厂里最近停产了，他在家休息，问我端午节回家不，刚好明天老爹过生日。 </p><p>我一愣，老赵过生日。</p><p>我哥跟我嫂子帮他订了个蛋糕，我们全家人在外面吃了个饭，老赵生平第一次吹了生日蜡烛，吃了一碗长寿面。</p><p>算起来，老赵今年六十六了，在我将近三十年的记忆里他没有过过生日，也没有生日的概念。我记得在高中的时候有一次我问到这个事情，我问他的生日是什么时候，他说：” 我也不知道，可能是个六月初几吧 “。他自己都不知道自己的生日是哪天，我奶奶应该知道他的生日，但是奶奶没了都多少年了，当然我大姑或许也会记得这个弟弟的生日吧。想想真的令人唏嘘，老赵是个没有生日的人。 我哥这次也只是按照他身份证上的出生日期来过的。我突然想到，或许我应该去找大姑问问清楚老赵的真实生日，不然过不了几年这世上可就真的没有知道他的生日了。</p><p>仔细想想，从母亲病了以后，这个男人就没有再为自己活过一天。</p><p>我哥跟我嫂子在亲戚的那个群里发了一堆照片，祝老赵父亲节快乐。我还纳闷呢，结果发现第二天还真是父亲节。当然老赵不知道什么是微信群，更不知道什么父亲节。</p><p>人们常说救命之恩无以为报，养育之恩又何尝不是呢。他老去的速度远远超过了我挣钱的速度，我不得不面对他精神状态的每况日下。老赵一直不是很同意我离开现在的单位，他怕我离开以后就找不到工作了，因为在我们老家有一份稳定的工作真的很不容易。没有工作是可怕的，就像现在的他，出了一辈子苦力，但是现在的年龄不允许他继续这么干了，现在他没次试图想要出去打点零工的时候都被我阻止了，其实我也很矛盾，我不知道这样算不算是为他好，我的出发点是不想他太累，怕累坏身体，但是我也深知他赋闲在家不能挣钱的煎熬，不过几次医院的经历告诉我还是保养身体为重。老赵的养育之恩我注定报答不完了，我能做的就是尽量让他改变自己的思想，能过的尽量舒心一点，这样我心里的亏欠也能相对少一点。话又说回来，如何让他过的舒心呢，很简单，让他知道我过的很好，显然当下的状况并不足以给他证明我过的有多好，所以生活一直在逼我往前走。</p><p>他一直希望我考公务员，农村人对铁饭碗的痴迷让人匪夷所思，老人们互相拉起家常的时候，在外年薪二三十万远不如一个老家月入两千五的县政府办事员来的硬气，老赵也是一个普普通通的农村老人，他一直这么认为，每月有稳定的收入才是最踏实的，公务员们退休之后还有退休工资，这样就算赋闲在家也能保证月月有进账。而这种思想也已经开始慢慢渗透到了老家下一代脑海里，其实这也是我不愿意继续留在老家的原因，或许这只是不同的生活方式，说不上谁对谁错，但是我知道自己内心喜欢哪一种就好。</p><p>曾经的他是家里的顶梁柱，生活的窘迫，家庭的变故他都能应付自如。现如今他老了，不再像曾经那样胸有成竹，身体的衰老其实并不可怕，让一个男人真正难受的是那种力不从心和不再被需要的感觉。他曾经的骄傲在岁月面前变得一文不值。当他变得不再强势，当他开始听取我的意见，当他明明认为自己的观点正确却不再坚持的时候，我并没有感到一点点成就，更多的是那种痛彻心扉的酸楚。祈求时间过得慢一点，再慢一点。。</p><p>不过好在老赵不再是一个没有生日的人了。</p>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 父亲 </tag>
            
            <tag> 感恩 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我和blog</title>
      <link href="/2018/06/09/%E5%85%B3%E4%BA%8Eblog/"/>
      <url>/2018/06/09/%E5%85%B3%E4%BA%8Eblog/</url>
      <content type="html"><![CDATA[<p>我是个资深的前端API调用工作者，同时又是个重度<a href="https://www.zhihu.com/people/troubledot" target="_blank" rel="noopener">知乎</a>只读用户，所以每天我会看各种各样的文章，有技术文档，也有扯淡消遣的，往往后者居多。看的多了就想自己也写一点东西，美其名曰希望记录一下自己的学习和生活。</p><p>2015年开始正式从事程序员的工作，没多久就有了想写点东西的想法，其实也是当时看到我<a href="http://www.littlemusic.tv/" target="_blank" rel="noopener">同事兼师傅的个站</a>， 我就想自己也有这样一个站。适逢刚入职工作量还没有那么大，就用自己仅有的一点html和css知识，做了几个简单的静态页面，而这几个页面后面因为知识的匮乏和热情的缺失就搁浅了。这是最开始筹备，其实当时都没想过是做一个blog。</p><p>在一个性质偏国企的外包公司工作，如果你没有很强学习欲望和动力，日子荒废起来快得吓人，一转眼就到了16年年中了，我打算重新拾起来那个搁浅了的计划，注册了域名，买了个阿里云的web弹性托管，我当时还只是个入门级的切图仔，不懂主机，不懂域名，更不懂数据库，有问题全都是靠百度和问别人，感谢百度也感谢耐心的同事。 一开始用的是wordpress ，第一次访问到自己网站的时候心里还是有一点兴奋的。但是因为空间有限，我又想存挺多图，还是同事教的，七牛给每个账户10G的空间，可以把图片放到那里，这里又折腾了一个月吧，把这个也弄好了。那段时间热情还是很高的，晚上会看看犀牛书，抄点笔记到blog上，开始的计划是每周更新，记录下自己的学习进程。好景不长，可能是一次加班，可能是突然犯懒，计划制定的容易，打破的更加容易。于是这次又这样搁置了。</p><p>我看了一下最后一篇是在2017年6月1号写的，那会儿庄才结婚，今天他都生儿子了。突然发现，整整一年了。</p><p>再一次开始做blog是在今年年初吧，部门开始将提了好久的前后端分离提上了日程，前端我们用的vuejs。磕磕巴巴边学边做了一个项目以后，算是有了点基本的认识，但是在项目中我这边只负责前端这一块，非科班出身的短板一览无余，后端知识匮乏，缺少编程思维。提升不足，需要上手，刚好我想自己做我的blog，前后端都由我来做，然后又开始了折腾。 前端用vue，后端用的node的<a href="http://expressjs.com/" target="_blank" rel="noopener">express</a>框架，数据库用的mysql。花了一点功夫，调通了前后台，blog的增删改查都实现了。但是我想把他做好，每一行代码，每一格缩进，每一个函数命名，我都要做好，我想让自己做的东西看上去像是一个程序员做的东西，显然这对我来讲不是一个小工程。我花了不少时间去看express，我看了一段时间的sql语句，当然我还需要系统的学习下es6，我也需要深入研究一下vuex，可能后面还有好多我现在都说不上来的东西。我要坚持做完这个东西，因为这二十几年来我能坚持下来的事情实在少的可怜。</p><p>来来回回绕了这么久，我好像忘了自己最初想要干嘛了，我不是想要自己写点东西吗？而且随着年龄的增长，见过的人和事越来越多，有时候真的会特别想写点自己的感悟。而我那个纯手工打造的blog还需要一段时间，而且我更看重那个blog搭建的过程。但是我又想要记录一些事情，于是就有了现在这个基于github和hexo的blog的出现。我会在这里记录以后的学习和生活，等那个好了以后两边内容会保持同步。</p>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>My New Post</title>
      <link href="/2018/06/08/My-New-Post/"/>
      <url>/2018/06/08/My-New-Post/</url>
      <content type="html"><![CDATA[<h2 id="English-blog"><a href="#English-blog" class="headerlink" title="English blog"></a>English blog</h2><p>This is my first hexo blog .<br>I want to write it in english , it must be very diffcult begin do it .<br>Just do it .</p><p>Beacuse I heard a word : if what you did is easy , it’s unuseful .</p><p><img src="http://pa00if26f.bkt.clouddn.com/image/jpgv2-763c35eb9cfe47731ee6a86838dc1988_r.jpg" alt="image description"></p>]]></content>
      
      
    </entry>
    
  
  
</search>
