---
title: leetCode1——两数之和
date: 2019-07-20 13:58:27
tags: leetCode easy 
---

我打算在后面持续更新下leetCode，希望能再坚持成功一件事情，这是第一题，直接开始。

题目：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

示例:

``` js
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```

一个毫无算法基础的非科班程序员，看到这个题目直接硬刚，两层循环。

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
  for (i in nums){
    for (j in nums){
      if (i + j == target && i !== j){
        return new Array(i, j)
      }
    }
  }
};
```

可能一开始刷leetCode会有点吃力，会有考虑不周的地方，但是也还算有思路，比如我第一次做的时候就没想到要排除i和j相等的情况。

最后提交的时候执行用时：5808 ms，好像超过了5%的人，就是菜鸟的意思。

我后面试过递归，也没能行，想不明白了，那就翻答案吧，然后就了解到了一个新的概念——哈希表。

一个完全陌生的概念，加上官方答案里面是java代码，而且这道题貌似考察的就是哈希表，我上网查了下关于哈希表的概念，大多数都比较晦涩，直到看到了[这篇文章](https://www.zhihu.com/question/330112288/answer/744362539)，文中举的停车场的例子真的生动至极，让人茅塞顿开。

具体什么是哈希表呢？如果我能把这个东西说清楚那么应该就算是理解了吧。

哈希表也叫散列表，在维基百科里面是这么解释的：

> 散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。

这里有几个关键字：**键（key）**，**散列函数**。

想象一下这样一种场景，有几个数字，2312、1333、1236、2580、9362、9457。

我们需要把这几个数字存起来，并且我需要某一个数字的时候能快速找到，有什么好的办法？

第一种办法，直接存数组里面：

```js
  var a = [2312,1333,1236,2580,9362,9457]
```

如果我需要9362，那么从a[0]开始一个个往后找，找到9362为止，这里会涉及到一个复杂度的问题，不细究了，总之我们能想象到这显然不是一个好办法，如果数字足够多，而你要找的又在最后那就很慢了。再快一点的找法，把a从小到大排序，从中间开始找，9362大于中间的数，那么我们直接往后找，这样能够快一点，但是显然还是不够快。

第二种办法，像下面这样一个表我们把这几个数按照一定的规则插入表中，并假定这个规则为关键字除以10的余数作为地址。

地址  | 空表 |插入2312|插入1333|插入1236|插入2580|插入9362|插入9457
:-:  | :-:  | :-:   | :-:   | :-:    | :-:   | :-:   | :-:   |
0    |      |       |       |        |  2580 | 2580  | 2580  |
1    |      |       |       |        |       |       |       |
2    |      | 2312  | 2312  |  2312  |  2312 | 2312  | 2312  |
3    |      |       | 1333  |  1333  |  1333 | 1333  | 1333  |
4    |      |       |       |        |       |**9362**|**9362**|
5    |      |       |       |        |       |       |       |
6    |      |       |       |  1236  |  1236 | 1236  | 1236  |
7    |      |       |       |        |       |       | 9457  |
8    |      |       |       |        |       |       |       |
9    |      |       |       |        |       |       |       |

插入数据的过程中，2312和9362除以10取余都是2，所以在插入9362的时候，在2号位置上已经有了2312，这时候就出现了哈希中的**冲突**，解决冲突的办法很多，我们用了最简单的往后顺延存到3号位置上，发现3号位置也被占用了，那就继续往后存到4号上了。

我们来看下这样存入数据以后查的时候真的会很快吗？
比如说我要查2312，用根据哈希函数除以10取余为2，我们知道应该去2号位置找，直接hash[2],就是2312。
再查找一个9362，同样我们根据哈希函数去2号位置找，发现不是9362，确定哈希函数没有问题的话那么知道这肯定是冲突了，这里我们知道冲突解决的规则是往后顺延，直接找3号位置，发现也不是继续顺延hash[4]是9362了。
发现这样找起来的确比较省事，如果没有发生冲突的话，一次就找到了。关于冲突的问题又会衍生出来好多内容，以后如果需要再细究。

这里我们可以看到最后的结果好像也是一个数组，与其说数组其实更像是一个对象，毕竟数组给我们的印象大都是连续的。


```js
obj = {
  '0': '2580',
  '1': '',
  '2': '2312',
  '3': '1333',
  '4': '9362',
  '5': '',
  '6': '1236',
  '7': '9457',
  '8': '',
  '9': ''
}
```

>其实，js中的对象底层就是哈希表。

不难看出来所谓“哈希表”，其实就是一个对象，而这个对象的键值（key）长得跟数组的索引（index）一样。

大致了解了哈希，我们再看这个题目，大致思路：

1. 把这些数字(num)挨个往哈希表中插入；
2. 插入的时候判断一下目标数字(target - num)是否存在于哈希表中，存在就返回索引不存在就插入哈希表中；

代码如下：

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
  let hash = {}
  for (let i = 0; i < nums.length; i++){
    if( target-nums[i] in hash){
      return [hash[target-nums[i]], i]
    } else {
      hash[nums[i]] = i
    }
  }
};
```

我们在插入哈希表的时候用 *hash[nums[i]] = i*，这样得到的哈希表中值是数组索引，而键是数组中的值。
拿测试的例子就是这样子：

```js
// 数组
nums = [2, 7, 11, 15]
// 哈希
{
  '2': '0',
  '7': '1',
  '11': '2',
  '15': '3'
}
```

这样的好处就在于我们可以用in运算符去判断目标值是否在哈希表中：*target-nums[i] in hash*

最后也能以目标值作为键来取到索引 *hash[target-nums[i]]*

这下好了，超过了99.57%。

![99.57%](http://res.troubledot.cn/twosum.png)

再去看看别人的写法，真的是大开眼界，强烈建议去刷国外的leetcode，那上面讨论更多，有意思的答案更多。

比如可以把里面的判断写一个方法用some来执行：

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
  let hash = {}
  let res = []
  nums.some((num, index)=>{
    const k = target - num
    if(k in hash){
      res = [hash[k], index]
      return true
    } else {
      hash[num] = index
    }
  })
    return res
};
```

这里注意最后需要返回值，我自己照着写的时候把返回值写在some里面的方法中，最后整个函数没有返回值，一直是undefined。

还有好多有意思的代码就不意义罗列了，看别人的代码，真的长姿势！！

第一道leetCode，写的有点啰嗦，后面慢慢简略点。
