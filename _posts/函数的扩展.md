---
title: 函数的扩展
date: 2019-01-16 14:48:13
tags:
---

### 1.函数参数的默认值

#### 基本用法

es6之前，函数的参数不能给默认值的，如果一定要给，只能用变通的方法；

```javascript
function log(x,y){
  y = y||'Word';
  console.log(x,y)
}
log('Hello') // Hello World
log('Hello', 'China') // Hello China
log('Hello', '') // Hello World
```

这样的问题就在于如果y是一个boll值为false的值，那么他就会取到默认值。就像上面最后一行代码，我们预期输出的应该是‘Hello ’，但是因为我们给y赋的值对应的布尔值为false，所以他最后读了默认值World。这里我们就需要额外判断一次y是否被赋值。

```JavaScript
if (typeof y === 'undefined') {
  y = 'World';
}
```

但是现在es6解决了这个问题，我们可以在定义参数的时候直接为其赋一个默认值。

```JavaScript
function log(x, y = 'World') {
  console.log(x, y);
}

log('Hello') // Hello World
log('Hello', 'China') // Hello China
log('Hello', '') // Hello
```

这样的写法比较自然也符合我们正常的思维。

```JavaScript
function Point(x = 0, y = 0) {
  this.x = x;
  this.y = y;
}

const p = new Point();
p // { x: 0, y: 0 }
```

除了简洁，ES6 的写法还有两个好处：首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。

参数变量是默认声明的，所以不能用let或const再次声明。

```JavaScript
function foo(x = 5) {
  let x = 1; // error
  const x = 2; // error
}
```

上面代码中，参数变量x是默认声明的，在函数体中，不能用let或const再次声明，否则会报错。

使用参数默认值时，函数不能有同名参数。

```JavaScript
// 不报错
function foo(x, x, y) {
  // ...
}

// 报错
function foo(x, x, y = 1) {
  // ...
}
// SyntaxError: Duplicate parameter name not allowed in this context

```

另外，一个容易忽略的地方是，参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。

```JavaScript
let x = 99;
function foo(p = x + 1) {
  console.log(p);
}

foo() // 100

x = 100;
foo() // 101
```

上面代码中，参数p的默认值是x + 1。这时，每次调用函数foo，都会重新计算x + 1，而不是默认p等于 100。

#### 与解构赋值默认值结合使用

参数默认值可以和解构赋值的默认值结合起来使用。

```JavaScript
function foo({x, y = 5}) {
  console.log(x, y);
}

foo({}) // undefined 5
foo({x: 1}) // 1 5
foo({x: 1, y: 2}) // 1 2
foo() // TypeError: Cannot read property 'x' of undefined
```
